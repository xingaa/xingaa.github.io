<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>钱钱的博客</title><meta name="description" content="钱钱的博客"/><meta name="google-site-verification" content="JPHZGs4Zk2iX0LKmv_kGBKtIfuo3rUJCO0AD6aP8bYc"/><link rel="icon" href="/CarStation.svg"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/6e0c8d9ced1e22d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e0c8d9ced1e22d0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6d4c10de180651ed.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6d4c10de180651ed.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7180b5018c6594e2.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-a6a17768821d805e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-cc4289bbb2571876.js" defer=""></script><script src="/_next/static/chunks/647-2045c5df6fd5ed37.js" defer=""></script><script src="/_next/static/chunks/pages/index-5c118ed60903b6a2.js" defer=""></script><script src="/_next/static/kRrtnNUirzJtMh_xDWC5r/_buildManifest.js" defer=""></script><script src="/_next/static/kRrtnNUirzJtMh_xDWC5r/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="rootPage"><div class="pageHeader" style="background-image:url(/_next/static/media/sea-bg.34630b96.jpg)"><div class="pageHeaderContent"><div> 钱仔のマスター </div><div class="pageHeaderContentsub">不因虚度年华而悔恨,也不因碌碌无为而羞耻</div></div></div><div class="layouts"><div class="layoutsmenu"><div class="layoutsmenufixed" style="height:0"><div class="players"><button type="button" class="ant-btn ant-btn-link layoutsButton" disabled=""><span role="img" aria-label="home" class="anticon anticon-home"><svg viewBox="64 64 896 896" focusable="false" data-icon="home" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M946.5 505L560.1 118.8l-25.9-25.9a31.5 31.5 0 00-44.4 0L77.5 505a63.9 63.9 0 00-18.8 46c.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8a63.6 63.6 0 0018.7-45.3c0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204zm217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z"></path></svg></span><span>主页</span></button><button type="button" class="ant-btn ant-btn-link layoutsButton"><span role="img" aria-label="snippets" class="anticon anticon-snippets"><svg viewBox="64 64 896 896" focusable="false" data-icon="snippets" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M832 112H724V72c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v40H500V72c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v40H320c-17.7 0-32 14.3-32 32v120h-96c-17.7 0-32 14.3-32 32v632c0 17.7 14.3 32 32 32h512c17.7 0 32-14.3 32-32v-96h96c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM664 888H232V336h218v174c0 22.1 17.9 40 40 40h174v338zm0-402H514V336h.2L664 485.8v.2zm128 274h-56V456L544 264H360v-80h68v32c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-32h152v32c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-32h68v576z"></path></svg></span><span>刷新页面</span></button><button type="button" class="ant-btn ant-btn-link layoutsButton"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span><span>我的主页</span></button></div></div><div class="adminControl"><span class="adminControl-line1"></span><span class="adminControl-line2"><span class="adminControl-line4"></span></span><span class="adminControl-line3"></span></div></div><div class="layoutsMain"><div class="Home_container__bCOhY"><main class="Home_main__nLjiQ"><div class="Home_content__Zy02X"></div></main></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"datas":[{"id":116,"art_title":"windows 使用 Git Bash 上下箭头不生效的解决方案","art_content":"\u003ch1 style=\"text-align: start;\"\u003e使用数字代替\u003c/h1\u003e\u003cblockquote\u003e\u003cspan style=\"color: rgb(85, 86, 102); background-color: rgb(238, 240, 244); font-size: 16px;\"\u003ewindows 中的使用上下键不生效的情况下，可以用数字代替进行选择\u003c/span\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1671785228784.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003ch1 style=\"text-align: start;\"\u003e使用 winpty\u003c/h1\u003e\u003cp style=\"text-align: start;\"\u003e这里以 \u003cspan style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 14px;\"\u003e\u003ccode\u003evue create\u003c/code\u003e\u003c/span\u003e 创建项目为例：\u003cbr\u003e将\u003c/p\u003e\u003cpre style=\"text-align: start;\"\u003e\u003ccode class=\"language-bash\"\u003evue create hello-world\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e改为：\u003c/p\u003e\u003cpre style=\"text-align: start;\"\u003e\u003ccode class=\"language-prism language-bash has-numbering\"\u003ewinpty vue.cmd create hello-world\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: red; font-size: 19px;\"\u003e这个时候出现的命令行，将可以使用上下箭头的功能了。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-23T08:48:17.000Z","art_tags":4},{"id":115,"art_title":"bing搜索提交url接口，实现自动化提交","art_content":"\u003cp style=\"line-height: 1.5;\"\u003e收录网址 \u003ca href=\"https://www.bing.com/webmasters/submiturl\" target=\"_blank\"\u003ehttps://www.bing.com/webmasters/submiturl\u003c/a\u003e \u003c/p\u003e\u003cp style=\"line-height: 1.5;\"\u003e接口文档 \u003ca href=\"https://www.bing.com/webmasters/url-submission-api#APIs\" target=\"_blank\"\u003ehttps://www.bing.com/webmasters/url-submission-api#APIs\u003c/a\u003e \u003c/p\u003e\u003cp style=\"line-height: 1.5;\"\u003eapikey获取 \u0026nbsp;\u003ca href=\"https://learn.microsoft.com/en-us/bingwebmaster/getting-access?source=recommendations#using-api-key\" target=\"_blank\"\u003ehttps://learn.microsoft.com/en-us/bingwebmaster/getting-access?source=recommendations#using-api-key\u003c/a\u003e \u003c/p\u003e\u003cp style=\"line-height: 1.5;\"\u003e\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e \u003c/span\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1671782199531.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003cspan style=\"color: transparent;\"\u003e \u003c/span\u003e\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e \u003c/span\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-23T08:04:57.000Z","art_tags":4},{"id":114,"art_title":"nextjs跨域问题解决","art_content":"\u003cp\u003e找到根目录下的 next.config.js 文件\u003c/p\u003e\u003cp\u003e废话不多说，直接上代码\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  swcMinify: true,\r\n  rewrites:async ()=\u0026gt;{\r\n    return [{\r\n      source: '/webmaster/api.svc/json/:slug*',\r\n      destination: `https://www.bing.com/webmaster/api.svc/json/:slug*`,\r\n    },]\r\n  }\r\n}\r\n\r\nmodule.exports = nextConfig\r\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003esource \u0026nbsp; \u0026nbsp;匹配字段，请求路径匹配到该字段将代理到destination字段的接口地址\u003cbr\u003e:slug* \u0026nbsp; \u0026nbsp; \u0026nbsp;为不同接口的不同路径，可视为一个变量，接收匹配字段的后半段路径\u003c/blockquote\u003e","art_author":"yellow star","art_createtime":"2022-12-23T08:02:11.000Z","art_tags":4},{"id":112,"art_title":"各个平台搜索引擎的收录网址","art_content":"\u003ch2\u003e百度\u003c/h2\u003e\u003cp\u003e \u003ca href=\"https://ziyuan.baidu.com/linksubmit/url\" target=\"_blank\"\u003ehttps://ziyuan.baidu.com/linksubmit/url\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1671778075822.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003ch2\u003ebing\u003c/h2\u003e\u003cp\u003e \u003ca href=\"https://www.bing.com/webmasters\" target=\"_blank\"\u003ehttps://www.bing.com/webmasters\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1671778145778.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003ch2\u003eGoogle\u003c/h2\u003e\u003cp\u003e \u003ca href=\"https://search.google.com/search-console\" target=\"_blank\"\u003ehttps://search.google.com/search-console\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1671778194424.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-23T06:50:19.000Z","art_tags":10},{"id":111,"art_title":"错误边界（Error Boundaries）","art_content":"\u003cp style=\"text-align: start;\"\u003e部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e错误边界是一种 React 组件，这种组件\u003cstrong\u003e可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI\u003c/strong\u003e，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e错误边界是一种 React 组件，这种组件\u003cstrong\u003e可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI\u003c/strong\u003e，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。\u003c/p\u003e\u003cblockquote style=\"text-align: start;\"\u003e注意\u003cbr\u003e错误边界无法捕获以下场景中产生的错误：\u003cbr\u003e事件处理（了解更多）\u003cbr\u003e异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\u003cbr\u003e服务端渲染\u003cbr\u003e它自身抛出来的错误（并非它的子组件）\u003c/blockquote\u003e\u003cp style=\"text-align: start;\"\u003e如果一个 class 组件中定义了 \u003ca href=\"https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror\" target=\"\"\u003e\u003ccode\u003estatic getDerivedStateFromError()\u003c/code\u003e\u003c/a\u003e 或 \u003ca href=\"https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch\" target=\"\"\u003e\u003ccode\u003ecomponentDidCatch()\u003c/code\u003e\u003c/a\u003e 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 \u003cspan style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"\u003e\u003ccode\u003estatic getDerivedStateFromError()\u003c/code\u003e\u003c/span\u003e 渲染备用 UI ，使用 \u003cspan style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"\u003e\u003ccode\u003ecomponentDidCatch()\u003c/code\u003e\u003c/span\u003e 打印错误信息。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {    // 更新 state 使下一次渲染能够显示降级后的 UI    return { hasError: true };  }\n  componentDidCatch(error, errorInfo) {    // 你同样可以将错误日志上报给服务器    logErrorToMyService(error, errorInfo);  }\n  render() {\n    if (this.state.hasError) {      // 你可以自定义降级后的 UI 并渲染      return \u0026lt;h1\u0026gt;Something went wrong.\u0026lt;/h1\u0026gt;;    }\n    return this.props.children; \n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e然后你可以将它作为一个常规组件去使用：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u0026lt;ErrorBoundary\u0026gt;\n  \u0026lt;MyWidget /\u0026gt;\n\u0026lt;/ErrorBoundary\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e错误边界的工作方式类似于 JavaScript 的 \u003cspan style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"\u003e\u003ccode\u003ecatch {}\u003c/code\u003e\u003c/span\u003e，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e注意\u003cstrong\u003e错误边界仅可以捕获其子组件的错误\u003c/strong\u003e，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 \u003cspan style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"\u003e\u003ccode\u003ecatch {}\u003c/code\u003e\u003c/span\u003e 的工作机制。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-20T07:46:06.000Z","art_tags":4},{"id":110,"art_title":"nginx配置解决访问静态资源跨域问题","art_content":"\u003cp\u003e在nginx.conf文件中location添加header配置项打开访问来源\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e   server {\n        listen       88; ## 端口\n        server_name  localhost; ## 域名\n        location / {  ## 匹配路径\n            add_header 'Access-Control-Allow-Origin' '*';\n            add_header 'Access-Control-Allow-Credentials' 'true';\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n            add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n            root   /www/www; ##  文件根目录\n            index  index.html index.htm; ## 默认页名称\n            if (!-e $request_filename) {\n       \t rewrite ^/(.*) /index.html last;\n        \tbreak;\n            }\n        }\n        error_page   500 502 503 504  /50x.html; ## 报错编码对应页面\n        location = /50x.html {\n            root   html;\n        }\n    }\n    \u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-16T05:56:23.000Z","art_tags":4},{"id":109,"art_title":"react项目前端跨域请求解决方案","art_content":"\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e通过middleware中间件的方式设置proxy\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e安装插件\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eyarn add http-proxy-middleware --save\r\n或\r\nnpm install http-proxy-middleware --save\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e安装middleware插件后，在src目录中新建setupProxy.js文件，在文件中放入如下代码：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst { createProxyMiddleware } = require('http-proxy-middleware')\r\n\r\n// 通常使用这种方式就够了，如果报错，可以使用下面的方法\r\nmodule.exports = function (app) {\r\n    app.use(\r\n        proxy('/api1', {     // 遇见/api1开头的请求，触发改代理配置\r\n            target: 'http://172.16.136.249:8080',       // 请求转发给谁\r\n            secure: false,\r\n            changeOrigin: true,     // 控制服务器收到的请求头中的Host值，默认false，意思为服务端收到的Host值是我们自己本的地址，开启以后，服务端收到的就会他自己的地址\r\n            pathRewrite: {\r\n              \"^/api1\": \"/api\"      // 把所有/api1重写成api\r\n            }\r\n        }),\r\n        proxy('/api2', {\r\n            target: 'http://172.16.136.250:8080',\r\n            secure: false,\r\n            changeOrigin: true,\r\n            pathRewrite: {\r\n              \"^/api2\": \"/api\"\r\n            }\r\n        })\r\n    )\r\n}\n\n\r\n//已采用方法，没有问题\r\nmodule.exports = function (app) {\r\n    app.use(\r\n        createProxyMiddleware('/api', {\r\n            target: 'http://172.16.136.249:8080',\r\n            secure: false,\r\n            changeOrigin: true,\r\n            pathRewrite: {\r\n              \"^/api\": \"/api\"\r\n            }\r\n        })\r\n    )\r\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e在\u003cspan style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003esetupProxy.js文件中不能使用\u003c/span\u003erequire直接引用本地项目文件，可能和打包后路径偏差影响有关\u003c/blockquote\u003e","art_author":"yellow star","art_createtime":"2022-12-15T03:24:52.000Z","art_tags":4},{"id":108,"art_title":"解决mobx6数据更新react无法实时渲染问题","art_content":"\u003cp style=\"text-align: start;\"\u003euseObserver 的使用几乎和 Class 组件的 render 函数的使用方式一致。事实上也确实如此，而且他的使用规则也很简单，直接把需要返回的 Node 用该 hooks 包裹后再返回就可以了。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e经过这样处理的组件，就可以成功监听数据的变化，当数据变化的时候，会触发组件的重渲染。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport { useObserver } from 'mobx-react'\n\n...\n\nreturn useObserver(() =\u0026gt; (\r\n    \u0026lt;div\u0026gt;\r\n        ...\r\n    \u0026lt;/div\u0026gt;\r\n  ))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-14T02:06:22.000Z","art_tags":4},{"id":107,"art_title":"React.memo()、useCallback()、useMemo()实现减少子组件渲染","art_content":"\u003ch2\u003eReact.memo()\u003c/h2\u003e\u003cp\u003eReact.memo 为高阶组件。它与React.PureComponent非常相似。\u003c/p\u003e\u003cp\u003e默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。这与shouldComponentUpdate 方法的返回值相反。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nfunction areEqual(prevProps, nextProps) {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n}\r\nexport default React.memo(MyComponent, areEqual);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e问题：\u003c/strong\u003e如果此时在子组件引用了事件处理函数的话， React.memo()将会失效，因为父组件在每次重新渲染时，定义的事件函数也会重新声明，对子组件来说，该事件属性已经发生改变了所以每次都会重新渲染；\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u0026lt;ChildMemo name={name} onClick={(newName) =\u0026gt; setName(newName)}/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cblockquote style=\"text-align: start;\"\u003e注意: 如果直接使用\u003cspan style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"\u003e\u003ccode\u003euseState\u003c/code\u003e\u003c/span\u003e解构的setName传给子组件, 子组件将不会重复渲染，因为解构出来的是一个memoized 函数。\u003c/blockquote\u003e\u003cpre style=\"text-align: start;\"\u003e\u003ccode class=\"language-javascript\"\u003e\u0026lt;ChildMemo name={name} onClick={setName}/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如何解决因事件函数产生的重复渲染呢，这个时候需要用到useCallback()了\u003c/p\u003e\u003ch2\u003euseCallback()\u003c/h2\u003e\u003cp\u003e\u003cspan style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e把内联回调函数及依赖项数组作为参数传入 \u003c/span\u003euseCallback\u003cspan style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e，它将返回该回调函数的\u003c/span\u003ememoized回调函数\u003cspan style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e，该回调函数仅在某个依赖项改变时才会更新\u003c/span\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cspan style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"\u003e\u003ccode\u003ememoized\u003c/code\u003e\u003c/span\u003e回调函数: 使用一组参数初次调用函数时，缓存参数和计算结果，当再次使用相同的参数调用该函数时，直接返回相应的缓存结果。(返回对应饮用，所以恒等于 ===)\u003c/blockquote\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u0026lt;ChildMemo name={name} onClick={ useCallback((newName: string) =\u0026gt; setName(newName), []) }/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003euseMemo()\u003c/h2\u003e\u003cp\u003e\u003cspan style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e上面的例子中，name 属性是个字符串，如果换成传递对象会怎样？\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst userInfo={name:\"jack\",age:16}\nreturn (\n    ...\n    \u0026lt;ChildMemo userInfo={userInfo} /\u0026gt;\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e更新父组件的其他state变量，看到子组件每次都重新渲染了。\u003cbr\u003e分析原因跟调用函数是一样的：\u003c/p\u003e\u003cul\u003e\u003cli\u003e更新父组件state，触发父组件重新渲染；\u003c/li\u003e\u003cli\u003e父组件渲染，userInfo 会重新生成一个新对象，导致传递给子组件的 userInfo 属性值变化，进而导致子组件重新渲染。\u003c/li\u003e\u003cli\u003e注意: 如果使用\u003ccode\u003euseState\u003c/code\u003e解构的userInfo, 子组件将不会重复渲染，因为解构出来的是一个memoized 值。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e解决：\u003cspan style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e使用 useMemo 将对象属性包一层。useMemo()返回一个 memoized 值。\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst userInfo = useMemo(() =\u0026gt; ({ name: \"小明\", age: 18 }), []);\nreturn (\n    ...\n    \u0026lt;ChildMemo userInfo={userInfo} /\u0026gt;\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-08T02:48:09.000Z","art_tags":8},{"id":106,"art_title":"全网置灰特效如何做到的？","art_content":"\u003cp style=\"text-align: start;\"\u003e在网站控制台中，在根目录html节点找到了这个属性\u003cspan style=\"background-color: rgb(245, 219, 77);\"\u003e filter: grayscale(1); \u003c/span\u003e将它删除，置灰特效就消失了，那来了解一下吧\u003c/p\u003e\u003ch1 style=\"text-align: start;\"\u003efilter\u003c/h1\u003e\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS\" target=\"\"\u003eCSS\u003c/a\u003e属性 \u003ccode\u003e\u003cstrong\u003efilter\u003c/strong\u003e\u003c/code\u003e 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。\u003c/p\u003e\u003cp\u003eCSS 标准里包含了一些已实现预定义效果的函数。你也可以参考一个 SVG 滤镜，通过一个 URL 链接到 SVG 滤镜元素（\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter\" target=\"\"\u003eSVG filter element\u003c/a\u003e）。\u003c/p\u003e\u003ch2\u003e\u003cspan style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e\u003ccode\u003e\u003cstrong\u003egrayscale()\u003c/strong\u003e\u003c/code\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e\u003cspan style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e 对图片进行灰度转换，它是 \u003c/span\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter-function\" target=\"\" style=\"text-align: start;\"\u003e\u003cspan style=\"background-color: var(--code-background-inline);\"\u003e\u003ccode\u003e\u0026lt;filter-function\u0026gt;\u003c/code\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e 的子属性。\u003c/span\u003e\u003c/p\u003e\u003ch2\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter-function/grayscale#%E8%AF%AD%E6%B3%95\" target=\"\"\u003e语法\u003c/a\u003e\u003c/h2\u003e\u003cpre\u003e\u003ccode class=\"language-css\"\u003egrayscale(amount)\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e参数\u003c/h3\u003e\u003cp\u003eamount\u003c/p\u003e\u003cp\u003e转换值的大小，可以是\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/number\" target=\"\"\u003e\u003cspan style=\"background-color: var(--code-background-inline);\"\u003e\u003ccode\u003e\u0026lt;number\u0026gt;\u003c/code\u003e\u003c/span\u003e\u003c/a\u003e 或 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage\" target=\"\"\u003e\u003cspan style=\"background-color: var(--code-background-inline);\"\u003e\u003ccode\u003e\u0026lt;percentage\u0026gt;\u003c/code\u003e\u003c/span\u003e\u003c/a\u003e. 当值为 100% 时，灰度最大。0% 时与原图没有区别。0% 到 100% 之间的值会使灰度线性变化。amount 为空时使用值为\u003cspan style=\"background-color: var(--code-background-inline);\"\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/span\u003e.\u003c/p\u003e\u003ch2\u003e例子\u003c/h2\u003e\u003cpre\u003e\u003ccode class=\"language-css\"\u003egrayscale(0)     /* 无效果 */\ngrayscale(.7)    /* 70% 灰度 */\ngrayscale(100%)  /* 灰度最大 */\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-06T01:29:09.000Z","art_tags":4},{"id":105,"art_title":"TS 中 interface 和 type 究竟有什么区别？","art_content":"\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003e前言\u003c/h2\u003e\u003cp\u003e我在学习 TS 时遇到了一个问题：\u003c/p\u003e\u003cp\u003e比如下面这个例子，可以用 type，也可以用 interface。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface Person {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Person = {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003einterface\u003c/h2\u003e\u003cp\u003einterface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface Person {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003etype\u003c/h2\u003e\u003cp\u003etype (类型别名)，顾名思义，类型别名只是给类型起一个新名字。\u003cstrong\u003e它并不是一个类型，只是一个别名而已\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他\u003ccode\u003e字母哥\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e就像我们项目中配置 \u003ccode\u003ealias\u003c/code\u003e，不用写相对路径就能很方便地引入文件\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eimport componentA from '../../../../components/componentA/index.vue'\n变成\nimport componentA from '@/components/componentA/index.vue\n复制代码\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e有了 type，我们书写 TS 的时候可以更加方便简洁。\u003c/p\u003e\u003cp\u003e比如下面这个例子，\u003ccode\u003egetName\u003c/code\u003e 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Name = string\ntype NameResolver = () =\u0026gt; string\ntype NameOrResolver = Name | NameResolver          // 联合类型\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n\n    }\n    else {\n        return n()\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样调用时传字符串和函数都可以。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003egetName('lin')\ngetName(() =\u0026gt; 'lin')\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果传的格式有问题，就会提示。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003e两者相同点\u003c/h2\u003e\u003ch3\u003e都可以定义一个对象或函数\u003c/h3\u003e\u003cp\u003e定义对象前面已经说了，我们来看一下如何定义函数。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype addType = (num1:number,num2:number) =\u0026gt; number\n\ninterface addType {\n    (num1:number,num2:number):number\n}\n这两种写法都可以定义函数类型\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst add:addType = (num1, num2) =\u0026gt; {\n    return num1 + num2\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e都允许继承（extends）\u003c/h3\u003e\u003cp\u003e我们定义一个 Person 类型和 Student 类型，\u003cstrong\u003eStudent 继承自 Person\u003c/strong\u003e，可以有下面四种方式\u003c/p\u003e\u003ch4\u003einterface 继承 interface\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface Person { \n  name: string \n}\ninterface Student extends Person { \n  grade: number \n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst person:Student = {\n  name: 'lin',\n  grade: 100\n}\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003etype 继承 type\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Person = { \n  name: string \n}\ntype Student = Person \u0026 { grade: number  }    用交叉类型\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003einterface 继承 type\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Person = { \n  name: string \n}\n\ninterface Student extends Person { \n  grade: number \n}\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003etype 继承 interface\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface Person { \n  name: string \n}\n\ntype Student = Person \u0026 { grade: number  }    用交叉类型\u003c/code\u003e\u003c/pre\u003e\u003cp\u003einterface 使用 extends 实现继承， type 使用交叉类型实现继承\u003c/p\u003e\u003ch2\u003e两者不同点\u003c/h2\u003e\u003ch3\u003etype 可以，interface 不行\u003c/h3\u003e\u003cblockquote\u003e类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 -- TS 文档\u003c/blockquote\u003e\u003ch4\u003e声明基本类型、联合类型、交叉类型、元组\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Name = string                              // 基本类型\n\ntype arrItem = number | string                  // 联合类型\n\nconst arr: arrItem[] = [1,'2', 3]\n\ntype Person = { \n  name: Name \n}\n\ntype Student = Person \u0026 { grade: number  }       // 交叉类型\n\ntype Teacher = Person \u0026 { major: string  } \n\ntype StudentAndTeacherList = [Student, Teacher]  // 元组类型\n\nconst list:StudentAndTeacherList = [\n  { name: 'lin', grade: 100 }, \n  { name: 'liu', major: 'Chinese' }\n]\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003einterface可以，type 不行\u003c/h3\u003e\u003ch4\u003e合并重复声明\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface Person {\n    name: string\n}\n\ninterface Person {         // 重复声明 interface，就合并了\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e重复声明 type ，就报错了\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Person = {\n    name: string\n}\n\ntype Person = {     // Duplicate identifier 'Person'\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003e小结\u003c/h2\u003e\u003cp\u003einterface 和 type 被 TS 设计出来，是完全不同的东西，有各自的职责。\u003c/p\u003e\u003cp\u003einterface 是\u003cstrong\u003e接口\u003c/strong\u003e，用于描述一个对象。\u003c/p\u003e\u003cp\u003etype 是\u003cstrong\u003e类型别名\u003c/strong\u003e，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\u003c/p\u003e\u003cp\u003e只是有时候两者都能实现同样的功能，才会经常被混淆。\u003c/p\u003e\u003cp\u003e平时开发中，一般\u003cstrong\u003e使用组合或者交叉类型\u003c/strong\u003e的时候，用 type。\u003c/p\u003e\u003cp\u003e一般要用类的 \u003cstrong\u003eextends\u003c/strong\u003e 或 \u003cstrong\u003eimplements\u003c/strong\u003e 时，用 interface。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e原文： \u003ca href=\"https://juejin.cn/post/7063521133340917773\" target=\"_blank\"\u003ehttps://juejin.cn/post/7063521133340917773\u003c/a\u003e \u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-05T01:31:14.000Z","art_tags":4},{"id":104,"art_title":"谈一谈 CSS框架TailwindCSS","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669969207140.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e网上收集了一点信息，简单说一下我的理解\u003c/p\u003e\u003cp\u003e先说立场：如果让我选择的话，我不会主动使用TailwindCSS。\u003c/p\u003e\u003cp\u003eTailwindCSS框架其实就是将很多的css属性直接class命名单独包装好直接在dom里使用，这样有个优点就是可以不写css文件一切样式皆在元素内实现，但是我认为通过行内样式也可以实现；\u003c/p\u003e\u003cp\u003e还有一个优点也是我网上看到很多用户喜欢的一点，使用tailwind可以让你在编码的时候不用再饱受class命名的纠结了，其实我个人开发的时候对于命名问题并没有那么折磨，个人喜欢继承式驼峰命名，并不会太纠结，虽然命名很随意，而且现在用css module并不会担心命名冲突问题，而且我觉得使用TailwindCSS会让元素变得臃肿，而且对于我这种记性不好的，再去记一套名称，真的是灾难；\u003c/p\u003e\u003cp\u003e我认为一套框架的出现应该是会让原有的方式发生跳跃式的改变，就比如jQuery、React框架的出现对原生开发的影响一样；所以我不看好TailwindCSS；\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-html\"\u003e/* 行内样式 */\n\u0026lt;div style=\"{ borderRadius: '0.5rem', padding: '1rem' }\"\u0026gt; Click \u0026lt;/div\u0026gt;\r\n\r\n/* TailwindCSS */\n\u0026lt;div class=\"rounded-lg p-4\"\u0026gt; Click \u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-12-02T08:22:02.000Z","art_tags":4},{"id":103,"art_title":"最近看的一部爽剧《财阀家的小儿子》","art_content":"\u003cp style=\"text-align: start;\"\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669600845465.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003ch1 style=\"text-align: start;\"\u003e财阀家的小儿子 \u003cspan style=\"color: rgb(229, 57, 53); font-size: 15px;\"\u003e更新至6集\u003c/span\u003e\u003c/h1\u003e\u003cp\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e豆瓣评分：\u003c/span\u003e \u0026nbsp;\u003cspan style=\"color: rgb(255, 153, 0); font-size: 24px;\"\u003e8.5\u003c/span\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e分类：\u003c/span\u003e奇幻,剧情,爱情 \u0026nbsp;\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e地区：\u003c/span\u003e韩国 \u0026nbsp;\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e年份：\u003c/span\u003e2022 \u0026nbsp;\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e又名：\u003c/span\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e演员：\u003c/span\u003e\u003ca href=\"https://www.hdmoli.com/search.php?searchword=%E5%AE%8B%E4%BB%B2%E5%9F%BA\" target=\"\"\u003e宋仲基\u003c/a\u003e \u0026nbsp;\u003ca href=\"https://www.hdmoli.com/search.php?searchword=%E6%9D%8E%E6%98%9F%E6%B0%91\" target=\"\"\u003e李星民\u003c/a\u003e \u0026nbsp;\u003ca href=\"https://www.hdmoli.com/search.php?searchword=%E7%94%B3%E8%B4%A4%E5%BD%AC\" target=\"\"\u003e申贤彬\u003c/a\u003e \u0026nbsp;\u003ca href=\"https://www.hdmoli.com/search.php?searchword=%E8%B5%B5%E6%B1%89%E5%93%B2\" target=\"\"\u003e赵汉哲\u003c/a\u003e \u0026nbsp;\u003ca href=\"https://www.hdmoli.com/search.php?searchword=%E9%87%91%E8%B4%9E%E5%85%B0\" target=\"\"\u003e金贞兰\u003c/a\u003e \u0026nbsp; \u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e导演：\u003c/span\u003e郑大允 \u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e更新：\u003c/span\u003e2022-11-28 07:50 \u0026nbsp;\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e更新周期：\u003c/span\u003e周五,周六,周日\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153);\"\u003e短评：\u003c/span\u003e重生复仇商战爽剧\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cspan style=\"color: rgb(153, 153, 153); font-size: 14px;\"\u003e解说：\u003c/span\u003e\u003cspan style=\"color: rgb(102, 102, 102); font-size: 14px;\"\u003e \u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(153, 153, 153); font-size: 14px;\"\u003e简介：\u003c/span\u003e\u003cspan style=\"color: rgb(102, 102, 102); font-size: 14px;\"\u003e 改编自同名人气网络小说，讲述管理财阀一家的秘书尹贤宇（宋仲基 饰），被冤枉涉嫌侵吞资金而被财阀家杀害。尹贤宇重生为财阀家的小儿子陈道俊，以新的身份一边成长一边复仇的故事。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(102, 102, 102); font-size: 14px;\"\u003e观看链接： \u003c/span\u003e\u003ca href=\"https://www.hdmoli.com/movie/index1636.html\" target=\"_blank\"\u003ehttps://www.hdmoli.com/movie/index1636.html\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669600619098.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-28T02:01:28.000Z","art_tags":6},{"id":102,"art_title":"很有趣的一个表情生成工具","art_content":"\u003cp\u003e网站链接： \u003ca href=\"https://paramoji.org/\" target=\"_blank\"\u003ehttps://paramoji.org/\u003c/a\u003e \u003c/p\u003e\u003cp\u003e看看效果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://paramoji.org/paramoji.svg.php?v=67\u0026a1=71\u0026a2=33\u0026d=79\u0026c=56\" alt=\"https://paramoji.org/paramoji.svg.php?v=67\u0026a1=71\u0026a2=33\u0026d=79\u0026c=56\" data-href=\"https://paramoji.org/paramoji.svg.php?v=67\u0026a1=71\u0026a2=33\u0026d=79\u0026c=56\" style=\"width: 299.00px;height: 299.00px;\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-25T02:45:01.000Z","art_tags":10},{"id":101,"art_title":"老子的一脸不屑","art_content":"\u003cp\u003e\u003cimg src=\"https://paramoji.org/paramoji.svg.php?v=3\u0026a1=99\u0026a2=0\u0026d=50\u0026c=100\" alt=\"https://paramoji.org/paramoji.svg.php?v=3\u0026a1=99\u0026a2=0\u0026d=50\u0026c=100\" data-href=\"https://paramoji.org/paramoji.svg.php?v=3\u0026a1=99\u0026a2=0\u0026d=50\u0026c=100\" style=\"width: 319.00px;height: 319.00px;\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-25T02:42:35.000Z","art_tags":6},{"id":99,"art_title":"深入理解HTTP缓存机制及原理","art_content":"\u003ch3\u003e一、前言\u003c/h3\u003e\u003cp\u003e       上周阿里的面试官问了个面试题 “ 能不能说下 304 的过程，以及影响缓存的头部属性有哪些？”OMG.......因为之前只是大概了解 304 状态码是表示缓存，且因为平时项目开发过程中也没有在缓存这块踩过坑，所以这一块也没有去做特别深入的研究。所以当被问这个问题时，有被当头一棒的感觉，也好好反思了下，自己校招以软件开发工程师的职位进入公司，之前没有想过要从事前端开发，所以前端基础几乎可以忽略不计。工作一年多来，为在工作上表现突出，在工作上投入大量的精力，干到晚上10点是常规操作，周末至少加班1天；并且空余时间，经常看前端相关书籍弥补基础，如《JavaScript 高级程序设计》、《CSS 权威指南》、《Sass 实践》、《JavaScript 高性能编程》....《Webpack 实践》、《深入浅出 node.js》等不下10本书；在广度上涉及的还是很多的，但是存在问题：从事前端时间不长，前端知识杂而多，如果没有专门准备，如果突然问你一个知识点，你虽然大概知道这是啥，但是让你讲的话，你很难有条理的讲清楚。\u003c/p\u003e\u003cp\u003e       So，下一阶段的首要任务：“打好打牢前端基础，深入了解所用的技术栈原理”。废话少说，学问学问，不懂就弄清楚！以下“理论知识 + 实践操作”来彻底弄懂 HTTP 缓存机制及原理！\u003c/p\u003e\u003ch3\u003e二、缓存规则及解析\u003c/h3\u003e\u003cp\u003e       为方便大家理解，我假设览器存在一个缓存数据库，用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。如下流程图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1125a6943e17~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e       根据是否需要重新向服务器发起请求来分类，将HTTP缓存规则分为两大类(\u003cstrong\u003e强制缓存\u003c/strong\u003e，\u003cstrong\u003e对比缓存\u003c/strong\u003e)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。\u003c/p\u003e\u003cp\u003e（1）已存在缓存数据时，仅基于\u003cstrong\u003e强制缓存\u003c/strong\u003e，请求数据的流程如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1131a01649ce~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e（2）已存在缓存数据时，仅基于\u003cstrong\u003e对比缓存\u003c/strong\u003e，请求数据的流程如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a113789f814d2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e       我们可以看到两类缓存规则的不同，\u003cstrong\u003e强制缓存\u003c/strong\u003e如果生效，不需要再和服务器发生交互，而\u003cstrong\u003e对比缓存\u003c/strong\u003e不管是否生效，都需要与服务端发生交互。\u003c/p\u003e\u003cp\u003e       两类缓存规则可以同时存在，\u003cstrong\u003e强制缓存\u003c/strong\u003e优先级高于\u003cstrong\u003e对比缓存\u003c/strong\u003e，也就是说，当执行\u003cstrong\u003e强制缓存\u003c/strong\u003e的规则时，如果缓存生效，直接使用缓存，不再执行\u003cstrong\u003e对比缓存\u003c/strong\u003e规则。\u003c/p\u003e\u003ch3\u003e三、缓存常用字段\u003c/h3\u003e\u003ch3\u003e1、http1.0时期的缓存方案\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a119737ecdeb2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e注意： \u003c/p\u003e\u003cp\u003e（1）如果使用了\u003ccode\u003ePragma: 'no-cache'\u003c/code\u003e的话，再设置\u003ccode\u003eExpires\u003c/code\u003e或者\u003ccode\u003eCache-Control\u003c/code\u003e，就没有用了，说明\u003ccode\u003ePragma\u003c/code\u003e的权值比后两者高。\u003c/p\u003e\u003cp\u003e （2）如果设置了\u003ccode\u003eExpires\u003c/code\u003e之后，客户端在需要请求数据的时候，首先会对比当前系统时间和这个\u003ccode\u003eExpires\u003c/code\u003e时间，如果没有超过\u003ccode\u003eExpires\u003c/code\u003e时间，则直接读取本地磁盘中的缓存数据，不发送请求。\u003cbr\u003e\u003c/p\u003e\u003ch3\u003e2、http1.1 时期的缓存方案\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e2.1、Cache-Control 字段 \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.1.1、Cache-Control 作为请求头字段\u003c/strong\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11b7c6a465ba~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（1）Cache-Control: no-cache \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e使用\u003ccode\u003eno-cache\u003c/code\u003e指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 \u003ccode\u003eno-cache\u003c/code\u003e 指令，则表示客户端将不会接收缓存的资源。每次请求都是从服务器获取资源，返回304。\u003cbr\u003e \u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（2）Cache-Control: no-store \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e使用\u003ccode\u003eno-store\u003c/code\u003e 指令表示请求的资源不会被缓存，下次任何其它请求获取该资源，还是会从服务器获取，返回 200，即资源本身。\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.1.2、Cache-Control 作为响应头字段\u003c/strong\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11c6b7651b77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCache-Control: public \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e当指定使用 \u003ccode\u003epublic \u003c/code\u003e指令时，则明确表明其他用户也可利用缓存。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e Cache-Control: private\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e当指定 \u003ccode\u003eprivate\u003c/code\u003e 指令后，响应只以特定的用户作为对象，这与 \u003ccode\u003epublic\u003c/code\u003e 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e Cache-Control: no-cache \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如果服务器返回的响应中包含\u003ccode\u003e no-cache \u003c/code\u003e指令，每次客户端请求，必需先向服务器确认其有效性，如果资源没有更改，则返回304. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCache-Control: no-store \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e不对响应的资源进行缓存，即用户下次请求还是返回 200，返回资源本身。 \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCache-Control: max-age=604800（单位：秒） \u003c/strong\u003e\u003c/p\u003e\u003cp\u003e资源缓存在本地浏览器的时间，如果超过该时间，则重新向服务器获取。\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.2、请求头部字段 \u0026 响应头部字段\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.2.1、请求头部字段\u003c/strong\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11dbaa0f8a2a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.2.2、响应头部字段\u003c/strong\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11e177c975f2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e注意：\u003c/p\u003e\u003cp\u003e （1）\u003ccode\u003eIf-None-Match\u003c/code\u003e的优先级比\u003ccode\u003eIf-Modified-Since\u003c/code\u003e高，所以两者同时存在时，遵从前者。\u003cbr\u003e\u003c/p\u003e\u003ch3\u003e四、实验验证\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e1、实验1 — 请求的资源没修改，验证2种缓存出现的情形\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e服务端使用 node.js ， 客户端使用 axios 进行请求：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.1、请求头部 / 响应头部 设置\u003cbr\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e（1）服务端响应头部设置：\u003c/p\u003e\u003cp\u003e     res.setHeader('Cache-Control', 'public, max-age=10');\u003c/p\u003e\u003cp\u003e（2）客户端请求头部使用默认设置\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.2、实验步骤\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e（1）请求 3 次，第一次请求请求资源；第二次在10秒内再次请求该资源，第三次在 10 秒后再次请求该资源（实验过程中，服务端的资源没有进行改变）\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.3、实验结果\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e      3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（10 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（10 秒后）请求该资源时，因为资源缓存时间（10 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源没有做更改，所以返回 304，让客户端直接从浏览器缓存中获取该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11ff1e022d96~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.3.1、第一次请求资源\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e 第一次请求资源的请求头部和响应头部的截图如下所示，因为第一次请求该资源，本地并没有缓存，所以直接从服务器获取该资源；我们从截图可以看到，服务器返回改资源的响应头部中包含3个属性与资源缓存相关：\u003c/p\u003e\u003cp\u003e（1）cache-control: public, max-age=10\u003c/p\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp; 缓存规则的设置，我们这个示例中，设置缓存规则为 public, 并且设置缓存过期时间为10秒；\u003c/p\u003e\u003cp\u003e（2）etag: W/\"95f15b-16994d7ebf6\"\u003c/p\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp; 资源的唯一标识符，客户端下次访问该资源时，会在请求头中携带 etag 去向服务器确认，该资源是否被修改；\u003c/p\u003e\u003cp\u003e（3）last-modified: Tue, 19 Mar 2019 07:26:12 GMT\u003c/p\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp; 资源最后一次修改时间，客户端下次访问该资源时，会在请求头中携带该信息去向服务器进行匹配，该资源是否被修改；\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12072e2e0cb6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.3.2、第二次请求资源（10秒内，即在缓存时间失效前）\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e       第二次请求资源的请求头部和响应头部的截图如下所示，因为第二次请求该资源，该资源本地缓存还没失效，所以就直接从浏览器缓存中获取该资源。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a120bbf711005~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1.3.3、第三次请求资源（10秒后，即在缓存时间失效后）\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1211c38c875b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2、实验2 — 请求的资源进行修改，验证2种缓存出现的情形\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e服务端使用 node.js ， 客户端使用 axios 进行请求：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.1、请求头部 / 响应头部 设置\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e（1）服务端响应头部设置：\u003c/p\u003e\u003cp\u003e     res.setHeader('Cache-Control', 'public, max-age=20');\u003c/p\u003e\u003cp\u003e（2）客户端请求头部使用默认设置\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.2、实验步骤\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e（1）请求 3 次，第一次请求资源；然后在服务器对请求的资源进行修改，第二次在 20 秒内再次请求该资源，第三次在 20 秒后再次请求该资源\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.3、实验结果\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e       3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（20 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（20 秒后）请求该资源时，因为资源缓存时间（20 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源不同，所以重新返回该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121606944373~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.3.1、第一次请求资源\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e       第一次请求资源的请求头部和响应头部的截图如下所示，具体详细信息与 1.3.1 小节相同，在此不同重复介绍。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1219166741f1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.3.2、第二次请求资源（20 秒内，即在缓存时间失效前）\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e      第二次请求资源的请求头部和响应头部的截图如下所示，（注意：即使此时服务器上的资源已经更改，但是由于缓存在浏览器中的资源没有过期，所以还是从缓存中返回旧资源）。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121db9c73552~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2.3.3、第三次请求资源（20 秒后，即在缓存时间失效后）\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改，从下图中可以看到，响应头部的属性 etag 与 请求头部的属性 If-None-Match \u0026nbsp;不同，响应头部的属性 If-Modified-Since 与 请求头部的属性 last-modified 不同；所以服务器返回该资源的最新资源。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1221529a99db~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3\u003e五、总结\u003c/h3\u003e\u003cp\u003e1、对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\u003c/p\u003e\u003cp\u003e2、对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\u003c/p\u003e\u003cp\u003e总结流程图如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12255df4532a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cem\u003e有任何问题欢迎留言讨论，如果觉得对你有帮助，请点赞鼓励~\u003c/em\u003e\u003cimg src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e作者：我是你的超级英雄\u003cbr\u003e链接：https://juejin.cn/post/6844903801778864136\u003cbr\u003e来源：稀土掘金\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-25T02:33:28.000Z","art_tags":4},{"id":98,"art_title":"使用 Github Actions 部署react-app 到 Github Pages","art_content":"\u003ch2 style=\"text-align: start;\"\u003e原文： \u003ca href=\"https://segmentfault.com/a/1190000041449997\" target=\"_blank\"\u003ehttps://segmentfault.com/a/1190000041449997\u003c/a\u003e \u003c/h2\u003e\u003ch2 style=\"text-align: start;\"\u003e前言-学以致用\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e之前一直忙于开发，总是零散的去看一些东西，想想学东西了么？额... 好像学了，又好像没有学，不知道你们有没有这种感觉，所以新年初始，换一种学习方法，本着学以致用去完整的学一些东西，正好之前想接触CI,CD 这里的知识，所以就从最常见的github开始吧，毕竟免费又常用。\u003c/p\u003e\u003ch2 style=\"text-align: start;\"\u003e初始化项目\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e创建github代码仓库，clone 项目到本地，进入目录初始化项目\u003c/p\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003enpx create-react-app\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e然后按照命令提示输入完成初始化,推送项目到github。\u003c/p\u003e\u003ch2 style=\"text-align: start;\"\u003e配置github actions\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e目标是实现推送代码到master分支, 自动开始构建项目，部署到Gthub Pages。\u003cbr\u003e按照\u003ca href=\"https://link.segmentfault.com/?enc=BsHuQ0PzigUZ28kaoAvQ1A%3D%3D.qxiSOELr%2FQtZg8yDLMw5z%2F3N%2Fg7890IdTr0xBDUgph6mtDx00VjRN6ObO29wJLlQ\" target=\"_blank\"\u003e文档\u003c/a\u003e先跑起来第一个流程，让自己看到效果，在去学习语法内容，这样更能激发兴趣，免得直接看文档看睡着了...\u003c/p\u003e\u003col style=\"text-align: start;\"\u003e\u003cli\u003e在目录外层增加 .gihub/workflows文件夹，创建第一个first-demo.yml文件，拷贝示例内容.\u003c/li\u003e\u003c/ol\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003ename: GitHub Actions Demo\non: [push]\njobs:\n  Explore-GitHub-Actions:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\"\n      - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\"\n      - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\"\n      - name: Check out repository code\n        uses: actions/checkout@v2\n      - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\"\n      - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\"\n      - name: List files in the repository\n        run: |\n          ls ${{ github.workspace }}\n      - run: echo \"🍏 This job's status is ${{ job.status }}.\"\u003c/code\u003e\u003c/pre\u003e\u003col style=\"text-align: start;\"\u003e\u003cli\u003e提交代码，点击gihub仓库上方的\u003cstrong\u003eActions\u003c/strong\u003e按钮，查看效果，第一个工作流程就完成了。\u003cbr\u003e\u003cimg src=\"https://segmentfault.com/img/bVcX4QB\" alt=\"image.png\" data-href=\"\" style=\"\"\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 style=\"text-align: start;\"\u003e开始编写自己的yml文件,实现自动构建\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e快速过一遍文档，学习一下语法，实现自己想要的工作流程。从demo可以看到主要有流程有这么几步\u003c/p\u003e\u003col style=\"text-align: start;\"\u003e\u003cli\u003ename 工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。\u003c/li\u003e\u003cli\u003eon 触发流程的事件，具体可以触发的事件有\u003ca href=\"https://link.segmentfault.com/?enc=RQOtsmXdu0%2FEXbROT%2FG%2F2Q%3D%3D.7z%2ByjH%2FOcAA%2Fn%2FAOG%2FPEc7sSAqWm8y9eeuk2jE6mKo3Sady7tvQdfp9twn8zABomtUFNy9UaxNnRKqmagziAA9KkvrPW%2FqZd9INMAa1hQb5%2Bbgd048QnZ4pxSaX8iVBA\" target=\"_blank\"\u003e这些\u003c/a\u003e,我们所要实现的是提交代码，所以用 push.\u003c/li\u003e\u003cli\u003ejobs 要按顺序运行作业.\u003c/li\u003e\u003c/ol\u003e\u003cp style=\"text-align: start;\"\u003e目标明确后，开始编写yml\u003c/p\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode class=\"language-xml\"\u003e # 显示得workflow名称\n name: First GitHub Actions Demo\n on: \n   # 推送到master分支开始打包\n   push:\n     branches:\n       - master\n\n jobs:\n   # 开始打包\n   Build:\n     runs-on: ubuntu-latest\n     steps:\n     - name: checkout code\n       # 迁出触发的流程的版本 能让下面的工作流程访问\n       uses: actions/checkout@v2\n       # setup-node 可以提供node环境，指定node版本以及 npm /yarn缓存\n     - name: actions/setup-node@v2\n       uses: actions/setup-node@v2   \n       with:\n         node: 16.14\n     # 初始用的npm 打包时间太长了，就想着用yarn 结果没仔细看文档，yarn 不用安装 ubuntu 上面有的 \n     # - name: install yarn \n     #  uses: npm install yarn     \n     # - run: yarn install\n     # - run: yarn build\n     # 简写为\n     - run: yarn install \u0026amp;\u0026amp; yarn build\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e好了提交代码看Actions（这是上面没有优化时的流程）。\u003cbr\u003e\u003cimg src=\"https://segmentfault.com/img/bVcX4U4\" alt=\"image.png\" data-href=\"\" style=\"\"\u003e\u003cbr\u003e到此已经完成了提交代码自动打包的过程了，但是一看打包时间好家伙一分半，这要是实际开发大量依赖加入，那不得半个小时么？打开流程一看大部分时间都是在下载依赖，所以是不是可以添加缓存呢？一搜索果然有\u003ca href=\"https://link.segmentfault.com/?enc=pnQPaLLU4xUkEVZs%2FAOMvg%3D%3D.2tU0x25fYK3W5v%2BKIaXbPtcgPRdBA3aCtheR9dRUoYVvVXrZqh4THcigzp8RkBWk\" target=\"_blank\"\u003ecache\u003c/a\u003e,麻溜的按照文档添加进入，\u003cbr\u003e一看时间46s,哈哈果然有效。到此yml内容为\u003c/p\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003ename: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: checkout code\n      uses: actions/checkout@v2\n    - name: actions/setup-node@v2\n      uses: actions/setup-node@v2   \n      with:\n        node: 16.14\n    # 配置依赖缓存\n    - name: yarn cache\n      id: yarn-cahce-dir-path\n      run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    - uses: actions/cache@v2\n      id: yarn-cache\n      with: \n        path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: | \n          ${{ runner.os }}-yarn-\n    - run: yarn install \u0026amp;\u0026amp; yarn build\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003e部署页面到Github Pages\u003c/h2\u003e\u003col style=\"text-align: start;\"\u003e\u003cli\u003e首先需要设定一个分支，当做站点的根目录，具体\u003ca href=\"https://link.segmentfault.com/?enc=VmP76VTiM%2BW%2BWDCp%2BCe%2BoQ%3D%3D.jjGmPHjENUgpLSpQUCjLgHZb4H9WteP7M1b8%2BsmlO6wkRYs7iMMi5X5gx4V3jda8WFrsrW7EPYw%2F0ARqadAHDW2cDfEmRicaQHdoj%2FsrssbgNcIGSjNimD2L2tqfO61ovyZJ7VdXGgATlEh37KyxRHVcdBEN3%2FFYiTDin%2B4GKvw%3D\" target=\"_blank\"\u003e设置文档\u003c/a\u003e，设置完成后会告诉你网站访问地址（ps: 一定要把仓库设置为Public,不然无法进行设置）。\u003c/li\u003e\u003c/ol\u003e\u003cp style=\"text-align: start;\"\u003e\u003cimg src=\"https://segmentfault.com/img/bVcX41W\" alt=\"image.png\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003col style=\"text-align: start;\"\u003e\u003cli\u003e按照文档编辑.yml,增加发布流程\u003c/li\u003e\u003c/ol\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003e # 上面的步骤拿过来\n # 新增 deploy\n  - name: deploy\n    uses: JamesIves/github-pages-deploy-action@v4.2.3\n    with:\n      branch: gh-pages # 部署的分支名 有一定要独立一个分支，第一次设置为master 好家伙构建完成后，直接把我的项目文件清除了，只剩下打包的文件了。\n      folder: build   # build后文件目录\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e效果\u003cbr\u003e\u003cimg src=\"https://segmentfault.com/img/bVcX42T\" alt=\"image.png\" data-href=\"\" style=\"\"\u003e\u003cbr\u003e到这里基本的目标已经实现了，但是当我看公司内部的流程时，install, build, deploy流程是分开的，这样有利于增加一些校验，lint规则等流程，所以我在思考怎么拆分流程呢，第一次我简单的拆分\u003c/p\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003ename: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n      - dev\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      uses: actions/checkout@v2\n      uses: actions/setup-node@v2   \n      with:\n        node: 16.14\n    - name: yarn cache\n      id: yarn-cahce-dir-path\n      run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    - uses: actions/cache@v2\n      id: yarn-cache\n      with: \n        path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: | \n          ${{ runner.os }}-yarn-   \n    - run: yarn install\n    - run: yarn build\n  Deploy:\n    - name: depploy\n      uses: JamesIves/github-pages-deploy-action@v4.2.3\n      width:\n        branch: gh-pages\n        folder: build\n        clean: true\n        clean-exclude: |\n          special-file.txt\n          some/*.txt\n        ssh-key: ${{ secrets.PAGE_ACCESS_TOKEN }}    \u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e我想着这样应该就可以了，一提交代码直接GG,第一是没有Deploy没有等待build完成，第二是两个job之间的文件不能够直接用，又翻了下文档才发现官方给了这两个 actions/upload-artifact@v2 actions/download-artifact@v2 可以在不同job之间公用文件，所以又改了改,build阶段上传打包好的文件，deploy阶段下载打包好的文件进行部署（注意deploy也要使用checkout@v2）。\u003cbr\u003e最终结果\u003c/p\u003e\u003cpre style=\"text-align: start; line-height: 1.5;\"\u003e\u003ccode\u003ename: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n      - dev\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    # 步骤名称\n    - name: checkout code\n      uses: actions/checkout@v2\n    - name: actions/setup-node@v2\n      uses: actions/setup-node@v2   \n      with:\n        node-version: '16.14'\n        cache: 'yarn'\n        cache-dependency-path: '**/yarn.lock'\n    # 缓存 有需要可以开启 同时 setu node 也可以进行缓存\n    # - name: yarn cache\n    #   id: yarn-cahce-dir-path\n    #   run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    # - uses: actions/cache@v2\n    #   id: yarn-cache\n    #   with: \n    #     path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n    #     key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n    #     restore-keys: | \n    #       ${{ runner.os }}-yarn-    \n    - run: yarn install \u0026amp;\u0026amp; yarn build  \n    # 上传打包好的文件，所以下一步可以使用\n    - name: upload files \n      uses: actions/upload-artifact@v2\n      with: \n        name: build-pages\n        path: build\n        retention-days: 1\n  Deploy: \n    needs: Build # 确保build 阶段完成\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout code\n        uses: actions/checkout@v2\n      - name: download build files\n        uses: actions/download-artifact@v2\n        with:\n          name: build-pages\n          path: build\n      - name: deploy\n        uses: JamesIves/github-pages-deploy-action@v4.2.3\n        with:\n          branch: gh-pages\n          folder: build \n          token: \"${{ secrets.DEPLOY_TOKEN }}\"  \u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e提交代码，查看运行结果，完成拆分。\u003cbr\u003e\u003cimg src=\"https://segmentfault.com/img/bVcX49V\" alt=\"image.png\" data-href=\"\" style=\"\"\u003e\u003cbr\u003e到这里可以愉快的访问你的网站了。\u003c/p\u003e\u003ch2 style=\"text-align: start;\"\u003e结尾\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e写作思路是按照当时完成的思路一步一步的去完成这个流程来的，所以有些功能可能还没想到，同时如果流程有什么可以优化的地方，欢迎各位大佬指教。当然，完整的流程还欠缺很多，目前只是先完成简单的打包构建流程，接下来还需要去学习gitlab 的CI、CD,完成后会在水一篇文章。在之后才会去看一些部署项目相关的内容。比如Docker,Nginx等，希望能在空闲之余学会整个流程。加油！\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-23T08:37:21.000Z","art_tags":4},{"id":97,"art_title":"nextjs代理配置","art_content":"\u003cp\u003e在next.config.js文件中配置：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  swcMinify: true,\r\n  // rewrites:async ()=\u0026gt;{\r\n  //   return [{\r\n  //     source: '/000000001000/:slug*',\r\n  //     destination: `http://111.20.105.192:6610/000000001000/:slug*`,\r\n  //   },]\r\n  // }\r\n}\r\n\r\nmodule.exports = nextConfig\r\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注释部分为代理配置，当匹配到 '/000000001000/’请求路径时会代理到`http://111.20.105.192:6610/000000001000/`地址\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-22T09:31:16.000Z","art_tags":4},{"id":96,"art_title":"GitHub Actions 入门教程","art_content":"\u003ch1 style=\"text-align: left;\"\u003e阮一峰大神的入门教学，全文copy👨‍💻\u003c/h1\u003e\u003cp\u003e \u003ca href=\"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\" target=\"_blank\"\u003ehttps://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e作者： \u003ca href=\"https://www.ruanyifeng.com/\" target=\"\" style=\"text-align: left;\"\u003e阮一峰\u003c/a\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e日期： \u003ca href=\"https://www.ruanyifeng.com/blog/2019/09/\" target=\"\" style=\"text-align: left;\"\u003e2019年9月12日\u003c/a\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ca href=\"https://github.com/features/actions\" target=\"_blank\" style=\"text-align: left;\"\u003eGitHub Actions\u003c/a\u003e 是 GitHub 的\u003ca href=\"https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" style=\"text-align: left;\"\u003e持续集成服务\u003c/a\u003e，于2018年10月\u003ca href=\"https://github.blog/changelog/2018-10-16-github-actions-limited-beta/\" target=\"_blank\" style=\"text-align: left;\"\u003e推出\u003c/a\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e这些天，我一直在试用，觉得它非常强大，有创意，比 \u003ca href=\"https://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" style=\"text-align: left;\"\u003eTravis CI\u003c/a\u003e 玩法更多。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e本文是一个简单教程，演示如何使用 GitHub Actions 自动发布一个 React 应用到 \u003ca href=\"https://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\" target=\"_blank\" style=\"text-align: left;\"\u003eGitHub Pages\u003c/a\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091201.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003ch2 style=\"text-align: left;\"\u003e一、GitHub Actions 是什么？\u003c/h2\u003e\u003cp style=\"text-align: left;\"\u003e大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eGitHub 做了一个\u003ca href=\"https://github.com/marketplace?type=actions\" target=\"_blank\" style=\"text-align: left;\"\u003e官方市场\u003c/a\u003e，可以搜索到他人提交的 actions。另外，还有一个 \u003ca href=\"https://github.com/sdras/awesome-actions\" target=\"_blank\" style=\"text-align: left;\"\u003eawesome actions\u003c/a\u003e 的仓库，也可以找到不少 action。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091105.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003euserName/repoName\u003c/code\u003e\u003c/span\u003e的语法引用 action。比如，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eactions/setup-node\u003c/code\u003e\u003c/span\u003e就表示\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003egithub.com/actions/setup-node\u003c/code\u003e\u003c/span\u003e这个\u003ca href=\"https://github.com/actions/setup-node\" target=\"_blank\" style=\"text-align: left;\"\u003e仓库\u003c/a\u003e，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 \u003ca href=\"https://github.com/actions\" target=\"_blank\" style=\"text-align: left;\"\u003egithub.com/actions\u003c/a\u003e 里面。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见\u003ca href=\"https://help.github.com/en/articles/about-actions#versioning-your-action\" target=\"_blank\" style=\"text-align: left;\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eactions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支\u003c/blockquote\u003e\u003ch2 style=\"text-align: left;\"\u003e二、基本概念\u003c/h2\u003e\u003cp style=\"text-align: left;\"\u003eGitHub Actions 有一些自己的术语。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e（1）\u003cstrong\u003eworkflow\u003c/strong\u003e （工作流程）：持续集成一次运行的过程，就是一个 workflow。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e（2）\u003cstrong\u003ejob\u003c/strong\u003e （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e（3）\u003cstrong\u003estep\u003c/strong\u003e（步骤）：每个 job 由多个 step 构成，一步步完成。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e（4）\u003cstrong\u003eaction\u003c/strong\u003e （动作）：每个 step 可以依次执行一个或多个命令（action）。\u003c/p\u003e\u003ch2 style=\"text-align: left;\"\u003e三、workflow 文件\u003c/h2\u003e\u003cp style=\"text-align: left;\"\u003eGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e.github/workflows\u003c/code\u003e\u003c/span\u003e目录。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eworkflow 文件采用 \u003ca href=\"https://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" style=\"text-align: left;\"\u003eYAML 格式\u003c/a\u003e，文件名可以任意取，但是后缀名统一为\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e.yml\u003c/code\u003e\u003c/span\u003e，比如\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003efoo.yml\u003c/code\u003e\u003c/span\u003e。一个库可以有多个 workflow 文件。GitHub 只要发现\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e.github/workflows\u003c/code\u003e\u003c/span\u003e目录里面有\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e.yml\u003c/code\u003e\u003c/span\u003e文件，就会自动运行该文件。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eworkflow 文件的配置字段非常多，详见\u003ca href=\"https://help.github.com/en/articles/workflow-syntax-for-github-actions\" target=\"_blank\" style=\"text-align: left;\"\u003e官方文档\u003c/a\u003e。下面是一些基本字段。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（1）name\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ename\u003c/code\u003e\u003c/span\u003e字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ename: GitHub Actions Demo\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（2）on\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eon\u003c/code\u003e\u003c/span\u003e字段指定触发 workflow 的条件，通常是某些事件。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eon: push\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码指定，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003epush\u003c/code\u003e\u003c/span\u003e事件触发 workflow。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eon\u003c/code\u003e\u003c/span\u003e字段也可以是事件的数组。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eon: [push, pull_request]\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码指定，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003epush\u003c/code\u003e\u003c/span\u003e事件或\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003epull_request\u003c/code\u003e\u003c/span\u003e事件都可以触发 workflow。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e完整的事件列表，请查看\u003ca href=\"https://help.github.com/en/articles/events-that-trigger-workflows\" target=\"_blank\" style=\"text-align: left;\"\u003e官方文档\u003c/a\u003e。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（3）on.\u0026lt;push|pull_request\u0026gt;.\u0026lt;tags|branches\u0026gt;\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e指定触发事件时，可以限定分支或标签。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eon: push: branches: - master\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码指定，只有\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003emaster\u003c/code\u003e\u003c/span\u003e分支发生\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003epush\u003c/code\u003e\u003c/span\u003e事件时，才会触发 workflow。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（4）jobs.\u0026lt;job_id\u0026gt;.name\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eworkflow 文件的主体是\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejobs\u003c/code\u003e\u003c/span\u003e字段，表示要执行的一项或多项任务。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejobs\u003c/code\u003e\u003c/span\u003e字段里面，需要写出每一项任务的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob_id\u003c/code\u003e\u003c/span\u003e，具体名称自定义。\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob_id\u003c/code\u003e\u003c/span\u003e里面的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ename\u003c/code\u003e\u003c/span\u003e字段是任务的说明。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ejobs: my_first_job: name: My first job my_second_job: name: My second job\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejobs\u003c/code\u003e\u003c/span\u003e字段包含两项任务，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob_id\u003c/code\u003e\u003c/span\u003e分别是\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003emy_first_job\u003c/code\u003e\u003c/span\u003e和\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003emy_second_job\u003c/code\u003e\u003c/span\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（5）jobs.\u0026lt;job_id\u0026gt;.needs\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eneeds\u003c/code\u003e\u003c/span\u003e字段指定当前任务的依赖关系，即运行顺序。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ejobs: job1: job2: needs: job1 job3: needs: [job1, job2]\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码中，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob1\u003c/code\u003e\u003c/span\u003e必须先于\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob2\u003c/code\u003e\u003c/span\u003e完成，而\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob3\u003c/code\u003e\u003c/span\u003e等待\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob1\u003c/code\u003e\u003c/span\u003e和\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob2\u003c/code\u003e\u003c/span\u003e的完成才能运行。因此，这个 workflow 的运行顺序依次为：\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob1\u003c/code\u003e\u003c/span\u003e、\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob2\u003c/code\u003e\u003c/span\u003e、\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ejob3\u003c/code\u003e\u003c/span\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（6）jobs.\u0026lt;job_id\u0026gt;.runs-on\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eruns-on\u003c/code\u003e\u003c/span\u003e字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eubuntu-latest，ubuntu-18.04或ubuntu-16.04windows-latest，windows-2019或windows-2016macOS-latest或macOS-10.14\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e下面代码指定虚拟机环境为\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eubuntu-18.04\u003c/code\u003e\u003c/span\u003e。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003eruns-on: ubuntu-18.04\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e\u003ccode\u003e\u003cstrong\u003e（7）jobs.\u0026lt;job_id\u0026gt;.steps\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003esteps\u003c/code\u003e\u003c/span\u003e字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ejobs.\u0026lt;job_id\u0026gt;.steps.name：步骤名称。jobs.\u0026lt;job_id\u0026gt;.steps.run：该步骤运行的命令或者 action。jobs.\u0026lt;job_id\u0026gt;.steps.env：该步骤所需的环境变量。\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e下面是一个完整的 workflow 文件的范例。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ename: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码中，\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003esteps\u003c/code\u003e\u003c/span\u003e字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。\u003c/p\u003e\u003ch2 style=\"text-align: left;\"\u003e四、实例：React 项目发布到 GitHub Pages\u003c/h2\u003e\u003cp style=\"text-align: left;\"\u003e下面是一个实例，通过 GitHub Actions 构建一个 React 项目，并发布到 GitHub Pages。最终代码都在\u003ca href=\"https://github.com/ruanyf/github-actions-demo\" target=\"_blank\" style=\"text-align: left;\"\u003e这个仓库\u003c/a\u003e里面，发布后的参考网址为\u003ca href=\"https://ruanyf.github.io/github-actions-demo\" target=\"_blank\" style=\"text-align: left;\"\u003eruanyf.github.io/github-actions-demo\u003c/a\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e第一步，GitHub Actions 目前还处在测试阶段，需要到\u003ca href=\"https://github.com/features/actions/signup/\" target=\"_blank\" style=\"text-align: left;\"\u003e这个网址\u003c/a\u003e申请测试资格。申请以后，可能需要几天才能通过。据说，2019年11月就会放开。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e获得资格后，仓库顶部的菜单会出现\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eActions\u003c/code\u003e\u003c/span\u003e一项。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091106.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e第二步，这个示例需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照\u003ca href=\"https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line\" target=\"_blank\" style=\"text-align: left;\"\u003e官方文档\u003c/a\u003e，生成一个密钥。然后，将这个密钥储存到当前仓库的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eSettings/Secrets\u003c/code\u003e\u003c/span\u003e里面。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091107.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e上图是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eACCESS_TOKEN\u003c/code\u003e\u003c/span\u003e。如果你不用这个名字，后面脚本里的变量名也要跟着改。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e第三步，本地计算机使用\u003ca href=\"https://github.com/facebook/create-react-app\" target=\"_blank\" style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ecreate-react-app\u003c/code\u003e\u003c/span\u003e\u003c/a\u003e，生成一个标准的 React 应用。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003e$ npx create-react-app github-actions-demo $ cd github-actions-demo\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e然后，打开\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003epackage.json\u003c/code\u003e\u003c/span\u003e文件，加一个\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003ehomepage\u003c/code\u003e\u003c/span\u003e字段，表示该应用发布后的根目录（参见\u003ca href=\"https://create-react-app.dev/docs/deployment#building-for-relative-paths\" target=\"_blank\" style=\"text-align: left;\"\u003e官方文档\u003c/a\u003e）。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003e\"homepage\": \"https://[username].github.io/github-actions-demo\",\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面代码中，将\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e[username]\u003c/code\u003e\u003c/span\u003e替换成你的 GitHub 用户名，参见\u003ca href=\"https://github.com/ruanyf/github-actions-demo/blob/master/package.json#L10\" target=\"_blank\" style=\"text-align: left;\"\u003e范例\u003c/a\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e第四步，在这个仓库的\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003e.github/workflows\u003c/code\u003e\u003c/span\u003e目录，生成一个 workflow 文件，名字可以随便取，这个示例是\u003cspan style=\"color: rgb(17, 17, 17); background-color: pink;\"\u003e\u003ccode\u003eci.yml\u003c/code\u003e\u003c/span\u003e。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e我们选用一个别人已经写好的 action：\u003ca href=\"https://github.com/marketplace/actions/deploy-to-github-pages\" target=\"_blank\" style=\"text-align: left;\"\u003eJamesIves/github-pages-deploy-action\u003c/a\u003e，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看\u003ca href=\"https://github.com/ruanyf/github-actions-demo/blob/master/.github/workflows/ci.yml\" target=\"_blank\" style=\"text-align: left;\"\u003e源码\u003c/a\u003e）。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003ename: GitHub Actions Build and Deploy Demo on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} BRANCH: gh-pages FOLDER: build BUILD_SCRIPT: npm install \u0026amp;\u0026amp; npm run build\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e上面这个 workflow 文件的要点如下。\u003c/p\u003e\u003cblockquote style=\"text-align: left;\"\u003e整个流程在master分支发生push事件时触发。只有一个job，运行在虚拟机环境ubuntu-latest。第一步是获取源码，使用的 action 是actions/checkout。第二步是构建和部署，使用的 action 是JamesIves/github-pages-deploy-action。第二步需要四个环境变量，分别为 GitHub 密钥、发布分支、构建成果所在目录、构建脚本。其中，只有 GitHub 密钥是秘密变量，需要写在双括号里面，其他三个都可以直接写在文件里。\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003e第五步，保存上面的文件后，将整个仓库推送到 GitHub。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eGitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看\u003ca href=\"https://github.com/ruanyf/github-actions-demo/commit/24fbf6a875351297f31434fd44bc3146accf9e59/checks\" target=\"_blank\" style=\"text-align: left;\"\u003e运行日志\u003c/a\u003e，日志默认保存30天。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091108.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e等到 workflow 运行结束，访问 \u003ca href=\"https://ruanyf.github.io/github-actions-demo/\" target=\"_blank\" style=\"text-align: left;\"\u003eGitHub Page\u003c/a\u003e，会看到构建成果已经发上网了。\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091109.jpg\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。\u003c/p\u003e\u003ch2 style=\"text-align: left;\"\u003e五、参考链接\u003c/h2\u003e\u003cul style=\"text-align: left;\"\u003e\u003cli style=\"text-align: left;\"\u003e\u003ca href=\"https://help.github.com/en/categories/automating-your-workflow-with-github-actions\" target=\"_blank\" style=\"text-align: left;\"\u003eGitHub Pages 官方文档\u003c/a\u003e\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e\u003ca href=\"https://lukeboyle.com/blog-posts/2019/08/github-actions-for-web-apps/\" target=\"_blank\" style=\"text-align: left;\"\u003eGithub Actions for web apps\u003c/a\u003e, Luke Boyle\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e\u003ca href=\"https://medium.com/@adam.zolyak/my-first-week-with-github-actions-5d92de4c4851\" target=\"_blank\" style=\"text-align: left;\"\u003eMy First Week With GitHub Actions\u003c/a\u003e, Adam Zolyak\u003c/li\u003e\u003c/ul\u003e\u003cp style=\"text-align: left;\"\u003e（完）\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-22T03:41:39.000Z","art_tags":4},{"id":95,"art_title":"做了css媒体查询，自适应屏幕大小","art_content":"\u003cp\u003e做了两种适配，1200px，800px📢📢📢\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669011016533.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669011093219.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1669011134210.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-21T06:12:21.000Z","art_tags":1},{"id":94,"art_title":"JS格式化金钱（千分位加逗号、保留两位小数）","art_content":"\u003cp\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.75); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e直接使用JS内置 API （\u003c/span\u003etoLocaleString\u003cspan style=\"color: rgba(0, 0, 0, 0.75); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e），实现金额的格式化\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e(999999999).toLocaleString(); // 999,999,999\r\n\r\n// 还可以加参数，进行更优雅的做法\r\nconst options = {\r\n  style: 'currency',\r\n  currency: 'CNY',\r\n};\r\n(999999).toLocaleString('zh-CN', options); // ¥999,999.00\r\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst options = {\r\n  style: 'percent',\r\n  currency: 'CNY',\r\n};\r\n(1).toLocaleString('zh-CN', options); // 100%\r\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003etoLocaleString 可以接收两个可选参数：locales 和 options，而且这个 api在各大浏览器通用不存在兼容问题并且这个 api 不止存在 Number 的原型上，Array、Object、Date 原型上都有这个 api，并且格式化出来的值可以根据我们传入的参数出现各种结果，关于toLocaleString的参数及用法在MDN（Number.prototype.toLocaleString()）中有详细的用法，感兴趣的小伙伴可以深入了解一下\u003c/blockquote\u003e","art_author":"yellow star","art_createtime":"2022-11-17T07:47:15.000Z","art_tags":7},{"id":93,"art_title":"React 搭建后台项目","art_content":"\u003ch2\u003e创建一个项目\u003c/h2\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(0, 0, 0);\"\u003e官网推荐的工具链\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003eReact 团队主要推荐这些解决方案：\u003c/span\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e如果你是在\u003c/span\u003e\u003cstrong\u003e学习 React\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e 或\u003c/span\u003e\u003cstrong\u003e创建一个新的\u003c/strong\u003e单页\u003cstrong\u003e应用\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e，请使用 \u003c/span\u003eCreate React App\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e如果你是在\u003c/span\u003e\u003cstrong\u003e用 Node.js 构建服务端渲染的网站\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e，试试 \u003c/span\u003eNext.js\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e如果你是在构建\u003c/span\u003e\u003cstrong\u003e内容主导的静态网站\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e，试试 \u003c/span\u003eGatsby\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e如果你是在打造\u003c/span\u003e\u003cstrong\u003e组件库\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e或\u003c/span\u003e\u003cstrong\u003e将 React 集成到现有代码仓库\u003c/strong\u003e\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e，尝试\u003c/span\u003e更灵活的工具链\u003cspan style=\"color: rgb(26, 26, 26);\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(0, 0, 0);\"\u003eCreate React App\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003ca href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\"\u003eCreate React App\u003c/a\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 是一个用于\u003c/span\u003e\u003cstrong\u003e学习 React\u003c/strong\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 的舒适环境，也是用 React 创建\u003c/span\u003e\u003cstrong\u003e新的\u003c/strong\u003e\u003ca href=\"https://zh-hans.reactjs.org/docs/glossary.html#single-page-application\" target=\"_blank\"\u003e单页\u003c/a\u003e\u003cstrong\u003e应用\u003c/strong\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e的最佳方式。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 \u003c/span\u003e\u003ca href=\"https://nodejs.org/en/\" target=\"_blank\"\u003eNode \u0026gt;= 14.0.0 和 npm \u0026gt;= 5.6\u003c/a\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e。要创建项目，请执行：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpx create-react-app my-app \ncd my-app \nnpm start\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e第一行的 \u003c/span\u003e\u003cspan style=\"color: rgb(26, 26, 26); font-size: 16px;\"\u003enpx\u003c/span\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 不是拼写错误 —— 它是 \u003c/span\u003enpm 5.2+ 附带的 package 运行工具\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003eCreate React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 \u003c/span\u003e\u003ca href=\"https://babeljs.io/\" target=\"_blank\"\u003eBabel\u003c/a\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 和 \u003c/span\u003e\u003ca href=\"https://webpack.js.org/\" target=\"_blank\"\u003ewebpack\u003c/a\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e，但你无需了解它们的任何细节。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e当你准备好部署到生产环境时，执行 \u003c/span\u003e\u003cspan style=\"color: rgb(26, 26, 26); font-size: 16px;\"\u003enpm run build\u003c/span\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 会在 \u003c/span\u003e\u003cspan style=\"color: rgb(26, 26, 26); font-size: 16px;\"\u003ebuild\u003c/span\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 16px;\"\u003e 文件夹内生成你应用的优化版本。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e项目初始页面：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667288055402-d6851283-8b72-48bb-b4cb-dab40dea6a4b.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e初始目录结构：\u003c/p\u003e\u003cpre\u003e\u003ccode \u003emy-app\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\t\t\t\t\t\t\t\t\t # 不参与编译的资源文件\n│   ├── favicon.ico\n│   ├── index.html\n│   └── manifest.json\n└── src\t\t\t\t\t\t\t\t\t\t\t # 主程序目录\t\t\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    └── serviceWorker.js\n    └── setupTests.js\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e一个模块（页面/组件）的基本代码结构\u003c/h3\u003e\u003cp\u003ehello.jsx:\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport React, { useState } from 'react'\nimport styles from './index.module.scss'\n\nconst app = () =\u0026gt; {\n  \n  const [data, setData] = useState('hello world')\n  \n  const onChange = () =\u0026gt; {\n    setActiveKey('changed')\n  }\n\n  return (\n    \u0026lt;div className={styles.box} onClick={onChange}\u0026gt;\n  \t\t{data}\n    \u0026lt;/div\u0026gt;\n  )\n}\n\nexport default app\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e构建路由 \u003cspan style=\"color: rgb(28, 30, 33); font-size: 16px;\"\u003eReact Router\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e为什么要使用路由？\u003c/p\u003e\u003cp\u003e传统web开发是每一个请求地址都会请求服务器来进行处理，但是用户有些操作则无需请求服务器，直接页面端修改下逻辑就能达到目的，这种最好使用路由，使用路由时，url也是随着改变的，用户浏览到一个网页时可以直接复制或收藏当前页的url给别人，这种方式对于搜索引擎和用户来说都是友好的。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(28, 30, 33); font-size: 16px;\"\u003eReact Router\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(28, 30, 33); font-size: 16px;\"\u003eReact Router是为React（一个用于构建用户界面的 JavaScript 库）设计的一个功能齐全的可以用在客户端和服务端的路由库，它可以在React运行的地方运行，在web上，node.js在服务器上，以及React Native上。\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003cspan style=\"font-size: 16px;\"\u003e安装\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"font-size: 16px;\"\u003e在项目目录下，使用npm下载\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpm install react-router-dom@6 history@5\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e项目中使用\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"font-size: 16px;\"\u003e首先创建路由：选定一个入口文件，并引入 \u003c/span\u003e\u003cspan style=\"color: rgb(28, 30, 33); font-size: 16px;\"\u003eBrowserRouter 组件包裹整个应用；添加路由、嵌套路由、重定向；\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(28, 30, 33); font-size: 16px;\"\u003e入口文件：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport React, { } from 'react'\nimport './App.css'\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route,\n  Navigate\n} from 'react-router-dom'\nimport DefaultLayout from '@/components/Layouts/DefaultLayout'\nimport routesData from './router/routes'\nimport Login from './pages/Login'\n\nfunction App () {\n  return (\n    \u0026lt;div className=\"App\"\u0026gt;\n      \u0026lt;Router\u0026gt;\n        \u0026lt;Routes\u0026gt;\n          {/* 首次进入页面是重定向到/home路径 */}\n          \u0026lt;Route path=\"/\" element={\u0026lt;Navigate to=\"/home\" /\u0026gt;}\u0026gt;\u0026lt;/Route\u0026gt;\n          \u0026lt;Route element={\u0026lt;DefaultLayout /\u0026gt;}\u0026gt;\n            {routesData.map((item: any, index: number) =\u0026gt; {\n              return (\n                \u0026lt;Route\n                  path={item.path}\n                  key={index}\n                  element={\u0026lt;item.component /\u0026gt;}\n                \u0026gt;\u0026lt;/Route\u0026gt;\n              )\n            })}\n          \u0026lt;/Route\u0026gt;\n          \u0026lt;Route path=\"/login\" element={\u0026lt;Login /\u0026gt;} /\u0026gt;\n          \u0026lt;Route path=\"*\" element={\u0026lt;div className=\"noFound\"\u0026gt;Not Found\u0026lt;/div\u0026gt;} /\u0026gt;\n        \u0026lt;/Routes\u0026gt;\n      \u0026lt;/Router\u0026gt;\n    \u0026lt;/div\u0026gt;\n  )\n}\nexport default App\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"font-size: 16px;\"\u003e路由之间的跳转\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"font-size: 16px;\"\u003e方法一：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport { Link } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    \u0026lt;div\u0026gt;\n        \u0026lt;Link to=\"/home\"\u0026gt;home\u0026lt;/Link\u0026gt;\n        \u0026lt;Link to=\"/login\"\u0026gt;login\u0026lt;/Link\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"font-size: 16px;\"\u003e方法二：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport { useNavigate } from \"react-router-dom\";\n\nexport default function App() {\n  const navigate = useNavigate()\n  return (\n    \u0026lt;div\u0026gt;\n        \u0026lt;button onClick={()=\u0026gt;navigate('/home')}\u0026gt;home\u0026lt;/button\u0026gt;\n        \u0026lt;button onClick={()=\u0026gt;navigate('/login')}\u0026gt;login\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e配置Antd组件库\u003c/h2\u003e\u003cp\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\"\u003eantd\u003c/span\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\u003c/span\u003e\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667289069588-daffe4f2-9fbc-4a09-886d-daa1658ebade.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85);\"\u003e✨\u003c/span\u003e\u003cstrong\u003e 特性：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e🌈 提炼自企业级中后台产品的交互语言和视觉风格。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e📦 开箱即用的高质量 React 组件。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e🛡 使用 TypeScript 开发，提供完整的类型定义文件。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e⚙️ 全链路开发和设计工具体系。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e🌍 数十个国际化语言支持。\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e🎨 深入每个细节的主题定制能力。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e安装使用\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpm install antd\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用一个按钮组件\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport React from 'react';\nimport { Button } from 'antd';\nimport './App.css';\n\nconst App = () =\u0026gt; (\n  \u0026lt;div className=\"App\"\u0026gt;\n    \u0026lt;Button type=\"primary\"\u0026gt;Button\u0026lt;/Button\u0026gt;\n  \u0026lt;/div\u0026gt;\n);\n\nexport default App;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e导入样式，\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e修改 \u003c/span\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\"\u003esrc/App.css\u003c/span\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e，在文件顶部引入 \u003c/span\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\"\u003eantd/dist/antd.css\u003c/span\u003e\u003cspan style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e@import '~antd/dist/antd.css';\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e全局配置中文语言环境，默认情况下，antd语言是英文，需要手动修改回中文环境\u003c/p\u003e\u003cp\u003eindex.js:\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\nimport { ConfigProvider } from 'antd'\nimport zhCN from 'antd/es/locale/zh_CN'\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n)\nroot.render(\n  // ConfigProvider antd全局配置中文语言环境\n  \u0026lt;ConfigProvider locale={zhCN}\u0026gt;\n    \u0026lt;App /\u0026gt;\n  \u0026lt;/ConfigProvider\u0026gt;\n)\n\nreportWebVitals()\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e封装全局组件\u003c/h2\u003e\u003cp\u003e在src/components路径下创建全局组件,解决重复利用，开发代码基本和页面开发一致，\u003c/p\u003e\u003cp\u003e举个例子：\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport styles from './index.module.scss'\nimport React, { } from 'react'\n\nconst App = (props) =\u0026gt; {\n  const { title = '段落标题', children, style } = props\n  return (\n    \u0026lt;div className={styles.box} style={style}\u0026gt;\n      \u0026lt;div className={styles.header}\u0026gt;\u0026lt;div className={styles.headerItem}\u0026gt;{title}\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n      \u0026lt;div className={styles.content}\u0026gt;{ children}\u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  )\n}\nexport default App\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e调用\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport Plates from '@/components/Plates'\n\n...\n\n\u0026lt;Plates title={'费用详情'}\u0026gt;\n  \u0026lt;Table\n    columns={columns}\n    dataSource={data}\n    pagination={false}\n    bordered\n    size={'small'}\n  /\u0026gt;\n\u0026lt;/Plates\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668648752246-771519a6-4446-48b8-a095-848e711a9bcc.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003ch2\u003e二次封装请求函数\u003c/h2\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(51, 51, 51);\"\u003eAxios 是什么?\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eAxios 是一个基于 \u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fpromise-basics\" target=\"_blank\"\u003epromise\u003c/a\u003e 网络请求库，作用于\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2F\" target=\"_blank\"\u003enode.js\u003c/a\u003e 和浏览器中。 它是 \u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.lullabot.com%2Farticles%2Fwhat-is-an-isomorphic-application\" target=\"_blank\"\u003eisomorphic\u003c/a\u003e 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e特性\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e从浏览器中创建 \u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003eXMLHttpRequests\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e从 \u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003enode.js\u003c/span\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e 创建 \u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003ehttp\u003c/span\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e请求\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e支持 \u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003ePromise\u003c/span\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e API\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e拦截请求和响应\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e转换请求数据和响应数据\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e取消请求\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e自动转换\u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003e JSON\u003c/span\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e 数据\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e客户端支持防御\u003c/span\u003e\u003cspan style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"\u003eXSRF\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e\u003cspan style=\"background-color: rgb(255, 245, 245);\"\u003e基本使用\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e安装\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpm install axios\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e导入\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport axios from 'axios'\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003e发送请求\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eaxios({        \n  url:'xxx',    // 设置请求的地址\n  method:\"GET\", // 设置请求方法\n  params:{      // get请求使用params进行参数凭借,如果是post请求用data\n    type: '',\n    page: 1\n  }\n}).then(res =\u0026gt; {  \n  // res为后端返回的数据\n  console.log(res);   \n})\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(51, 51, 51);\"\u003e为什么要封装\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eaxios 的 API 很友好，完全可以很轻松地在项目中直接使用。\u003c/p\u003e\u003cp\u003e不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍，这种重复劳动不仅浪费时间，而且让代码变得冗余增加，难以维护。为了提高代码质量，所以应该在项目中二次封装 axios 再使用。\u003c/p\u003e\u003ch3\u003e如何封装\u003c/h3\u003e\u003cul\u003e\u003cli\u003e封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间......\u003c/li\u003e\u003cli\u003e设置接口请求前缀：根据开发、测试、预发、生产环境的不同，前缀需要加以区分；\u003c/li\u003e\u003cli\u003e请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(比如：用户信息)；\u003c/li\u003e\u003cli\u003e状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好；\u003c/li\u003e\u003cli\u003e请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便\u003c/li\u003e\u003cli\u003e请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问\u003c/li\u003e\u003cli\u003e响应拦截器： 这块就是根据 后端返回来的状态码判定执行不同业务\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e代码实例：\u003c/p\u003e\u003cpre\u003e\u003ccode \u003eimport axios from 'axios'\nimport { message, notification } from 'antd'\n\nconst openNotification = (msg) =\u0026gt; {\n  notification.error({\n    message: '请联系管理员',\n    description: msg\n  })\n}\n\nconst showStatus = (status) =\u0026gt; {\n  let message = ''\n  switch (status) {\n    case 400:\n      message = '请求错误(400)'\n      break\n    case 401:\n      message = '未授权，请重新登录(401)'\n      break\n    case 402:\n      message = '拒绝访问(402)'\n      break\n    case 404:\n      message = '请求出错(404)'\n      break\n    case 408:\n      message = '请求超时(408)'\n      break\n    case 500:\n      message = '服务器错误(500)'\n      break\n    case 501:\n      message = '服务未实现(501)'\n      break\n    case 502:\n      message = '网络错误(502)'\n      break\n    case 503:\n      message = '服务不可用(503)'\n      break\n    case 504:\n      message = '网络超时(504)'\n      break\n    case 505:\n      message = 'HTTP版本不受支持(505)'\n      break\n    default:\n      message = `连接出错(${status})!`\n  }\n  return `${message}，请检查网络或联系管理员！`\n}\n\nconst service = axios.create({\n  // 联调\n\n  headers: {\n    get: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    },\n    post: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    }\n  },\n  // 是否跨站点访问控制请求\n  withCredentials: false,\n  timeout: 30000,\n  validateStatus () {\n    // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常\n    return true\n  }\n})\n\n// 请求拦截器\nservice.interceptors.request.use(\n  config =\u0026gt; {\n    // 将 token 添加到请求头\n    const token = localStorage.getItem('token')\n    token \u0026\u0026 (config.headers.token = token)\n    return config\n  },\n  (err) =\u0026gt; {\n    err.message = '服务器异常，请联系管理员！'\n    // 错误抛到业务代码\n    return Promise.reject(err)\n  }\n)\n\n// 响应拦截器\nservice.interceptors.response.use(\n  response =\u0026gt; {\n    const status = response.status\n    let msg = ''\n    if ((status \u0026lt; 200) || (status \u0026gt;= 300 \u0026\u0026 status !== 401 \u0026\u0026 status !== 500)) {\n      // 处理http错误，抛到业务代码\n      msg = showStatus(status)\n      openNotification(msg)\n      if (typeof response.data === 'string') {\n        response.data = { msg }\n      } else {\n        response.data.msg = msg\n      }\n      return response\n    } else if (status === 200) {\n      if (!response.data.success) {\n        message.error(response.data.message)\n      }\n      return response.data\n    } else if (status === 500) {\n      msg = showStatus(status)\n      openNotification(msg)\n      response.data = { msg }\n      //   router.replace({name:'exception',query:{type:500}})\n      return response\n    }\n  },\n  (err) =\u0026gt; {\n    err.message = '请求超时或服务器异常，请检查网络或联系管理员！'\n    openNotification('请求超时或服务器异常，请检查网络或联系管理员！')\n    // return Promise.reject(err)\n  }\n)\n\nexport default service\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eCSS Modules + node-sass\u003c/h2\u003e\u003ch3\u003e什么是CSS Modules\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(10, 10, 35);\"\u003e所有的类名和动画名称默认都有各自的作用域的 CSS 文件。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(10, 10, 35);\"\u003e所以 CSS Modules 既不是官方标准，也不是浏览器的特性，而是在构建步骤（例如使用 Webpack 或 Browserify）中对 CSS 类名和选择器限定作用域的一种方式（类似于命名空间）。\u003c/span\u003e\u003c/p\u003e\u003ch3\u003enode-sass\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(10, 10, 35);\"\u003enode sass是一个库，它将Node.js绑定到LibSass【流行样式表预处理器Sass的C版本】，它允许用户以令人难以置信的速度将【.scss】文件本地编译为css，并通过连接中间件自动编译。\u003c/span\u003e\u003c/p\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(33, 37, 41);\"\u003e为什么使用scss，而不是传统的css\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e使用 scss 可以编写清晰、无冗余、语义化的 css。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e变量\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e是 scss 提供的最基本的工具。通过变量可以让独立的 css 值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e同样基础的是 scss 的 \u003c/span\u003e\u003cstrong\u003e嵌套机制\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e。嵌套允许css规则内嵌套css规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。scss同时提供了特殊的\u003c/span\u003e\u003cstrong\u003e父选择器标识符 \u0026\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e ，通过它可以构造出更高效的嵌套。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e混合器\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e允许用户编写语义化样式的同时避免视觉层面上样式的重复。使用混合器减少重复，使用混合器让你的css变得更加可维护和语义化。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e与混合器相辅相成的\u003c/span\u003e\u003cstrong\u003e选择器继承\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e样式导入\u003c/strong\u003e\u003cspan style=\"color: rgb(33, 37, 41); font-size: 16px;\"\u003e，scss 的另一个重要特性。通过样式导入可以把分散在多个sass文件中的内容合并生成到一个css文件，避免了项目中有大量的css文件通过原生的css @import带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。\u003c/span\u003e\u003c/p\u003e\u003ch2\u003e状态管理工具 mobx\u003c/h2\u003e\u003cp\u003e\u003cem\u003e简单、可扩展的状态管理\u003c/em\u003e\u003c/p\u003e\u003ch3\u003e\u003cspan style=\"color: rgb(51, 51, 51);\"\u003eMobx工作流程\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668651326688-11627ad0-e87a-463e-82a5-09d5445f86a4.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(51, 51, 51); font-size: 16px;\"\u003eReact 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。\u003c/span\u003e\u003c/p\u003e\u003ch2\u003e\u003cspan style=\"font-size: 14px;\"\u003eESlint代码规范\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy\" target=\"\"\u003ehttps://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e项目优化\u003c/h2\u003e\u003ch4\u003e\u003cspan style=\"font-size: 14px;\"\u003e绝对路径 @ \u003c/span\u003e\u003c/h4\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"font-size: 14px;\"\u003e使用\u003c/span\u003e\u003ca href=\"https://github.com/timarney/react-app-rewired\" target=\"_blank\"\u003ereact-app-rewired\u003c/a\u003e\u003cspan style=\"font-size: 14px;\"\u003e来对react-scripts进行hack。\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e$ yarn add -D react-app-rewired //或 $ npm install react-app-rewired --save-dev\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"font-size: 14px;\"\u003e然后修改\u003c/span\u003e\u003cstrong\u003epackage.json\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e，将\u003c/span\u003e\u003cstrong\u003estart\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e、\u003c/span\u003e\u003cstrong\u003ebuild\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e、\u003c/span\u003e\u003cstrong\u003etest\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e三个命令由react-scripts换成\u003c/span\u003e\u003cspan style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\"\u003ereact-app-rewired\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e\"scripts\": { \n  \t\"start\": \"react-app-rewired start\", \n    \"build\": \"react-app-rewired build\", \n    \"test\": \"react-app-rewired test\", \n    \"eject\": \"react-scripts eject\" \n},\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"font-size: 14px;\"\u003e在根目录下创建\u003c/span\u003e\u003cstrong\u003econfig-overrides.js\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003econst path = require('path'); \nconst rootPath = path.resolve(__dirname, 'src'); \n\nmodule.exports = { \n  webpack: (config) =\u0026gt; { \n    config.resolve.alias['@'] = rootPath; \n    return config; \n  }, \n}\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: left;\"\u003e\u003cstrong\u003e注意：\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e修改完文件后，\u003c/span\u003e\u003cstrong\u003e必须先重启项目\u003c/strong\u003e\u003cspan style=\"font-size: 14px;\"\u003e，然后再使用绝对路径，\u003c/span\u003e\u003cspan style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\"\u003e@\u003c/span\u003e\u003cspan style=\"font-size: 14px;\"\u003e代表的就是\u003c/span\u003e\u003cspan style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\"\u003e根目录/src\u003c/span\u003e\u003cspan style=\"font-size: 14px;\"\u003e 。\u003c/span\u003e\u003c/p\u003e\u003ch4\u003ehelper.js\u003c/h4\u003e\u003ch4\u003e页面跳转过渡状态\u003c/h4\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-17T03:04:38.000Z","art_tags":4},{"id":92,"art_title":"vercel免费分配二级域名，并部署应用🚀","art_content":"\u003cp style=\"text-align: left;\"\u003e在 \u003ca href=\"https://vercel.com/\" target=\"_blank\"\u003ehttps://vercel.com/\u003c/a\u003e 中可以免费部署你的nextjs项目或者个人网站；它是通过关联GitHub仓库实现自动化部署，并且会分配一个免费的二级域名；nice！\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1668503171393.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1668503396271.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-15T09:10:29.000Z","art_tags":4},{"id":90,"art_title":"增加了tag功能📢","art_content":"\u003cp\u003etag！！！\u003c/p\u003e\u003cp\u003etag！！！\u003c/p\u003e\u003cp\u003etag！！！\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-15T08:23:36.000Z","art_tags":8},{"id":86,"art_title":"【收藏】发现一个机场测速平台👨‍💻","art_content":"\u003cp\u003e节点再也不担心翻车了📢\u003c/p\u003e\u003cp\u003e \u003ca href=\"https://www.duyaoss.com/\" target=\"_blank\"\u003ehttps://www.duyaoss.com/\u003c/a\u003e \u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-15T07:16:51.000Z","art_tags":null},{"id":85,"art_title":"【CSS】display:grid; 布局","art_content":"\u003cp\u003e属性好多 好难，api参考 \u003ca href=\"https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\"\u003ehttps://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\u003c/a\u003e \u003c/p\u003e\u003cp\u003edemo查看 \u0026nbsp;\u003ca href=\"/gridauto\" target=\"_blank\"\u003egrid-demo\u003c/a\u003e \u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1668416165008.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-14T08:56:16.000Z","art_tags":null},{"id":84,"art_title":"Web Sockets、Web Worker 和 Service Worker 之间的区别","art_content":"\u003cp style=\"text-align: start;\"\u003eWeb Sockets、Web Workers、Service Workers……这些术语您可能已经阅读或无意中听到。也许不是全部，但可能至少其中之一。即使您对前端开发有很好的了解，您也很有可能需要查找它们的含义。或者，也许你像我一样，时不时地把它们混在一起。这些术语看起来和听起来都非常相似，很容易让它们混淆。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e那么，让我们将它们分解在一起，区分 Web Sockets、Web Workers 和 Service Worker。不是从本质上讲，我们会深入研究并获得每个人的实践经验——更像是下次你需要复习时书签的小\u003cs\u003e帮手\u003c/s\u003e。\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003e快速参考\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e我们将从高级概述开始，以便进行快速比较和对比。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ctable style=\"width: auto;\"\u003e\u003ctbody\u003e\u003ctr\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003e特征\u003c/strong\u003e\u003c/th\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003e这是什么\u003c/strong\u003e\u003c/th\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003eWeb Socket\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e在浏览器和服务器之间建立开放且持久的双向连接，以通过事件触发的单个连接发送和接收消息。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003eWeb Worker\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e允许脚本在单独的线程中在后台运行，以防止脚本在主线程上相互阻塞。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003eService Worker\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e一种 Web Worker，它创建一个后台服务，该服务充当中间件，用于处理浏览器和服务器之间的网络请求，即使在离线情况下也是如此。\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch3 style=\"text-align: start;\"\u003e网络套接字\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003eWeb Socket 是一种双向通信协议。把这想象成你和你的朋友之间正在进行的通话，除非你们中的一个人决定挂断，否则它不会结束。唯一的区别是你是浏览器，你的朋友是服务器。客户端向服务器发送请求，服务器通过处理客户端的请求进行响应，反之亦然。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cimg src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/10/s_946F1219BF833C90E2A9F5AFF16573F7EDD61CBB9CE5FD38969485809A5FD1A8_1666620506067_YpooKVs9-.png?resize=500%2C500\u0026amp;ssl=1\" alt=\"分别代表浏览器和服务器的两名女性的插图。 它们之间的箭头显示了活动连接中的通信流程。\" data-href=\"\" style=\"height: auto !important;\"\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e通信基于事件。建立一个\u003ccode\u003eWebSocket\u003c/code\u003e对象并连接到服务器，服务器之间的消息触发发送和接收它们的事件。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这意味着当建立初始连接时，我们有一个客户端-服务器通信，其中一个连接被启动并保持活动状态，直到客户端或服务器选择通过发送一个\u003ccode\u003eCloseEvent\u003c/code\u003e. 这使得 Web Sockets 非常适合需要在客户端和服务器之间进行连续和直接通信的应用程序。我见过的大多数定义都将聊天应用程序称为常见用例——您键入一条消息，将其发送到服务器，触发一个事件，然后服务器用数据进行响应，而无需一遍又一遍地 ping 服务器。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e考虑这种情况\u003c/strong\u003e：您正在出门，并决定打开 Google 地图。您可能已经知道 Google 地图的工作原理，但如果您不知道，它会在您连接到应用程序后自动找到您的位置，并随时随地跟踪它。只要此连接处于活动状态，它就会使用实时数据传输来跟踪您的位置。这是一个 Web Socket，它在浏览器和服务器之间建立持久的双向对话，以使数据保持最新。具有实时比分的体育应用程序也可以通过这种方式使用 Web Sockets。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eWeb Sockets 和 Web Worker（以及我们将看到的 Service Worker）之间的最大区别在于它们可以直接访问 DOM。Web Worker（和 Service Worker）在不同的线程上运行，而 Web Sockets 是主线程的一部分，这使它们能够操作 DOM。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e有一些工具和服务可以帮助建立和维护 Web Socket 连接，包括：\u003ca href=\"https://socketcluster.io/\" target=\"\"\u003eSocketCluster\u003c/a\u003e、\u003ca href=\"https://www.asyncapi.com/\" target=\"\"\u003eAsyncAPI\u003c/a\u003e、\u003ca href=\"https://github.com/ninenines/cowboy\" target=\"\"\u003ecowboy\u003c/a\u003e、\u003ca href=\"https://websocketking.com/\" target=\"\"\u003eWebSocket King\u003c/a\u003e、\u003ca href=\"https://channels.readthedocs.io/en/stable/index.html\" target=\"\"\u003eChannels\u003c/a\u003e和\u003ca href=\"https://pkg.go.dev/github.com/gorilla/websocket\" target=\"\"\u003eGorilla WebSocket\u003c/a\u003e。MDN 有一个\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API#tools\" target=\"\"\u003e包含其他服务的运行列表\u003c/a\u003e。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003e更多 Web 套接字信息\u003c/h4\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003e\u003ca href=\"https://web.dev/websockets-basics/\" target=\"\"\u003e介绍 WebSockets – 将 Sockets 引入 Web\u003c/a\u003e (web.dev)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://css-tricks.com/thinking-about-power-usage-and-websites/\" target=\"\"\u003e考虑用电和网站\u003c/a\u003e(Chris Coyier)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\" target=\"\"\u003eWebSocket API\u003c/a\u003e (MDN 文档)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://caniuse.com/websockets\" target=\"\"\u003e最新的浏览器支持\u003c/a\u003e(Caniuse)\u003c/li\u003e\u003c/ul\u003e\u003ch3 style=\"text-align: start;\"\u003e\u003c/h3\u003e\u003ch3 style=\"text-align: start;\"\u003eWeb Workers\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e考虑一个场景，您需要执行一堆复杂的计算，同时对 DOM 进行更改。JavaScript 是一种单线程应用程序，运行多个脚本可能会破坏您尝试更改的用户界面以及正在执行的复杂计算。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这就是 Web Workers 发挥作用的地方。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eWeb Worker 允许脚本在不同线程的后台运行，以防止脚本在主线程上相互阻塞。这使得它们非常适合提高需要密集操作的应用程序的性能，因为这些操作可以在后台在单独的线程上执行，而不会影响用户界面的渲染。但是它们在访问 DOM 方面并不是那么出色，因为与 Web Sockets 不同的是，Web Worker 在其自己的线程中运行在主线程之外。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eWeb Worker 是一个对象，它通过使用\u003ccode\u003eWorker\u003c/code\u003e对象来执行任务来执行脚本文件。当我们谈论工人时，他们往往属于以下三种类型之一：\u003c/p\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003e\u003cstrong\u003e专用工人：\u003c/strong\u003e专用工人只能通过调用它的脚本来实现。它仍然执行典型 Web Worker 的任务，例如它的多线程脚本。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e共享工作者：\u003c/strong\u003e共享工作者与专用工作者相反。它可以被多个脚本访问，并且实际上可以执行 web worker 执行的任何任务，只要它们与 worker 存在于同一个域中。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eService Worker：\u003c/strong\u003e Service Worker 充当应用程序、浏览器和服务器之间的网络代理，即使在网络离线时也允许脚本运行。我们将在下一节讨论这个问题。\u003c/li\u003e\u003c/ul\u003e\u003ch4 style=\"text-align: start;\"\u003eMore Web Workers information\u003c/h4\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003e\u003ca href=\"https://css-tricks.com/off-the-main-thread/\" target=\"\"\u003e“脱离主线”\u003c/a\u003e（克里斯·科伊尔）\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://css-tricks.com/the-state-of-web-workers-in-2021/\" target=\"\"\u003e2021 年 Web 工作者的状态\u003c/a\u003e(Chris Coyier)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://zapier.com/engineering/intro-to-web-workers/\" target=\"\"\u003eWeb Workers 简介\u003c/a\u003e(Zapier)\u003c/li\u003e\u003cli\u003e Web Workers\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\" target=\"\"\u003e API\u003c/a\u003e（MDN 文档）\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://caniuse.com/webworkers\" target=\"\"\u003e最新的浏览器支持\u003c/a\u003e(Caniuse)\u003c/li\u003e\u003c/ul\u003e\u003ch3 style=\"text-align: start;\"\u003eService Workers\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e作为开发人员，有些事情我们无法控制，其中之一就是用户的网络连接。无论用户连接到什么网络，它就是什么。我们只能尽最大努力优化我们的应用程序，以便它们在碰巧使用的任何连接上都能发挥最佳性能。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eService Worker 是我们可以做的事情之一，以逐步提高应用程序的性能。服务工作者位于应用程序、浏览器和服务器之间，提供在后台运行在单独线程上的安全连接，这要归功于——你猜对了——Web Workers。正如我们在上一节中了解到的，Service Worker 是三种类型的 Web Worker 之一。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e那么，为什么你需要一个\u003cspan style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"\u003eservice worker\u003c/span\u003e坐在你的应用程序和用户的浏览器之间呢？同样，我们无法控制用户的网络连接。假设连接由于某种未知原因而中断。这会破坏浏览器和服务器之间的通信，阻止数据来回传递。服务工作者维护连接，充当能够拦截请求和执行任务的异步代理——即使在网络连接丢失之后也是如此。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cimg src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/10/s_946F1219BF833C90E2A9F5AFF16573F7EDD61CBB9CE5FD38969485809A5FD1A8_1666620745315_fmg2Vf-3x.png?resize=500%2C500\u0026amp;ssl=1\" alt=\"一个标记为 Service Worker 的齿轮图标位于标记为客户端的浏览器图标和标记为服务器的云图标之间。\" data-href=\"\" style=\"height: auto !important;\"\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这是通常被称为\u003ca href=\"https://css-tricks.com/instant-loading-building-offline-first-progressive-web-apps/\" target=\"\"\u003e“离线优先”开发\u003c/a\u003e的主要驱动力。我们可以将资产存储在本地缓存而不是网络中，在用户离线时提供关键信息，预取内容以便在用户需要时准备好，并提供回退以响应网络错误。它们是完全异步的，但与 Web Socket 不同，它们无法访问 DOM，因为它们在自己的线程上运行。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e关于 Service Workers 要了解的另一件大事是它们拦截来自您的应用程序的每一个请求和响应。因此，它们具有一些安全隐患，最值得注意的是它们遵循同源策略。因此，这意味着没有从 CDN 或第三方服务运行服务工作者。它们还需要安全的 HTTPS 连接，这意味着您需要 SSL 证书才能运行它们。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003e更多服务工作者信息\u003c/h4\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003e\u003ca href=\"https://css-tricks.com/add-a-service-worker-to-your-site/\" target=\"\"\u003e将 Service Worker 添加到您的站点\u003c/a\u003e(Chris Ferdinadi)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.chrome.com/docs/workbox/service-worker-overview/\" target=\"\"\u003eService Worker 概述\u003c/a\u003e（Chrome 开发人员）\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://philipwalton.com/articles/smaller-html-payloads-with-service-workers/\" target=\"\"\u003e使用 Service Worker 的更小的 HTML 有效负载\u003c/a\u003e(Philip Walton)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://serviceworke.rs/\" target=\"\"\u003e服务工作者手册\u003c/a\u003e(Mozilla)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" target=\"\"\u003e服务工作者 API\u003c/a\u003e（MDN 文档）\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://caniuse.com/serviceworkers\" target=\"\"\u003e最新的浏览器支持\u003c/a\u003e(Caniuse)\u003c/li\u003e\u003c/ul\u003e\u003ch3 style=\"text-align: start;\"\u003e包起来\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e这是对 Web Sockets、Web Worker 和 Service Worker 之间差异（和相似之处）的超高级解释。同样，术语和概念非常相似，可以将它们混为一谈，但希望这能让您更好地了解如何区分它们。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e我们从一个快速参考表开始。这是同样的事情，但稍微扩大以进行更深入的比较。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ctable style=\"width: auto;\"\u003e\u003ctbody\u003e\u003ctr\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003e特征\u003c/strong\u003e\u003c/th\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003e这是什么\u003c/strong\u003e\u003c/th\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003e多线程？\u003c/strong\u003e\u003c/th\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003eHTTPS？\u003c/strong\u003e\u003c/th\u003e\u003cth colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"\u003e\u003cstrong\u003eDOM 访问？\u003c/strong\u003e\u003c/th\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003e网络套接字\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e在浏览器和服务器之间建立开放且持久的双向连接，以通过事件触发的单个连接发送和接收消息。\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e在主线程上运行\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e不需要\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e是的\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003eWeb Worker\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e允许脚本在单独的线程中在后台运行，以防止脚本在主线程上相互阻塞。\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e在单独的线程上运行\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e必需的\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e不\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e\u003cstrong\u003eService Worker\u003c/strong\u003e\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e一种 Web Worker，它创建一个后台服务，该服务充当中间件，用于处理浏览器和服务器之间的网络请求，即使在离线情况下也是如此。\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e在单独的线程上运行\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e必需的\u003c/td\u003e\u003ctd colSpan=\"1\" rowSpan=\"1\" width=\"auto\"\u003e不\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-14T06:20:30.000Z","art_tags":null},{"id":83,"art_title":"乱搞","art_content":"\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=35d92b9406f3a90b65fe0035725885b6-1668229110059.jpeg\" alt=\"\" data-href=\"\" style=\"width: 407.00px;height: 407.00px;\"\u003e\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e勒好啊\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-12T04:59:23.000Z","art_tags":null},{"id":82,"art_title":"【CSS】渐变魔方","art_content":"\u003cp style=\"text-align: center;\"\u003e纯css实现\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e \u003ca href=\"/cubeshover\" target=\"_blank\"\u003e跳转查看\u003c/a\u003e \u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e \u003ca href=\"https://github.com/Mr-majifu/Cubes-Hover-Effects\" target=\"_blank\"\u003eGitHub\u003c/a\u003e\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1668148205530.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-11T06:32:09.000Z","art_tags":null},{"id":81,"art_title":"【CSS】抄了一个好看的navBar","art_content":"\u003cp style=\"text-align: center;\"\u003e 🎈 \u003ca href=\"/navbarcss\" target=\"_blank\"\u003e跳转查看\u003c/a\u003e \u0026nbsp; \u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e \u003ca href=\"https://github.com/Mr-majifu/Magic-Menu-Indicator\" target=\"_blank\"\u003eGithub\u003c/a\u003e\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1668136681098.png\" alt=\"\" data-href=\"\" style=\"\"\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-11T03:18:24.000Z","art_tags":null},{"id":80,"art_title":"【CSS】CSS 中的 :root","art_content":"\u003ch2 style=\"text-align: start;\"\u003e:root\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;:root是一个伪类，表示文档根元素，所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本。在:root中声明相当于全局属性，只要当前页面引用了:root segment所在文件，都可以使用var()来引用。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-css\"\u003e:root {\r\n    --blue: #007bff;\r\n    --indigo: #6610f2;\r\n    --purple: #6f42c1;\r\n    --pink: #e83e8c;\r\n    --red: #dc3545;\r\n    --orange: #fd7e14;\r\n    --yellow: #ffc107;\r\n    --green: #28a745;\r\n    --teal: #20c997;\r\n    --cyan: #17a2b8;\r\n    --white: #fff;\r\n    --gray: #6c757d;\r\n    --gray-dark: #343a40;\r\n    --primary: #007bff;\r\n    --secondary: #6c757d;\r\n    --success: #28a745;\r\n    --info: #17a2b8;\r\n    --warning: #ffc107;\r\n    --danger: #dc3545;\r\n    --light: #f8f9fa;\r\n    --dark: #343a40;\r\n    --breakpoint-xs: 0;\r\n    --breakpoint-sm: 576px;\r\n    --breakpoint-md: 768px;\r\n    --breakpoint-lg: 992px;\r\n    --breakpoint-xl: 1200px;\r\n    --breakpoint-xxl: 1600px;\r\n    --font-family-sans-serif: -apple-system, BlinkMacSystemFont;\r\n    --font-family-monospace: SFMono-Regular, Menlo, Monaco, Consolas;\r\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003evar()\u003c/h2\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;var()函数可以代替元素中任何属性中的值的任何部分。var()函数不能作为属性名、选择器或者其他除了属性值之外的值。（这样做通常会产生无效的语法或者一个没有关联到变量的值。）\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-css\"\u003ebody {\n  background-color: var(--blue);  /* 设置背景颜色为蓝色 */\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-11T03:13:30.000Z","art_tags":null},{"id":78,"art_title":"Gitee Go 实现远程自动部署","art_content":"\u003cp\u003e🚀\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=image-1667976257980.png\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-09T07:37:36.000Z","art_tags":null},{"id":77,"art_title":"【壁纸】测试图片上传bug，最终版","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=xenoblade Homura-1667886321361.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e \u0026nbsp; 继续调节获取时间语句位置，测试通过！\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-08T05:46:33.000Z","art_tags":null},{"id":75,"art_title":"【计划】","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=iTab-e7j33o-1667805206433.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp;规划一下学习路线：\u003c/p\u003e\u003cul\u003e\u003cli\u003eTS慢慢学起来\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli\u003eantd Pro 熟悉起来\u003c/li\u003e\u003cli\u003ereact native 可以学习下\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e \u0026nbsp; \u0026nbsp;\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-07T07:16:26.000Z","art_tags":null},{"id":74,"art_title":"【壁纸】2022/11/07","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=168917-1667793965047.webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-07T04:06:35.000Z","art_tags":null},{"id":71,"art_title":"【测试】pm2 图片上传功能修复完成📢","art_content":"\u003cp\u003e原项目，获取日期创建文件夹写在了全局，导致项目启动日期只获取一次，故过一天会出现图片上传成功，获取图片失败的bug。\u003c/p\u003e\u003cp\u003e解决：\u003c/p\u003e\u003cp\u003e将获取日期写在接口处理函数内，每次创建文件夹都是最新的日期！\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221014151720-1667371174132.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-02T06:42:57.000Z","art_tags":null},{"id":70,"art_title":"【屌图】程序员能有什么压力","art_content":"\u003cp\u003e👨‍💻\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221025105908-1667369141159.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-02T06:10:15.000Z","art_tags":null},{"id":69,"art_title":"【技术】structuredClone深拷贝","art_content":"\u003ch2\u003e对象转换为 JSON 字符串，再转换为对象\u003c/h2\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = JSON.parse(JSON.stringify(obj));\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJSON.parse(JSON.stringify(obj))可比上面 deepClone 函数简洁多了，但不是好的实践，因为它有以下缺点：\u003c/p\u003e\u003cul\u003e\u003cli style=\"text-align: left;\"\u003e会忽略 undefined\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e会忽略 symbol\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e不能序列化函数\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e不能解决循环引用的对象\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e如果 data 里有NaN、Infinity和-Infinity，则序列化的结果会变成null\u003c/li\u003e\u003cli style=\"text-align: left;\"\u003e致命缺陷，性能差\u003c/li\u003e\u003c/ul\u003e\u003ch2 style=\"text-align: left;\"\u003estructuredClone\u003c/h2\u003e\u003cp style=\"text-align: left;\"\u003e\u003cspan style=\"color: rgb(0, 0, 0); font-size: 13px; font-family: \u0026quot;Courier New\u0026quot;;\"\u003estructuredClone\u003c/span\u003e\u0026nbsp;是 HTML5 一个新的 API，它可以实现深拷贝。\u003c/p\u003e\u003cpre\u003e\u003ccode \u003econst obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = structuredClone(obj);\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该方法还支持把原始值中的 transferable objects (en-US) (可转移对象) 转移到新对象，而不是把属性引用拷贝过去。 可转移对象与原始对象分离并附加到新对象;它们不可以在原始对象中访问被访问到。目前要考虑浏览器以及nodejs版本兼容性问题\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-02T04:07:59.000Z","art_tags":null},{"id":68,"art_title":"JavaScript将图片转换成Base64字符串的几种方法","art_content":"\u003ch2\u003eFileReader 方法\u003c/h2\u003e\u003cp\u003eLoad the image as blob via \u003ca href=\"https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003eXMLHttpRequest\u003c/span\u003e\u003c/a\u003e and use the \u003ca href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003eFileReader API\u003c/span\u003e\u003c/a\u003e (\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003ereadAsDataURL()\u003c/span\u003e\u003c/a\u003e) to convert it to a \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003edataURL\u003c/span\u003e\u003c/a\u003e:\u003c/p\u003e\u003cp\u003e通过 XMLHttpRequest 以blob格式请求图像，图像数据返回成功之后， 使用 \u003ca href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003eFileReader API\u003c/span\u003e\u003c/a\u003e (\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003ereadAsDataURL()\u003c/span\u003e\u003c/a\u003e) 将其转换为 dataURL：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction toDataURL(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.onload = function() {\n    var reader = new FileReader();\n    reader.onloadend = function() {\n      callback(reader.result);\n    }\n    reader.readAsDataURL(xhr.response);\n  };\n  xhr.open('GET', url);\n  xhr.responseType = 'blob';\n  xhr.send();\n}\n\ntoDataURL('https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0', function(dataUrl) {\n  console.log('RESULT:', dataUrl)\n})\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以下代码发送请求部分也可以使用 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003efetch API\u003c/span\u003e\u003c/a\u003e 接口实现：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst toDataURL = url =\u0026gt; fetch(url)\n  .then(response =\u0026gt; response.blob())\n  .then(blob =\u0026gt; new Promise((resolve, reject) =\u0026gt; {\n    const reader = new FileReader()\n    reader.onloadend = () =\u0026gt; resolve(reader.result)\n    reader.onerror = reject\n    reader.readAsDataURL(blob)\n  }))\n\n\ntoDataURL('https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0')\n  .then(dataUrl =\u0026gt; {\n    console.log('RESULT:', dataUrl)\n  })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这种方式的好处是支持的格式比较多，缺点就是 FileReader API 的兼容性差一点，有部分手机浏览器不支持。\u003c/p\u003e\u003ch2\u003eCanvas 方法\u003c/h2\u003e\u003cp\u003e构建一个Image对象，用以加载图片数据。然后通过Canvas的drawImage方法将图片绘制到Canvas上，最后通过Canvas的toDataURL方法将图片转换为base64字符串。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction toDataURL(src, callback, outputFormat) {\n  var img = new Image();\n  img.crossOrigin = 'Anonymous';\n  img.onload = function() {\n    var canvas = document.createElement('CANVAS');\n    var ctx = canvas.getContext('2d');\n    var dataURL;\n    canvas.height = this.naturalHeight;\n    canvas.width = this.naturalWidth;\n    ctx.drawImage(this, 0, 0);\n    dataURL = canvas.toDataURL(outputFormat);\n    callback(dataURL);\n  };\n  img.src = src;\n  if (img.complete || img.complete === undefined) {\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==\";\n    img.src = src;\n  }\n}\n\ntoDataURL(\n  'https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0',\n  function(dataUrl) {\n    console.log('RESULT:', dataUrl)\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这种方式的好处是兼容性好，缺点是只支持图片格式。\u003c/p\u003e\u003ch2\u003e本地图片转换\u003c/h2\u003e\u003cp\u003e如果是本地图片，可以使用 \u003ca href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003eFileReader API\u003c/span\u003e\u003c/a\u003e 的 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"\u003e\u003cspan style=\"color: rgb(0, 56, 132);\"\u003ereadAsDataURL()\u003c/span\u003e\u003c/a\u003e 方法将其转换为 dataURL。\u003c/p\u003e\u003cp\u003e当然，需要有一个文件上传按钮。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction encodeImageFileAsURL(element) {\n  var file = element.files[0];\n  var reader = new FileReader();\n  reader.onloadend = function() {\n    console.log('RESULT', reader.result)\n  }\n  reader.readAsDataURL(file);\n}\n\n\u0026lt;input type=\"file\" onchange=\"encodeImageFileAsURL(this)\" /\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e参考资料\u003c/p\u003e\u003cul\u003e\u003cli style=\"text-align: left;\"\u003eHow can I convert an image into Base64 string using JavaScript? - Stack Overflow\u003c/li\u003e\u003c/ul\u003e","art_author":"yellow star","art_createtime":"2022-11-02T02:59:31.000Z","art_tags":null},{"id":67,"art_title":"【Echarts】legend不能formatter标签和转义字符（老坑人了）","art_content":"\u003cp style=\"text-align: start; line-height: 1.5;\"\u003elegend:{\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e data:['rain','sunny']\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e selected:{\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e 'rain':false,\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e 'sunny':true,\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e }\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e}\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003e \u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003elegend可以数组（多个）/对象（一个）\u003c/p\u003e\u003cp style=\"text-align: start; line-height: 1.5;\"\u003eselected控制是否显示rain的条形数据\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-11-01T12:37:05.000Z","art_tags":null},{"id":65,"art_title":"【技术】比Webpack快700倍的Turbopack，到底快在哪？","art_content":"\u003cblockquote\u003e\u003cspan style=\"color: rgb(102, 102, 102); background-color: rgb(247, 247, 247); font-size: 14px;\"\u003eTurbopack 建立在新的增量架构上，以提供最快的开发体验。在大型应用上，它的更新速度比 Vite 快 10 倍，比Webpack 快 700 倍。在更大的应用上，通常会比 Vite 快 20 倍。\u003c/span\u003e\u003c/blockquote\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e10 月 25 日，Next.js 13 正式发布。同时，Vercel 还推出并开源了下一代打包工具：Turbopack。Turbopack 是针对 JavaScript 和 TypeScript 优化的增量打包工具，由 Webpack 的创建者 Tobias Koppers 和 Next.js 团队使用 Rust 编写。Turbopack 的推出吸引了众多开发者的关注，下面就来看看 Turbopack 都有哪些优势！\u003c/p\u003e\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg\u0026amp;rf=LaDigue_1920x1080.jpg\u0026amp;pid=hp\u0026amp;w=240\u0026amp;h=135\" alt=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg\u0026amp;rf=LaDigue_1920x1080.jpg\u0026amp;pid=hp\u0026amp;w=240\u0026amp;h=135\" data-href=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg\u0026amp;rf=LaDigue_1920x1080.jpg\u0026amp;pid=hp\u0026amp;w=240\u0026amp;h=135\" style=\"\"\u003e\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003eTurbopack 的速度有多快？\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 建立在新的增量架构上，以提供最快的开发体验。在大型应用上，它的更新速度比 Vite 快 10 倍，比Webpack 快 700 倍。在更大的应用上，通常会比 Vite 快 20 倍。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e由于 Turbopack 只打包开发所需的最少资源，因此启动时间非常快。在具有 3000 个模块的应用上，Turbopack 需要 1.8 秒即可启动，而 Vite 则需要 11.4 秒：\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003eTurbopack 为什么这么快？\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 性能的秘诀有两个：高度优化的机器代码和低层级增量计算引擎，可以缓存到单个函数的级别。它的架构吸取了 Turborepo 和 Google 的 Bazel 等工具的经验教训，它们都专注于使用缓存来避免重复执行相同的工作。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003eTurbo 引擎工作原理\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 之所以如此之快，是因为它建立在一个可重用的 Rust 库之上，该库支持增量计算，称为 Turbo 引擎。以下是它的工作原理。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e在 Turbopack 驱动的程序中，可以将某些函数标记为“to be remembered”。当这些函数被调用时，Turbo 引擎会记住它们被调用的内容，以及它们返回的内容。然后它将其保存在内存缓存中。下面是一个简化的示例：\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e我们首先在 api.ts​ 和 sdk.ts​ 这两个文件中调用 readFile。然后打包这些文件，将它们拼接在一起，最后得到 fullBundle。所有这些函数调用的结果都保存在缓存中以备后用。\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e由于 sdk.ts​ 的结果发生了变化，就需要再次打包，然后需要再次拼接。重要的是，api.ts​ 并没有改变。只需从缓存中读取它的结果并将其传递给 concat。因此，这样就通过不读取并重新打包来节省了时间。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eTurbo 引擎当前将其缓存存储在内存中。这意味着缓存将与运行它的进程一样长，这对于 Dev server 来说效果很好。将来，计划将这个缓存持久化——要么保存到文件系统中，要么保存到像 Turborepo 这样的远程缓存中。这意味着 Turbopack 可以记住跨运行和机器完成的工作。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这种方法使 Turbopack 在计算应用的增量更新方面非常快速，优化了 Turbopack 以处理开发中的更新，这意味着 Dev server 将始终快速响应更改。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003e按要求编译\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003eTurbo 引擎有助于在 Dev server 上提供极快的更新，但还有另一个重要指标需要考虑——启动时间。Dev server 开始运行的速度越快，开始工作的速度就越快。有两种方法可以使流程更快：工作更快或做工作更少。为了启动 Dev server，减少工作量的方法就是只编译启动所需的代码。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（1）页面级编译\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e2-3 年前的 Next.js 版本在显示 Dev server 之前会编译整个应用。从 Next.js 11 开始就只编译请求的页面上的代码。这样会更好，但并不完美。当导航到 /users 时，将打包所有客户端和服务端模块、动态导入的模块以及引用的 CSS 和图片。这意味着如果页面的很大一部分隐藏在视图之外，或者隐藏在选项卡后面，仍然会编译它。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（2）请求级编译\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 足够智能，可以只编译请求的代码。这意味着如果浏览器请求 HTML，就只会编译 HTML，而不会编译 HTML 引用的任何内容。如果浏览器需要 CSS，将只编译 CSS，而不编译其引用的图片，Turbopack 甚至知道不编译 source map，除非 Chrome DevTools 是打开的。通过请求级编译，减少了请求的数量，性能改进显着。\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003e为什么基于 Rust 开发？\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack是 基于 Rust 开发的，每当 Next.js 团队将基于 JavaScript 的工具转移到基于 Rust 的工具时，都会看到巨大的改进。Next.js 替换了 JavaScript 编译器 Babel，使编译速度提高达 17 倍，替换了 Terser，使压缩速度提高了 6 倍，同时还减少了加载时间和宽带使用。\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003e为什么选择 Turbopack？\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e创建 Turbopack 就是为了提高 Next.js 的速度，希望它能够取代 Webpack，成为下一代 Web 打包工具。那为什么不选择新一代打包工具 esbuild 和 swc，而是选择创建自己的打包工具呢？\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003e增量计算\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003e通常，有两种方法可以加快进程：减少工作量或并行工作。想要打造最快的打包工具，就要用力拉动这两个杠杆。因此决定为分布式和增量行为创建一个可重用的 Turbo 构建引擎。Turbo 引擎就像函数调用的调度程序一样工作，允许在所有可用内核上并行调用函数。Turbo 引擎还会缓存它调度的所有函数的结果，这意味着它永远不需要执行两次相同的工作。简而言之，它会以最大速度做最少的工作。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e其他工具对“做更少的工作”采取不同的方式。比如，Vite 通过在开发模式下使用原生 ESM 将工作量降至最低。在底层，Vite 将 esbuild 用于许多任务。esbuild 是一个非常快的打包器，它不会强迫我们使用原生 ESM。但出于几个原因，决定不采用 esbuild：\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eesbuild 的代码针对一项任务进行了超优化 - 快速打包，因此没有 HMR（热更新）；\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eesbuild 是一个非常快的打包工具，但它并没有做太多的缓存。这意味着会做很多重复的工作；\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e而具有增量计算的 Rust 驱动的打包器在更大的规模上可以比 esbuild 更好地执行。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003e惰性打包\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003eNext.js 的早期版本试图在开发模式下打包整个 Web 应用，这并不是最优的。Next.js 的现代版本仅打包 Dev server 请求的页面。例如，如果转到localhost:3000​，它将仅打包 pages/index.jsx，以及它导入的模块。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这种更“惰性”的方法是快速 Dev server 的关键。而 esbuild 没有“惰性”打包的概念——它是全有或全无的。Turbopack 的开发模式会根据收到的请求构建应用导入和导出的最小图，并且只打包必要的最少代码。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e此策略使 Turbopack 在首次启动 Dev server 时速度极快。只需计算渲染页面所需的代码，然后在单个块中将其发送到浏览器。在大规模应用中，这最终比原生 ESM 快得多。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e这就是构建 Turbopack 的原因。\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003eTurbopack 的功能\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e构建 Web 应用的实践非常多样化。仅在 CSS 中，就有 SCSS、Less、CSS Module、PostCSS等。React、Vue 和 Svelte 等框架需要自定义设置。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e在构建打包工具时，我们希望它能开箱即用，无需配置，可以通过插件获得一些功能。目前，Turbopack 仍处于 alpha 阶段，在当前状态下，Turbopack 还不能配置，所以插件也还不可用。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e下面来看一下 Turbopack 默认配置中哪些功能是开箱即用的以及未来将通过插件配置的功能：\u003c/p\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003eJavaScript：支持所有 ESNext 功能、Browserslist 和顶层 await；\u003c/li\u003e\u003cli\u003eTypeScript：开箱即用地支持 TypeScript，包括解析路径和baseUrl；\u003c/li\u003e\u003cli\u003eImports：支持 require、import、动态导入等；\u003c/li\u003e\u003cli\u003eDev Server：优化的 Dev Server 支持热更新 (HMR) 和快速刷新；\u003c/li\u003e\u003cli\u003eCSS：支持全局 CSS、CSS Module、postcss-nested 和 @import；\u003c/li\u003e\u003cli\u003e静态资源：支持 /public 目录、JSON 导入和通过 ESM 导入资源；\u003c/li\u003e\u003cli\u003e环境变量：通过 .env、.env.local 等支持环境变量。\u003c/li\u003e\u003c/ul\u003e\u003ch3 style=\"text-align: start;\"\u003eTurbopack vs Vite vs Webpack\u003c/h3\u003e\u003ch4 style=\"text-align: start;\"\u003eTurbopack vs Vite\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 在以下两个关键指标上的表现优于 Vite。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（1）Dev server 启动时间\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 的 Dev server 启动速度比 Vite 快得多。在 1000 个模块的应用中，Vite 需要 4.8 秒才能启动。Turbopack 启动仅需 0.9 秒，快了5.5倍。在大型应用中，这种差异将保持一致。在 30000 个模块的应用中， Turbopack 的启动速度比 Vite 快了 5.4 倍。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（2）代码更新\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e当文件更改时，它需要将更改呈现给浏览器。它做到的越快，反馈循环就越紧密，发布的速度就越快。在 1000 个模块的应用中，Turbopack 对文件更改的速度比 Vite 快 5.8 倍。\u003c/p\u003e\u003ch4 style=\"text-align: start;\"\u003eTurbopack vs Webpack\u003c/h4\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 的增量架构在以下两个关键指标上超过了 Webpack 的速度。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（1）Dev server 启动时间\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 的 Dev server 启动速度比 Webpack 快得多。Next.js 12 底层使用了 Webpack，可以在 3.4 秒内在 1000 个模块的应用上启动 build server。Turbopack 的启动速度快了 0.9 秒 - 3.9倍。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cstrong\u003e（2）代码更新\u003c/strong\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e在 Dev server 上执行的最常见操作就是更改文件。当文件更改时，它需要将更改呈现给浏览器。它做到的越快，反馈循环就越紧密，发布的速度就越快。在 1000 个模块的应用中，Turbopack 对文件更改的反应速度比 Webpack 快 8.9 倍：\u003c/p\u003e\u003ch3 style=\"text-align: start;\"\u003eTurbopack 的未来\u003c/h3\u003e\u003cp style=\"text-align: start;\"\u003e到目前为止，Turbopack 可以在 Next.js v13 中使用。未来将发布独立的 CLI、插件 API，并支持其他框架，如 Svelte 和 Vue。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eTurbopack 将用于 Next.js 13 Dev server。它将为闪电般快速的 HMR 提供动力，并将原生支持 React 服务端组件，以及 TypeScript、JSX、CSS 等。Webpack 用户还可以期待使用 Turbopack 进入基于 Rust 的未来的增量迁移路径。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e期待在 Webpack 的创建者 Tobias Koppers 的带领下，Turbopack 成为 Web 的下一代打包工具。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-28T09:17:10.000Z","art_tags":null},{"id":64,"art_title":"【技术】Vite的原理介绍及应用","art_content":"\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003e背景\u003c/h2\u003e\u003cblockquote\u003e在当今Webpack横行的时代，Webpack的影响力不可谓之不大。对于一个主流Web项目的开发而言，大多数时候我们都会采用现有的脚手架作为项目开发，打包工具如：Vue-cli、create-react-app，而他们都基于Webpack。但是，在不断的使用和日常项目的迭代中，我们慢慢会走入一个窘境，就会出现我们稍微改动一行代码我们就需要等待十几秒甚至是数十秒的情况，这对于我们日益增长的业务开发来说是十分不友好的。 深入Webpack打包原理我们可以清晰的知道他的编译过程是静态的，也就是说他会把所有可能用到的代码全部进行打包构建，会借助胶水代码用来组装各模块，这样打包出来的代码是十分庞大的，很多时候其实我们在开发过程中并不需要全部代码的功能，而是一小部分，这个时候大量的构建时间都是多余的，我们需要一个能够真正意义上实现懒加载的开发工具。\u003c/blockquote\u003e\u003ch2\u003eVite是什么？\u003c/h2\u003e\u003ch3\u003e定义\u003c/h3\u003e\u003cblockquote\u003eVite（轻量，轻快）vite是一个基于vue3单文件组件的非打包开发服务器。它做到了本地快速开发启动，实现按需编译，不再等待整个应用编译完成。 面向现代化浏览器，基于原生模块系统 ES moudle 的开发服务器，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。 浏览器端使用 export、import 的方式导入和导出模块，在 script 标签里设置 type=\"module\"，浏览器会识别所有添加了type='module'的script标签，对于该标签中的import关键字，浏览器会发起http请求获取模块内容。\u003c/blockquote\u003e\u003cblockquote\u003e它主要具有以下特点： 快速的冷启动 即时的模块热更新 真正的按需编译\u003c/blockquote\u003e\u003ch3\u003e基本架构\u003c/h3\u003e\u003cp\u003e启动项目时，则是启动一个koa服务器，服务器拦截浏览器的es module的请求，服务器直接将 ESM 模块内容处理后，通过 path 找到目录下对应的文件做一定的处理最终以 ES Modules 格式返回给客户端。接着，现代浏览器通过解析 script module，对每一个 import 到的模块进行 HTTP 请求，服务器继续对这些 HTTP 请求进行处理并响应。（热更新）\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e图中的目标项目即我们开发时的项目，vite服务在解析模块路径以及读取文件内容时需要访问目标项目中的模块内容或者配置文件等。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2\u003eVite的原理介绍\u003c/h2\u003e\u003cul\u003e\u003cli\u003e使用vite后项目分析\u003c/li\u003e\u003cli\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-  language-jsx\"\u003e它的核心在于使用了es的语法，我们可以看到index.html文件，和以前不一样的地方在于，它使用了:\n  \u0026lt;script type=\"module\" src=\"/src/main.js\"\u0026gt;\u0026lt;/script\u0026gt;\n// 这样引入的话就表示它是一个模块，那这个script里面就可以使用import\n//默认引入的是src下的main.js\n\n\n\n\n\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-969c945a7160f9f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/909/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\nimage.png\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从其他请求中我们也可以看出每一个.vue文件都被拆分成了多个请求，并通过type来标识是template还是style。\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-5b47c8ada339e630.png?imageMogr2/auto-orient/strip|imageView2/2/w/904/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003eimage.png\u003c/p\u003e\u003cul\u003e\u003cli\u003e结论\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003evite在这里做了两件事，第一是修改了模块请求路径，第二就是将.vue文件进行解析拆分。（只是本文会进行详细讲解的有关于Vite实现的部分，而不是说Vite只干了这两件事 Vite的功能还是十分强大的）\u003c/blockquote\u003e\u003ch2\u003e深入源码讲原理\u003c/h2\u003e\u003ch4\u003e1、创建自己的vite工具 my-vite\u003c/h4\u003e\u003cblockquote\u003e项目目录概述： my-vite -bin 。www.js -node_modules -plugins -index.js -package.json\u003c/blockquote\u003e\u003cp\u003e在项目根目录创建bin目录，并在bin目录下创建一个\u003ca href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.js\" target=\"_blank\"\u003ewww.js\u003c/a\u003e文件，文件内容如下：\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-  language-jsx\"\u003e! /usr/bin/env node\n// 执行的入口\nrequire('../index');\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e2、创建服务\u003c/h4\u003e\u003cp\u003e在创建\u003ca href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.js\" target=\"_blank\"\u003ewww.js\u003c/a\u003e文件中引入了index.js文件，主要是使用了koa启动了一个简单服务以及实现vite的功能\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-  language-tsx\"\u003econst Koa = require('koa')\nconst { moduleRewritePlugin } = require('./plugins/serverPluginModuleRewrite')\nconst serveStaticPlugin = require('./plugins/serverPluginServeStatic')\nconst { moduleResolvePlugin } = require('./plugins/serverPluginModuleResolve')\nconst { vuePlugin } = require('./plugins/serverPluginVue')\n\nfunction createServer() {\n    let app = new Koa();\n    const context = { //直接创建一个上下文，来给不同的插件共享功能\n        app,\n        root: process.cwd()     \n     }\n    const resolvePlugin = [\n        moduleRewritePlugin, //2.重写我们的请求路径, 重写后浏览器会再次发送请求\n        moduleResolvePlugin,//解析模块路径,服务端来解析模块真实位置\n        vuePlugin, // 解析.vue文件\n        serveStaticPlugin //1.静态服务插件,处理所需要处理的静态文件    \n    ]\n    resolvePlugin.forEach(plugin =\u0026gt; plugin(context))\n    return app;\n}\ncreateServer().listen(4000, () =\u0026gt; {\n    console.log('vite start 4000')\n})\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e3、静态服务插件\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003eserverPluginServeStatic.js文件\u003c/strong\u003e:使用koa-static中间件来托管静态资源，同时我们需要拿到koa实例（app），其次需要获取到目标项目的根目录路径（root），将目标项目进行整体托管，同时对于目标项目的 public目录也进行托管，这样，我们需要处理的静态文件基本完成了。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-  language-jsx\"\u003econst static = require('koa-static')\nconst path = require('path')\n\nfunction serveStaticPlugin({ app, root }) {\n\n    app.use(static(root)) // root指的是根目录 访问根目录下的index.html\n    app.use(static(path.resolve(root, 'public'))) //可以直接http://localhost:4000/文件名，访问public下的文件,比如public文件下有aa.txt,则直接访问http://localhost:4000/aa.txt\n}\n\nmodule.exports = serveStaticPlugin\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e4、重写模块路径插件\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e为什么要重写模块路径呢？\u003c/strong\u003e\u003cbr\u003e\u003cbr\u003e这是因为我们在使用import方式导入模块的时候，浏览器只能识别./、../、/这种开头的路径，对于直接使用模块名比如：import vue from 'vue'，浏览器就会报错，因为它无法识别这种路径，这就是我们需要进行处理的地方了。\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-cff68afc3687df15.png?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003eimage.png\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eserverPluginModuleRewrite.js文件：\u003c/strong\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-b8f5c37f492f3653.png?imageMogr2/auto-orient/strip|imageView2/2/w/1125/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003eimage.png\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-3ff52d2268e84a58.png?imageMogr2/auto-orient/strip|imageView2/2/w/807/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003eimage.png\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4\u003e5、解析模块路径插件\u003c/h4\u003e\u003cp\u003e在处理完所有的模块路径之后，我们就需要在服务端来解析模块真实位置。\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-  language-jsx\"\u003econst reg = /^\\/@modules\\//\nconst fs = require('fs').promises\nconst path = require('path')\n \nfunction moduleResolvePlugin({ app, root }) {\n    app.use(async(ctx, next) =\u0026gt; {\n        // 如果没有匹配到 /@modules就往下执行即可\n        if (!reg.test(ctx.path)) {\n            return next();\n        }\n        const id = ctx.path.replace(reg, '');\n        //console.log(\"id--\u0026gt;\", id)  //vue\n        let mapping = {\n                vue: path.resolve(root, 'node_modules', '@vue/runtime-dom/dist/runtime-dom.esm-browser.js')\n            }\n            //如果是第三方模块，则可以根据package.json进行查找\n        const content = await fs.readFile(mapping[id], 'utf8')\n        ctx.type = 'js' //返回的文件为js\n        ctx.body = content\n    })\n}\n\nexports.moduleResolvePlugin =  moduleResolvePlugin\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e6、解析.vue文件\u003c/h4\u003e\u003cp\u003e当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template , css ,script 模块三个模块进行分别处理。最后会对 script ,template, css 发送多个请求获取。\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"//upload-images.jianshu.io/upload_images/8496278-3ed884d6ce6c3225.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cp\u003eimage.png\u003c/p\u003e\u003ch4\u003e7、总结\u003c/h4\u003e\u003cblockquote\u003e在 koa 中间件里获取请求 body 通过 es-module-lexer 解析资源 ast 拿到 import 的内容 判断 import 的资源是否是 npm 模块 返回处理后的资源路径：\"vue\" =\u0026gt; \"/@modules/vue\" 将处理的template,script,style等所需的依赖以http请求的形式，通过query参数形式区分并加载SFC文件各个模块内容。\u003c/blockquote\u003e\u003ch2\u003eWebpack \u0026 Vite 对比\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cbr\u003e\u003cbr\u003e\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e1.当我们对比使用 vue-cli-service serve 的时候，会有明显感觉。因为 Webpack Dev Server 在启动时，需要先 build—遍，而 build 的过程是需要耗费很多时间的。 2.而 Vite 则完全不同，当我们执行 Vite serve 时（npm run dev），内部直接启动了 Web Server，并不会先编译所有的代码文件。那仅仅是启动 Web Server，那么及时请求的编译呢？关于支持 JSX， TSX，Typescript 编译到原生 JS —— Vite 引入了EsBuild，是使用 Go 写的，直接编译为 Native 代码，性能要比 TSC 好二三十倍， 当然也会用上缓存。\u003c/blockquote\u003e\u003cul\u003e\u003cli\u003e即时的热模块更新\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e1.热更新的时候，Vite 只需要立即编译当前所修改的文件即可，所以 响应速度非常快。 2.而 Webpack 修改某个文件过后，会自动以这个文件为入口重写 build—次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。\u003c/blockquote\u003e\u003cul\u003e\u003cli\u003e真正的按需编译\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e1.Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。 2.Vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。也就是说，只有具体去请求某个文件时才会编译这个文件。所以，这种「即时编译」的好处主要体现在：按需编译。\u003cbr\u003e\u003c/blockquote\u003e\u003cp\u003e作者：江南之城\u003cbr\u003e链接：https://www.jianshu.com/p/0d00a49adb20\u003cbr\u003e来源：简书\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-26T07:31:34.000Z","art_tags":null},{"id":63,"art_title":"【笔记】JavaScript阻止屏幕进入睡眠状态","art_content":"\u003cp style=\"text-align: start;\"\u003e使用 JavaScript 阻止屏幕进入睡眠状态。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e最近在 H5 端有需要保持手机屏幕常亮的需求，辗转之下，发现了一个早在 chrome 85 中就已经支持的 Web API，不过，截止到今天发文时，Safari 仍不支持，尽管如此，在安卓端我们还是能调用这个 API 来节省设备电池电量（相对于 NoSleep.js 来说），ios 端使用 polyfill 的方式，在将来 Safari 支持该 API 后移除即可。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eWake Lock 可防止屏幕关闭、变暗或锁定，仅适用于活动的选项卡/窗口，这可以防止后台选项卡使您的设备保持唤醒状态，也提供了函数以随时通过代码手动释放。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e调用 Wake Lock 之前，我们首先需要检查当前浏览器中是否存在该功能。我们可以使用以下简单函数来做到这一点。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst canWakeLock = () =\u0026gt; 'wakeLock' in navigator;\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003e请求唤醒锁\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e下面的示例演示如何请求 WakeLockSentinel 对象。\u003cspan style=\"color: rgb(248, 35, 117); background-color: rgb(248, 248, 248);\"\u003e\u003ccode\u003eWakeLock.request\u003c/code\u003e\u003c/span\u003e 方法是基于 Promise 的，因此我们可以创建一个异步函数。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elet wakeLock = null;const requestWakeLock = async ()=\u0026gt;{\n    try {\n        wakeLock = await navigator.wakeLock.request('screen');\n        console.log('Wake Lock is active!');\n    } catch (err) {\n        console.log(`${err.name}, ${err.message}`);\n    }\n\n}\n\nrequestWakeLock()\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003e释放唤醒锁\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e下面的示例演示如何释放以前获取的唤醒锁。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ewakeLock.release().then(() =\u0026gt; wakeLock = null);\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003e侦听唤醒锁释放\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e如因任何原因（例如离开活动窗口/选项卡）而释放唤醒锁，将出触发 release 监听函数。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e复制wakeLock.addEventListener('release', () =\u0026gt; {\n    console.log('Wake Lock has been released');\n});\u003c/code\u003e\u003c/pre\u003e\u003ch2 style=\"text-align: start;\"\u003e重新获取唤醒锁\u003c/h2\u003e\u003cp style=\"text-align: start;\"\u003e以下代码在文档的可见性发生更改并释放唤醒锁时重新获取唤醒锁。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e复制document.addEventListener('visibilitychange', async () =\u0026gt; {\n    if (wakeLock !== null \u0026\u0026 document.visibilityState === 'visible') {\n        requestWakeLock()\n    }\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-21T03:24:47.000Z","art_tags":null},{"id":62,"art_title":"【图片】发现一张邓紫棋照片🖼","art_content":"\u003cp\u003e\u003cimg src=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" alt=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" data-href=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-20T05:38:08.000Z","art_tags":null},{"id":61,"art_title":"【CSS】Chrome如何支持小于12px 的文字 🎃","art_content":"\u003cp style=\"text-align: start;\"\u003e\u003cbr\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e方案一：使用zoom\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli\u003ezoom 可以改变页面上元素的尺寸，属于真实尺寸。\u003c/li\u003e\u003cli\u003ezoom:50%，表示缩小到原来的一半\u003c/li\u003e\u003cli\u003ezoom:0.5，表示缩小到原来的一半\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre style=\"text-align: left;\"\u003e\u003ccode\u003e.span10{\n    font-size: 12px;\n    display: inline-block;\n    zoom: 0.8;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e方法二： transform:scale(0.8)\u003c/p\u003e\u003cpre style=\"text-align: left;\"\u003e\u003ccode\u003e.span10{\n    font-size: 12px;\n    display: inline-block;\n    transform:scale(0.8);\n}\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: center;\"\u003e\u003cimg src=\"http://img.poooster.com/poooster/2022/10/illuminator_POSTER_01.jpg\" alt=\"钻石\" data-href=\"http://img.poooster.com/poooster/2022/10/illuminator_POSTER_01.jpg\" style=\"width: 50%;\"\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-20T03:48:05.000Z","art_tags":null},{"id":60,"art_title":"【HTML】HTML5 drag API 🎈","art_content":"\u003cul style=\"text-align: start;\"\u003e\u003cli\u003edragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。\u003c/li\u003e\u003cli\u003edarg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。\u003c/li\u003e\u003cli\u003edragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。\u003c/li\u003e\u003cli\u003edragover：事件主体是目标元素，在被拖放在某元素内移动时触发。\u003c/li\u003e\u003cli\u003edragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。\u003c/li\u003e\u003cli\u003edrop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\u003c/li\u003e\u003cli\u003edragend：事件主体是被拖放元素，在整个拖放操作结束时触发。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-20T03:42:46.000Z","art_tags":null},{"id":59,"art_title":"钻石💎","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=illuminator_POSTER_02-1666158145550.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-19T05:43:09.000Z","art_tags":null},{"id":58,"art_title":"钱钱刚刚在叫","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=35d92b9406f3a90b65fe0035725885b6-1666106223817.jpeg\" alt=\"\" data-href=\"\" style=\"width: 129.00px;height: 129.00px;\"/\u003e 表情包 😊 ❤️🏋️‍♂️🥌\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-18T15:18:51.000Z","art_tags":null},{"id":57,"art_title":"【测试】标题表情包测试🧛‍♀️🧛‍♂️🧜‍♀️🧜‍♂️","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221014151720-1666074535913.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-18T06:28:58.000Z","art_tags":null},{"id":56,"art_title":"【测试】表情包测试","art_content":"\u003cp\u003e👧👦🧒👶👵\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-18T06:26:33.000Z","art_tags":null},{"id":55,"art_title":"【记录一下】梦  2022/10/18","art_content":"\u003cp\u003e梦到乔丹从一个少年成为篮球巨星的故事，乔丹，生于单亲妈妈家庭，是一个白人，没错是白人，由妈妈带大，篮球目标也是妈妈为他选好的，参加选秀的时候，一枝独秀；出名后故意晒黑（也可能是纹身）让自己成为黑皮肤，报复母亲；\u003c/p\u003e\u003cp\u003e衔接上个梦境，成为超人，一群人来挑事，往我电脑安装监控器，被发现后还态度强硬，后被我暴揍，将他们最厉害两个人按地上暴捶；\u003c/p\u003e\u003cp\u003e醒\u003c/p\u003e\u003cp\u003e莫名其妙 \u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-18T06:06:53.000Z","art_tags":null},{"id":54,"art_title":"和人可人去人咬人不人马人","art_content":"\u003cp\u003e和人可人去人咬人不人马人\u003c/p\u003e\u003cp\u003e和人可人去人咬人不人马人\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-10-10T08:42:18.000Z","art_tags":null},{"id":53,"art_title":"后期优化点","art_content":"\u003col\u003e\u003cli\u003e首页加载数据限制，下拉刷新\u003c/li\u003e\u003cli\u003e视频功能加上？（痛点：服务器存储不够）\u003c/li\u003e\u003cli\u003e资源整理\u003c/li\u003e\u003cli\u003e服务器数据区emoji字符集还未更新！\u003c/li\u003e\u003cli\u003e手机访问适配，媒体查询\u003c/li\u003e\u003cli\u003e其他板块探索\u003c/li\u003e\u003c/ol\u003e","art_author":"yellow star","art_createtime":"2022-10-10T08:34:06.000Z","art_tags":null},{"id":51,"art_title":"发布图片测试-问题","art_content":"\u003cp\u003e\u003cimg src=\"http://124.223.185.220:3000/getImage?img=HYDRA-1665389786925.jpg\" alt=\"\" data-href=\"\" style=\"\"/\u003e\u003c/p\u003e\u003cblockquote\u003e \u0026nbsp; 问题：使用PM2管理项目，上传图片会失败，终端npm start启动项目成功上传图片！\u003c/blockquote\u003e","art_author":"yellow star","art_createtime":"2022-10-10T08:18:13.000Z","art_tags":null},{"id":47,"art_title":"ERROR 1064 (42000): You have an error in your SQL syntax; Want to configure a password as root being the user","art_content":"\u003cp style=\"text-align: left;\"\u003eI was using MySQL 8 and non of the above worked for me.\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eThis is what I had to do:\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e# ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password';\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003e\u003ccode\u003eThis worked for me on: mysql ver 8.0.16 for osx10.14 on x86_64 (Homebrew). Update query resulted in syntax error.\u003c/code\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003e \u003c/span\u003e– \u003ca href=\"https://stackoverflow.com/users/2010877/nishant-ghodke\" target=\"\"\u003eNishant Ghodke\u003c/a\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003e \u003c/span\u003e\u003cspan style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003eJul 14, 2019 at 12:42\u003cbr\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003eYup... only this works on: mysql ver 8.0.16 for mac installed with homebrew \u003c/span\u003e– \u003ca href=\"https://stackoverflow.com/users/1364747/teddy\" target=\"\"\u003eTeddy\u003c/a\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003e \u003c/span\u003e\u003cspan style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003eJul 16, 2019 at 9:25\u003cbr\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003eThis was the only thing that worked for me been googling forever!! \u003c/span\u003e– \u003ca href=\"https://stackoverflow.com/users/4245513/sam-johnson\" target=\"\"\u003eSam Johnson\u003c/a\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003e \u003c/span\u003e\u003cspan style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\"\u003eJan 7, 2020 at 22:37\u003c/span\u003e\u003c/blockquote\u003e\u003cp style=\"text-align: left;\"\u003eOn MySQL 8.0.15 (maybe earlier than this too) the \u003cspan style=\"color: var(--black-800); background-color: var(--black-075);\"\u003e\u003ccode\u003ePASSWORD()\u003c/code\u003e\u003c/span\u003e function does not work anymore, so you have to do:\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eMake sure you have stopped MySQL first (Go to: 'System Preferences' \u0026gt;\u0026gt; 'MySQL' and stop MySQL).\u003c/p\u003e\u003cp style=\"text-align: left;\"\u003eRun the server in safe mode with privilege bypass:\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003esudo mysqld_safe --skip-grant-tables\r\nmysql -u root\r\nUPDATE mysql.user SET authentication_string=null WHERE User='root';\r\nFLUSH PRIVILEGES;\r\nexit;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 15px;\"\u003eThen\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003emysql -u root\r\nALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'yourpasswd';\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: left;\"\u003eFinally, start MySQL again.\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-09-14T01:11:10.000Z","art_tags":null},{"id":46,"art_title":"今日0914","art_content":"\u003cp\u003e\u003cspan style=\"color: rgb(8, 151, 156);\"\u003e昨日俩鸡 over\u003c/span\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-09-14T01:07:04.000Z","art_tags":null},{"id":19,"art_title":"SSG","art_content":"\u003ch3 style=\"text-align: start;\"\u003eSSG\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003eSSG(Static Site Generation) 是指在应用编译构建时预先渲染页面，并生成静态的 HTML。把生成的 HTML 静态资源部署到服务器后，浏览器不仅首次能请求到带页面内容的 HTML ，而且不需要服务器实时渲染和响应，大大节约了服务器运维成本和资源。\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003eNext.js 默认为每个页面开启 SSG。对于页面内容需要依赖静态数据的场景，允许在每个页面中 \u003c/span\u003eexport\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 一个 \u003c/span\u003egetStaticProps\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 异步函数，在这个函数中可以把该页面组件所需要的数据收集并返回。当 \u003c/span\u003egetStaticProps\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 函数执行完成后，页面组件就能在 \u003c/span\u003eprops\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 中拿到这些数据并执行静态渲染。举个在静态路由中使用 SSG 的例子：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// pages/posts/first-post.js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return \u0026lt;div\u0026gt;{postData.title}\u0026lt;/div\u0026gt;\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  // 模拟获取静态数据\r\n  const postData = await getPostData();\r\n  return {\r\n    props: { postData }\r\n  }\r\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e对于动态路由的场景，Next.js 是如何做 SSG 的呢？Next.js 提供 \u003c/span\u003egetStaticPaths\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 异步函数，在这个方法中，会返回一个 \u003c/span\u003epaths\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 数组，这个数组包含了这个动态路由在构建时需要预渲染的页面数据。举个例子：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return \u0026lt;div\u0026gt;{postData.title}\u0026lt;/div\u0026gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  // 返回该动态路由可能会渲染的页面数据，比如 params.id\r\n  const paths = [\r\n    {\r\n      params: { id: 'ssg-ssr' }\r\n    },\r\n    {\r\n      params: { id: 'pre-rendering' }\r\n    }\r\n  ]\r\n  return {\r\n    paths,\r\n    // 命中尚未生成静态页面的路由直接返回 404 页面\r\n    fallback: false\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    }\r\n  }\r\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e当我们执行 \u003c/span\u003enextjs build\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 后，可以看到打包结果包含 \u003c/span\u003epre-rendering.html\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 和 \u003c/span\u003essg-ssr.html\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 两个 HTML 页面，也就是说在执行 SSG 时，会对 \u003c/span\u003egetStaticPaths\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 函数返回的 \u003c/span\u003epaths\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 数组进行循环，逐一预渲染页面组件并生成 HTML。\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003e├── server\r\n|  ├── chunks\r\n|  ├── pages\r\n|  |  ├── api\r\n|  |  ├── index.html\r\n|  |  ├── index.js\r\n|  |  ├── index.json\r\n|  |  └── posts\r\n|  |     ├── [id].js\r\n|  |     ├── first-post.html\r\n|  |     ├── first-post.js\r\n|  |     ├── pre-rendering.html       # 预渲染生成 pre-rendering 页面\r\n|  |     ├── pre-rendering.json\r\n|  |     ├── ssg-ssr.html             # 预渲染生成 ssg-ssr 页面\r\n|  |     └── ssg-ssr.json\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003eSSG 虽然很好解决了白屏时间过长和 SEO 不友好的问题，但是它仅仅适合于页面内容较为静态的场景，比如官网、博客等。面对\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e\u003cstrong\u003e页面数据更新频繁\u003c/strong\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e或\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e\u003cstrong\u003e页面数量很多\u003c/strong\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e的情况，它似乎显得有点束手无策，毕竟在静态构建时不能拿到最新的数据和无法枚举海量页面。这时，就需要增量静态再生成(Incremental Static Regeneration)方案了。\u003c/span\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-24T01:38:08.000Z","art_tags":null},{"id":18,"art_title":"2022/08/24 09:06","art_content":"\u003ch3 style=\"text-align: start;\"\u003eISR\u003c/h3\u003e\u003cp\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003eNext.js 推出的 ISR(Incremental Static Regeneration) 方案，允许在\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e\u003cstrong\u003e应用运行时再重新生成每个页面 HTML，而不需要重新构建整个应用\u003c/strong\u003e\u003c/span\u003e\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e。这样即使有海量页面，也能使用上 SSG 的特性。一般来说，使用 ISR 需要 \u003c/span\u003egetStaticPaths\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 和 \u003c/span\u003egetStaticProps\u003cspan style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"\u003e 同时配合使用。举个例子：\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return \u0026lt;div\u0026gt;{postData.title}\u0026lt;/div\u0026gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  const paths = await fetch('https://.../posts');\r\n  return {\r\n    paths,\r\n    // 页面请求的降级策略，这里是指不降级，等待页面生成后再返回，类似于 SSR\r\n    fallback: 'blocking'\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    },\r\n    // 开启 ISR，最多每10s重新生成一次页面\r\n    revalidate: 10,\r\n  }\r\n}\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e在应用编译构建阶段，会生成已经确定的静态页面，和上面 SSG 执行流程一致。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e在 \u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/span\u003e 函数返回的对象中增加 \u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003erevalidate\u003c/code\u003e\u003c/span\u003e 属性，表示开启 ISR。在上面的例子中，指定 \u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003erevalidate = 10\u003c/code\u003e\u003c/span\u003e，表示最多10秒内重新生成一次静态 HTML。当浏览器请求已在构建时渲染生成的页面时，首先返回的是缓存的 HTML，10s 后页面开始重新渲染，页面成功生成后，更新缓存，浏览器再次请求页面时就能拿到最新渲染的页面内容了。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e对于浏览器请求构建时未生成的页面时，会马上生成静态 HTML。在这个过程中，\u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003egetStaticPaths\u003c/code\u003e\u003c/span\u003e 返回的 \u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003efallback\u003c/code\u003e\u003c/span\u003e 字段有以下的选项：\u003c/p\u003e\u003cul style=\"text-align: start;\"\u003e\u003cli\u003e\u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003efallback: 'blocking'\u003c/code\u003e\u003c/span\u003e：不降级，并且要求用户请求一直等到新页面静态生成结束，静态页面生成结束后会缓存\u003c/li\u003e\u003cli\u003e\u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003efallback: true\u003c/code\u003e\u003c/span\u003e：降级，先返回降级页面，当静态页面生成结束后，会返回一个 JSON 供降级页面 CSR 使用，经过二次渲染后，完整页面出来了\u003c/li\u003e\u003c/ul\u003e\u003cp style=\"text-align: start;\"\u003e在上面的例子中，使用的是不降级方案(\u003cspan style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"\u003e\u003ccode\u003efallback: 'blocking'\u003c/code\u003e\u003c/span\u003e)，实际上和 SSR 方案有相似之处，都是阻塞渲染，只不过多了缓存而已。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003eIf fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path.\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e也不是所有场景都适合使用 ISR。对于实时性要求较高的场景，比如新闻资讯类的网站，可能 SSR 才是最好的选择。\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-24T01:07:51.000Z","art_tags":null},{"id":17,"art_title":"2022/08/23 17:06","art_content":"\u003cp\u003e今天成功打包了一个nextJs项目\u003c/p\u003e\u003cp\u003e问题：\u003c/p\u003e\u003cp\u003enpm run build后终端报错打包失败：panicked at 'The global thread pool has not been initialized.\u003c/p\u003e\u003cp\u003e解决：\u003c/p\u003e\u003cp\u003e问题看不懂来源，我直接把 node_modules文件夹整个删掉；\u003c/p\u003e\u003cp\u003e再 npm install 下回来，\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpm install\r\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"\u003e依赖下完后继续打包\u003c/span\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode \u003enpm run build\r\u003c/code\u003e\u003c/pre\u003e\u003cp style=\"text-align: start;\"\u003e打包成功，成功解决。\u003c/p\u003e\u003cp style=\"text-align: start;\"\u003e笑死~\u003cbr\u003e问题来的触不及防，走的也悄无声息。\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-23T09:09:06.000Z","art_tags":null},{"id":16,"art_title":"华华美女","art_content":"\u003ch2\u003e最好看的华华\u003c/h2\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elog('仙女华华')\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-23T02:22:25.000Z","art_tags":null},{"id":14,"art_title":"20220822/17:01","art_content":"\u003cp\u003e富文本内容只读操作\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React, { useEffect, useState } from 'react'\r\nimport Head from 'next/head'\r\nimport Image from 'next/image'\r\nimport styles from '../../styles/artcontent.module.css'\r\nimport axios from 'axios'\r\nimport { useRouter } from 'next/router'\r\nimport '@wangeditor/editor/dist/css/style.css'\r\nimport dynamic from 'next/dynamic';\r\n\r\nexport async function getStaticPaths() {\r\n    const res = await fetch('http://192.168.70.98:3030/api/msq/test')\r\n    const arts = await res.json()\r\n   const narts= arts.data.map(item=\u0026gt;{\r\n       return {\r\n        params:{aid:item.id+''}\r\n       }\r\n    })\r\n    // console.log('arts',narts);\r\n    return {\r\n      paths: narts,\r\n    //   paths: [{ params: { aid: '1' } }, { params: { aid: '2' }}],\r\n      fallback: false, // can also be true or 'blocking'\r\n    }\r\n  }\r\nexport async function getStaticProps(context) {\r\n   \r\n  // Call an external API endpoint to get posts.\r\n  // You can use any data fetching library\r\n  const res = await fetch('http://192.168.70.98:3030/api/msq/search?id='+context.params.aid)\r\n  const detail = await res.json()\r\n    console.log(detail);\r\n//   // By returning { props: { posts } }, the Blog component\r\n//   // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      datas:detail.data,\r\n    },\r\n  }\r\n}\r\n\r\nconst DisplayPanels = dynamic(import(\"../../components/DisplayPanels\"), {\r\n    ssr: false,\r\n    loading: () =\u0026gt; \u0026lt;p\u0026gt;Loading ...\u0026lt;/p\u0026gt;,\r\n  });\r\n\r\n\r\nexport default function Artcontent(props) {\r\n  const router = useRouter()\r\n  const { aid } = router.query\r\n  const {datas={}}=props\r\n  useEffect(()=\u0026gt;{\r\n    \r\n  },[])\r\n\r\n  return (\r\n    \u0026lt;div className={styles.container}\u0026gt;\r\n      \u0026lt;Head\u0026gt;\r\n        \u0026lt;title\u0026gt;yellow star blog\u0026lt;/title\u0026gt;\r\n        \u0026lt;meta name=\"description\" content=\"yellow star blog\" /\u0026gt;\r\n        \u0026lt;link rel=\"icon\" href=\"/CarStation.svg\" /\u0026gt;\r\n      \u0026lt;/Head\u0026gt;\r\n\r\n      \u0026lt;main className={styles.main}\u0026gt;\r\n        \u0026lt;h1\u0026gt;{datas.art_title}\u0026lt;/h1\u0026gt;\r\n        \u0026lt;DisplayPanels\r\n            EditorCfg={{\r\n                defaultConfig:{\r\n                    placeholder: '无内容',\r\n                    readOnly:true\r\n                  },\r\n                value:datas.art_content,\r\n                // onCreated:setEditor,\r\n                // onChange:editor =\u0026gt; setHtml(editor.getHtml()),\r\n                mode:'default',\r\n                style:{ height: '500px', 'overflowY': 'hidden' },\r\n                readOnly:true\r\n              }}\r\n        \u0026gt;\u0026lt;/DisplayPanels\u0026gt;\r\n      \u0026lt;/main\u0026gt;\r\n\r\n      \u0026lt;footer className={styles.footer}\u0026gt;\r\n        \u0026lt;a\r\n          href=\"https://vercel.com?utm_source=create-next-app\u0026utm_medium=default-template\u0026utm_campaign=create-next-app\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        \u0026gt;\r\n          Powered by{' '}\r\n          \u0026lt;span className={styles.logo}\u0026gt;\r\n            \u0026lt;Image src=\"/vercel.svg\" alt=\"Vercel Logo\" width={72} height={16} /\u0026gt;\r\n          \u0026lt;/span\u0026gt;\r\n        \u0026lt;/a\u0026gt;\r\n      \u0026lt;/footer\u0026gt;\r\n    \u0026lt;/div\u0026gt;\r\n  )\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-22T09:03:28.000Z","art_tags":null},{"id":13,"art_title":"20220822","art_content":"\u003cp\u003e今天周一，天气晴，做了核酸！\u003c/p\u003e","art_author":"yellow star","art_createtime":"2022-08-22T07:51:51.000Z","art_tags":null}]},"__N_SSG":true},"page":"/","query":{},"buildId":"kRrtnNUirzJtMh_xDWC5r","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>