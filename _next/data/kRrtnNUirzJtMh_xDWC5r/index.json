{"pageProps":{"datas":[{"id":116,"art_title":"windows 使用 Git Bash 上下箭头不生效的解决方案","art_content":"<h1 style=\"text-align: start;\">使用数字代替</h1><blockquote><span style=\"color: rgb(85, 86, 102); background-color: rgb(238, 240, 244); font-size: 16px;\">windows 中的使用上下键不生效的情况下，可以用数字代替进行选择</span></blockquote><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1671785228784.png\" alt=\"\" data-href=\"\" style=\"\"/></p><h1 style=\"text-align: start;\">使用 winpty</h1><p style=\"text-align: start;\">这里以 <span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 14px;\"><code>vue create</code></span> 创建项目为例：<br>将</p><pre style=\"text-align: start;\"><code class=\"language-bash\">vue create hello-world</code></pre><p style=\"text-align: start;\">改为：</p><pre style=\"text-align: start;\"><code class=\"language-prism language-bash has-numbering\">winpty vue.cmd create hello-world</code></pre><p style=\"text-align: start;\"><span style=\"color: red; font-size: 19px;\">这个时候出现的命令行，将可以使用上下箭头的功能了。</span></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-23T08:48:17.000Z","art_tags":4},{"id":115,"art_title":"bing搜索提交url接口，实现自动化提交","art_content":"<p style=\"line-height: 1.5;\">收录网址 <a href=\"https://www.bing.com/webmasters/submiturl\" target=\"_blank\">https://www.bing.com/webmasters/submiturl</a> </p><p style=\"line-height: 1.5;\">接口文档 <a href=\"https://www.bing.com/webmasters/url-submission-api#APIs\" target=\"_blank\">https://www.bing.com/webmasters/url-submission-api#APIs</a> </p><p style=\"line-height: 1.5;\">apikey获取 &nbsp;<a href=\"https://learn.microsoft.com/en-us/bingwebmaster/getting-access?source=recommendations#using-api-key\" target=\"_blank\">https://learn.microsoft.com/en-us/bingwebmaster/getting-access?source=recommendations#using-api-key</a> </p><p style=\"line-height: 1.5;\"><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;\"> </span><img src=\"http://124.223.185.220:3000/getImage?img=image-1671782199531.png\" alt=\"\" data-href=\"\" style=\"\"><span style=\"color: transparent;\"> </span><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 14px;\"> </span></p>","art_author":"yellow star","art_createtime":"2022-12-23T08:04:57.000Z","art_tags":4},{"id":114,"art_title":"nextjs跨域问题解决","art_content":"<p>找到根目录下的 next.config.js 文件</p><p>废话不多说，直接上代码</p><pre><code class=\"language-javascript\">/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  swcMinify: true,\r\n  rewrites:async ()=&gt;{\r\n    return [{\r\n      source: '/webmaster/api.svc/json/:slug*',\r\n      destination: `https://www.bing.com/webmaster/api.svc/json/:slug*`,\r\n    },]\r\n  }\r\n}\r\n\r\nmodule.exports = nextConfig\r\n</code></pre><blockquote>source &nbsp; &nbsp;匹配字段，请求路径匹配到该字段将代理到destination字段的接口地址<br>:slug* &nbsp; &nbsp; &nbsp;为不同接口的不同路径，可视为一个变量，接收匹配字段的后半段路径</blockquote>","art_author":"yellow star","art_createtime":"2022-12-23T08:02:11.000Z","art_tags":4},{"id":112,"art_title":"各个平台搜索引擎的收录网址","art_content":"<h2>百度</h2><p> <a href=\"https://ziyuan.baidu.com/linksubmit/url\" target=\"_blank\">https://ziyuan.baidu.com/linksubmit/url</a> </p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1671778075822.png\" alt=\"\" data-href=\"\" style=\"\"/></p><h2>bing</h2><p> <a href=\"https://www.bing.com/webmasters\" target=\"_blank\">https://www.bing.com/webmasters</a> </p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1671778145778.png\" alt=\"\" data-href=\"\" style=\"\"/></p><h2>Google</h2><p> <a href=\"https://search.google.com/search-console\" target=\"_blank\">https://search.google.com/search-console</a> </p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1671778194424.png\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-12-23T06:50:19.000Z","art_tags":10},{"id":111,"art_title":"错误边界（Error Boundaries）","art_content":"<p style=\"text-align: start;\">部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p><p style=\"text-align: start;\">错误边界是一种 React 组件，这种组件<strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p><p style=\"text-align: start;\">错误边界是一种 React 组件，这种组件<strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p><blockquote style=\"text-align: start;\">注意<br>错误边界无法捕获以下场景中产生的错误：<br>事件处理（了解更多）<br>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）<br>服务端渲染<br>它自身抛出来的错误（并非它的子组件）</blockquote><p style=\"text-align: start;\">如果一个 class 组件中定义了 <a href=\"https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror\" target=\"\"><code>static getDerivedStateFromError()</code></a> 或 <a href=\"https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch\" target=\"\"><code>componentDidCatch()</code></a> 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 <span style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"><code>static getDerivedStateFromError()</code></span> 渲染备用 UI ，使用 <span style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"><code>componentDidCatch()</code></span> 打印错误信息。</p><pre><code class=\"language-javascript\">class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {    // 更新 state 使下一次渲染能够显示降级后的 UI    return { hasError: true };  }\n  componentDidCatch(error, errorInfo) {    // 你同样可以将错误日志上报给服务器    logErrorToMyService(error, errorInfo);  }\n  render() {\n    if (this.state.hasError) {      // 你可以自定义降级后的 UI 并渲染      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    }\n    return this.props.children; \n  }\n}</code></pre><p style=\"text-align: start;\">然后你可以将它作为一个常规组件去使用：</p><pre><code class=\"language-javascript\">&lt;ErrorBoundary&gt;\n  &lt;MyWidget /&gt;\n&lt;/ErrorBoundary&gt;</code></pre><p style=\"text-align: start;\">错误边界的工作方式类似于 JavaScript 的 <span style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"><code>catch {}</code></span>，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p><p style=\"text-align: start;\">注意<strong>错误边界仅可以捕获其子组件的错误</strong>，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 <span style=\"color: rgb(26, 26, 26); background-color: rgba(255, 229, 100, 0.2);\"><code>catch {}</code></span> 的工作机制。</p><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-20T07:46:06.000Z","art_tags":4},{"id":110,"art_title":"nginx配置解决访问静态资源跨域问题","art_content":"<p>在nginx.conf文件中location添加header配置项打开访问来源</p><pre><code >   server {\n        listen       88; ## 端口\n        server_name  localhost; ## 域名\n        location / {  ## 匹配路径\n            add_header 'Access-Control-Allow-Origin' '*';\n            add_header 'Access-Control-Allow-Credentials' 'true';\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n            add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n            root   /www/www; ##  文件根目录\n            index  index.html index.htm; ## 默认页名称\n            if (!-e $request_filename) {\n       \t rewrite ^/(.*) /index.html last;\n        \tbreak;\n            }\n        }\n        error_page   500 502 503 504  /50x.html; ## 报错编码对应页面\n        location = /50x.html {\n            root   html;\n        }\n    }\n    </code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-16T05:56:23.000Z","art_tags":4},{"id":109,"art_title":"react项目前端跨域请求解决方案","art_content":"<p><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">通过middleware中间件的方式设置proxy</span></p><p><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">安装插件</span></p><pre><code >yarn add http-proxy-middleware --save\r\n或\r\nnpm install http-proxy-middleware --save</code></pre><p><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">安装middleware插件后，在src目录中新建setupProxy.js文件，在文件中放入如下代码：</span></p><pre><code class=\"language-javascript\">const { createProxyMiddleware } = require('http-proxy-middleware')\r\n\r\n// 通常使用这种方式就够了，如果报错，可以使用下面的方法\r\nmodule.exports = function (app) {\r\n    app.use(\r\n        proxy('/api1', {     // 遇见/api1开头的请求，触发改代理配置\r\n            target: 'http://172.16.136.249:8080',       // 请求转发给谁\r\n            secure: false,\r\n            changeOrigin: true,     // 控制服务器收到的请求头中的Host值，默认false，意思为服务端收到的Host值是我们自己本的地址，开启以后，服务端收到的就会他自己的地址\r\n            pathRewrite: {\r\n              \"^/api1\": \"/api\"      // 把所有/api1重写成api\r\n            }\r\n        }),\r\n        proxy('/api2', {\r\n            target: 'http://172.16.136.250:8080',\r\n            secure: false,\r\n            changeOrigin: true,\r\n            pathRewrite: {\r\n              \"^/api2\": \"/api\"\r\n            }\r\n        })\r\n    )\r\n}\n\n\r\n//已采用方法，没有问题\r\nmodule.exports = function (app) {\r\n    app.use(\r\n        createProxyMiddleware('/api', {\r\n            target: 'http://172.16.136.249:8080',\r\n            secure: false,\r\n            changeOrigin: true,\r\n            pathRewrite: {\r\n              \"^/api\": \"/api\"\r\n            }\r\n        })\r\n    )\r\n}</code></pre><blockquote>在<span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">setupProxy.js文件中不能使用</span>require直接引用本地项目文件，可能和打包后路径偏差影响有关</blockquote>","art_author":"yellow star","art_createtime":"2022-12-15T03:24:52.000Z","art_tags":4},{"id":108,"art_title":"解决mobx6数据更新react无法实时渲染问题","art_content":"<p style=\"text-align: start;\">useObserver 的使用几乎和 Class 组件的 render 函数的使用方式一致。事实上也确实如此，而且他的使用规则也很简单，直接把需要返回的 Node 用该 hooks 包裹后再返回就可以了。</p><p style=\"text-align: start;\">经过这样处理的组件，就可以成功监听数据的变化，当数据变化的时候，会触发组件的重渲染。</p><pre><code class=\"language-javascript\">import { useObserver } from 'mobx-react'\n\n...\n\nreturn useObserver(() =&gt; (\r\n    &lt;div&gt;\r\n        ...\r\n    &lt;/div&gt;\r\n  ))\n</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-14T02:06:22.000Z","art_tags":4},{"id":107,"art_title":"React.memo()、useCallback()、useMemo()实现减少子组件渲染","art_content":"<h2>React.memo()</h2><p>React.memo 为高阶组件。它与React.PureComponent非常相似。</p><p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。这与shouldComponentUpdate 方法的返回值相反。</p><pre><code class=\"language-javascript\">function MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nfunction areEqual(prevProps, nextProps) {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n}\r\nexport default React.memo(MyComponent, areEqual);</code></pre><p><strong>问题：</strong>如果此时在子组件引用了事件处理函数的话， React.memo()将会失效，因为父组件在每次重新渲染时，定义的事件函数也会重新声明，对子组件来说，该事件属性已经发生改变了所以每次都会重新渲染；</p><pre><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={(newName) =&gt; setName(newName)}/&gt;</code></pre><blockquote style=\"text-align: start;\">注意: 如果直接使用<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>useState</code></span>解构的setName传给子组件, 子组件将不会重复渲染，因为解构出来的是一个memoized 函数。</blockquote><pre style=\"text-align: start;\"><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={setName}/&gt;</code></pre><p>如何解决因事件函数产生的重复渲染呢，这个时候需要用到useCallback()了</p><h2>useCallback()</h2><p><span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">把内联回调函数及依赖项数组作为参数传入 </span>useCallback<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">，它将返回该回调函数的</span>memoized回调函数<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">，该回调函数仅在某个依赖项改变时才会更新</span></p><blockquote><span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>memoized</code></span>回调函数: 使用一组参数初次调用函数时，缓存参数和计算结果，当再次使用相同的参数调用该函数时，直接返回相应的缓存结果。(返回对应饮用，所以恒等于 ===)</blockquote><pre><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={ useCallback((newName: string) =&gt; setName(newName), []) }/&gt;</code></pre><h2 style=\"text-align: start;\">useMemo()</h2><p><span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">上面的例子中，name 属性是个字符串，如果换成传递对象会怎样？</span></p><pre><code class=\"language-javascript\">const userInfo={name:\"jack\",age:16}\nreturn (\n    ...\n    &lt;ChildMemo userInfo={userInfo} /&gt;\n)\n</code></pre><p>更新父组件的其他state变量，看到子组件每次都重新渲染了。<br>分析原因跟调用函数是一样的：</p><ul><li>更新父组件state，触发父组件重新渲染；</li><li>父组件渲染，userInfo 会重新生成一个新对象，导致传递给子组件的 userInfo 属性值变化，进而导致子组件重新渲染。</li><li>注意: 如果使用<code>useState</code>解构的userInfo, 子组件将不会重复渲染，因为解构出来的是一个memoized 值。</li></ul><p>解决：<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">使用 useMemo 将对象属性包一层。useMemo()返回一个 memoized 值。</span></p><pre><code class=\"language-javascript\">const userInfo = useMemo(() =&gt; ({ name: \"小明\", age: 18 }), []);\nreturn (\n    ...\n    &lt;ChildMemo userInfo={userInfo} /&gt;\n)</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-08T02:48:09.000Z","art_tags":8},{"id":106,"art_title":"全网置灰特效如何做到的？","art_content":"<p style=\"text-align: start;\">在网站控制台中，在根目录html节点找到了这个属性<span style=\"background-color: rgb(245, 219, 77);\"> filter: grayscale(1); </span>将它删除，置灰特效就消失了，那来了解一下吧</p><h1 style=\"text-align: start;\">filter</h1><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS\" target=\"\">CSS</a>属性 <code><strong>filter</strong></code> 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。</p><p>CSS 标准里包含了一些已实现预定义效果的函数。你也可以参考一个 SVG 滤镜，通过一个 URL 链接到 SVG 滤镜元素（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter\" target=\"\">SVG filter element</a>）。</p><h2><span style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"><code><strong>grayscale()</strong></code></span></h2><p><span style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"> 对图片进行灰度转换，它是 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter-function\" target=\"\" style=\"text-align: start;\"><span style=\"background-color: var(--code-background-inline);\"><code>&lt;filter-function&gt;</code></span></a><span style=\"color: rgb(27, 27, 27); background-color: rgb(255, 255, 255); font-size: 16px;\"> 的子属性。</span></p><h2><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter-function/grayscale#%E8%AF%AD%E6%B3%95\" target=\"\">语法</a></h2><pre><code class=\"language-css\">grayscale(amount)</code></pre><h3>参数</h3><p>amount</p><p>转换值的大小，可以是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/number\" target=\"\"><span style=\"background-color: var(--code-background-inline);\"><code>&lt;number&gt;</code></span></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage\" target=\"\"><span style=\"background-color: var(--code-background-inline);\"><code>&lt;percentage&gt;</code></span></a>. 当值为 100% 时，灰度最大。0% 时与原图没有区别。0% 到 100% 之间的值会使灰度线性变化。amount 为空时使用值为<span style=\"background-color: var(--code-background-inline);\"><code>1</code></span>.</p><h2>例子</h2><pre><code class=\"language-css\">grayscale(0)     /* 无效果 */\ngrayscale(.7)    /* 70% 灰度 */\ngrayscale(100%)  /* 灰度最大 */</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-06T01:29:09.000Z","art_tags":4},{"id":105,"art_title":"TS 中 interface 和 type 究竟有什么区别？","art_content":"<p><br></p><h2>前言</h2><p>我在学习 TS 时遇到了一个问题：</p><p>比如下面这个例子，可以用 type，也可以用 interface。</p><pre><code class=\"language-typescript\">interface Person {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}</code></pre><pre><code class=\"language-typescript\">type Person = {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}</code></pre><p><br></p><h2>interface</h2><p>interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。</p><pre><code class=\"language-typescript\">interface Person {\n    name: string\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}</code></pre><h2>type</h2><p>type (类型别名)，顾名思义，类型别名只是给类型起一个新名字。<strong>它并不是一个类型，只是一个别名而已</strong></p><p>就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他<code>字母哥</code>。</p><p>就像我们项目中配置 <code>alias</code>，不用写相对路径就能很方便地引入文件</p><pre><code class=\"language-typescript\">import componentA from '../../../../components/componentA/index.vue'\n变成\nimport componentA from '@/components/componentA/index.vue\n复制代码</code></pre><p>有了 type，我们书写 TS 的时候可以更加方便简洁。</p><p>比如下面这个例子，<code>getName</code> 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。</p><pre><code class=\"language-typescript\">type Name = string\ntype NameResolver = () =&gt; string\ntype NameOrResolver = Name | NameResolver          // 联合类型\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n\n    }\n    else {\n        return n()\n    }\n}</code></pre><p>这样调用时传字符串和函数都可以。</p><pre><code class=\"language-typescript\">getName('lin')\ngetName(() =&gt; 'lin')</code></pre><p>如果传的格式有问题，就会提示。</p><p><br></p><h2>两者相同点</h2><h3>都可以定义一个对象或函数</h3><p>定义对象前面已经说了，我们来看一下如何定义函数。</p><pre><code class=\"language-typescript\">type addType = (num1:number,num2:number) =&gt; number\n\ninterface addType {\n    (num1:number,num2:number):number\n}\n这两种写法都可以定义函数类型</code></pre><pre><code class=\"language-typescript\">const add:addType = (num1, num2) =&gt; {\n    return num1 + num2\n}</code></pre><h3>都允许继承（extends）</h3><p>我们定义一个 Person 类型和 Student 类型，<strong>Student 继承自 Person</strong>，可以有下面四种方式</p><h4>interface 继承 interface</h4><pre><code class=\"language-typescript\">interface Person { \n  name: string \n}\ninterface Student extends Person { \n  grade: number \n}</code></pre><pre><code class=\"language-typescript\">const person:Student = {\n  name: 'lin',\n  grade: 100\n}</code></pre><h4>type 继承 type</h4><pre><code class=\"language-typescript\">type Person = { \n  name: string \n}\ntype Student = Person & { grade: number  }    用交叉类型</code></pre><h4>interface 继承 type</h4><pre><code class=\"language-typescript\">type Person = { \n  name: string \n}\n\ninterface Student extends Person { \n  grade: number \n}</code></pre><h4>type 继承 interface</h4><pre><code class=\"language-typescript\">interface Person { \n  name: string \n}\n\ntype Student = Person & { grade: number  }    用交叉类型</code></pre><p>interface 使用 extends 实现继承， type 使用交叉类型实现继承</p><h2>两者不同点</h2><h3>type 可以，interface 不行</h3><blockquote>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 -- TS 文档</blockquote><h4>声明基本类型、联合类型、交叉类型、元组</h4><pre><code class=\"language-typescript\">type Name = string                              // 基本类型\n\ntype arrItem = number | string                  // 联合类型\n\nconst arr: arrItem[] = [1,'2', 3]\n\ntype Person = { \n  name: Name \n}\n\ntype Student = Person & { grade: number  }       // 交叉类型\n\ntype Teacher = Person & { major: string  } \n\ntype StudentAndTeacherList = [Student, Teacher]  // 元组类型\n\nconst list:StudentAndTeacherList = [\n  { name: 'lin', grade: 100 }, \n  { name: 'liu', major: 'Chinese' }\n]</code></pre><h3>interface可以，type 不行</h3><h4>合并重复声明</h4><pre><code class=\"language-typescript\">interface Person {\n    name: string\n}\n\ninterface Person {         // 重复声明 interface，就合并了\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}</code></pre><p>重复声明 type ，就报错了</p><pre><code class=\"language-typescript\">type Person = {\n    name: string\n}\n\ntype Person = {     // Duplicate identifier 'Person'\n    age: number\n}\n\nconst person: Person = {\n    name: 'lin',\n    age: 18\n}\n</code></pre><p><br></p><h2>小结</h2><p>interface 和 type 被 TS 设计出来，是完全不同的东西，有各自的职责。</p><p>interface 是<strong>接口</strong>，用于描述一个对象。</p><p>type 是<strong>类型别名</strong>，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。</p><p>只是有时候两者都能实现同样的功能，才会经常被混淆。</p><p>平时开发中，一般<strong>使用组合或者交叉类型</strong>的时候，用 type。</p><p>一般要用类的 <strong>extends</strong> 或 <strong>implements</strong> 时，用 interface。</p><p><br></p><p>原文： <a href=\"https://juejin.cn/post/7063521133340917773\" target=\"_blank\">https://juejin.cn/post/7063521133340917773</a> <br></p>","art_author":"yellow star","art_createtime":"2022-12-05T01:31:14.000Z","art_tags":4},{"id":104,"art_title":"谈一谈 CSS框架TailwindCSS","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=image-1669969207140.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p>网上收集了一点信息，简单说一下我的理解</p><p>先说立场：如果让我选择的话，我不会主动使用TailwindCSS。</p><p>TailwindCSS框架其实就是将很多的css属性直接class命名单独包装好直接在dom里使用，这样有个优点就是可以不写css文件一切样式皆在元素内实现，但是我认为通过行内样式也可以实现；</p><p>还有一个优点也是我网上看到很多用户喜欢的一点，使用tailwind可以让你在编码的时候不用再饱受class命名的纠结了，其实我个人开发的时候对于命名问题并没有那么折磨，个人喜欢继承式驼峰命名，并不会太纠结，虽然命名很随意，而且现在用css module并不会担心命名冲突问题，而且我觉得使用TailwindCSS会让元素变得臃肿，而且对于我这种记性不好的，再去记一套名称，真的是灾难；</p><p>我认为一套框架的出现应该是会让原有的方式发生跳跃式的改变，就比如jQuery、React框架的出现对原生开发的影响一样；所以我不看好TailwindCSS；</p><pre><code class=\"language-html\">/* 行内样式 */\n&lt;div style=\"{ borderRadius: '0.5rem', padding: '1rem' }\"&gt; Click &lt;/div&gt;\r\n\r\n/* TailwindCSS */\n&lt;div class=\"rounded-lg p-4\"&gt; Click &lt;/div&gt;</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-02T08:22:02.000Z","art_tags":4},{"id":103,"art_title":"最近看的一部爽剧《财阀家的小儿子》","art_content":"<p style=\"text-align: start;\"><img src=\"http://124.223.185.220:3000/getImage?img=image-1669600845465.png\" alt=\"\" data-href=\"\" style=\"\"></p><h1 style=\"text-align: start;\">财阀家的小儿子 <span style=\"color: rgb(229, 57, 53); font-size: 15px;\">更新至6集</span></h1><p><span style=\"color: rgb(153, 153, 153);\">豆瓣评分：</span> &nbsp;<span style=\"color: rgb(255, 153, 0); font-size: 24px;\">8.5</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153);\">分类：</span>奇幻,剧情,爱情 &nbsp;<span style=\"color: rgb(153, 153, 153);\">地区：</span>韩国 &nbsp;<span style=\"color: rgb(153, 153, 153);\">年份：</span>2022 &nbsp;<span style=\"color: rgb(153, 153, 153);\">又名：</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153);\">演员：</span><a href=\"https://www.hdmoli.com/search.php?searchword=%E5%AE%8B%E4%BB%B2%E5%9F%BA\" target=\"\">宋仲基</a> &nbsp;<a href=\"https://www.hdmoli.com/search.php?searchword=%E6%9D%8E%E6%98%9F%E6%B0%91\" target=\"\">李星民</a> &nbsp;<a href=\"https://www.hdmoli.com/search.php?searchword=%E7%94%B3%E8%B4%A4%E5%BD%AC\" target=\"\">申贤彬</a> &nbsp;<a href=\"https://www.hdmoli.com/search.php?searchword=%E8%B5%B5%E6%B1%89%E5%93%B2\" target=\"\">赵汉哲</a> &nbsp;<a href=\"https://www.hdmoli.com/search.php?searchword=%E9%87%91%E8%B4%9E%E5%85%B0\" target=\"\">金贞兰</a> &nbsp; </p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153);\">导演：</span>郑大允 </p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153);\">更新：</span>2022-11-28 07:50 &nbsp;<span style=\"color: rgb(153, 153, 153);\">更新周期：</span>周五,周六,周日</p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153);\">短评：</span>重生复仇商战爽剧</p><p style=\"text-align: start;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">解说：</span><span style=\"color: rgb(102, 102, 102); font-size: 14px;\"> </span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">简介：</span><span style=\"color: rgb(102, 102, 102); font-size: 14px;\"> 改编自同名人气网络小说，讲述管理财阀一家的秘书尹贤宇（宋仲基 饰），被冤枉涉嫌侵吞资金而被财阀家杀害。尹贤宇重生为财阀家的小儿子陈道俊，以新的身份一边成长一边复仇的故事。</span></p><p><span style=\"color: rgb(102, 102, 102); font-size: 14px;\">观看链接： </span><a href=\"https://www.hdmoli.com/movie/index1636.html\" target=\"_blank\">https://www.hdmoli.com/movie/index1636.html</a> </p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1669600619098.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-28T02:01:28.000Z","art_tags":6},{"id":102,"art_title":"很有趣的一个表情生成工具","art_content":"<p>网站链接： <a href=\"https://paramoji.org/\" target=\"_blank\">https://paramoji.org/</a> </p><p>看看效果：</p><p><img src=\"https://paramoji.org/paramoji.svg.php?v=67&a1=71&a2=33&d=79&c=56\" alt=\"https://paramoji.org/paramoji.svg.php?v=67&a1=71&a2=33&d=79&c=56\" data-href=\"https://paramoji.org/paramoji.svg.php?v=67&a1=71&a2=33&d=79&c=56\" style=\"width: 299.00px;height: 299.00px;\"/></p>","art_author":"yellow star","art_createtime":"2022-11-25T02:45:01.000Z","art_tags":10},{"id":101,"art_title":"老子的一脸不屑","art_content":"<p><img src=\"https://paramoji.org/paramoji.svg.php?v=3&a1=99&a2=0&d=50&c=100\" alt=\"https://paramoji.org/paramoji.svg.php?v=3&a1=99&a2=0&d=50&c=100\" data-href=\"https://paramoji.org/paramoji.svg.php?v=3&a1=99&a2=0&d=50&c=100\" style=\"width: 319.00px;height: 319.00px;\"/></p>","art_author":"yellow star","art_createtime":"2022-11-25T02:42:35.000Z","art_tags":6},{"id":99,"art_title":"深入理解HTTP缓存机制及原理","art_content":"<h3>一、前言</h3><p>       上周阿里的面试官问了个面试题 “ 能不能说下 304 的过程，以及影响缓存的头部属性有哪些？”OMG.......因为之前只是大概了解 304 状态码是表示缓存，且因为平时项目开发过程中也没有在缓存这块踩过坑，所以这一块也没有去做特别深入的研究。所以当被问这个问题时，有被当头一棒的感觉，也好好反思了下，自己校招以软件开发工程师的职位进入公司，之前没有想过要从事前端开发，所以前端基础几乎可以忽略不计。工作一年多来，为在工作上表现突出，在工作上投入大量的精力，干到晚上10点是常规操作，周末至少加班1天；并且空余时间，经常看前端相关书籍弥补基础，如《JavaScript 高级程序设计》、《CSS 权威指南》、《Sass 实践》、《JavaScript 高性能编程》....《Webpack 实践》、《深入浅出 node.js》等不下10本书；在广度上涉及的还是很多的，但是存在问题：从事前端时间不长，前端知识杂而多，如果没有专门准备，如果突然问你一个知识点，你虽然大概知道这是啥，但是让你讲的话，你很难有条理的讲清楚。</p><p>       So，下一阶段的首要任务：“打好打牢前端基础，深入了解所用的技术栈原理”。废话少说，学问学问，不懂就弄清楚！以下“理论知识 + 实践操作”来彻底弄懂 HTTP 缓存机制及原理！</p><h3>二、缓存规则及解析</h3><p>       为方便大家理解，我假设览器存在一个缓存数据库，用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。如下流程图所示：</p><p><img src=\"\" alt=\"\" data-href=\"\" style=\"\"/></p><p><img src=\"\" alt=\"\" data-href=\"\" style=\"\"/><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1125a6943e17~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><p>       根据是否需要重新向服务器发起请求来分类，将HTTP缓存规则分为两大类(<strong>强制缓存</strong>，<strong>对比缓存</strong>)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p><p>（1）已存在缓存数据时，仅基于<strong>强制缓存</strong>，请求数据的流程如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1131a01649ce~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>（2）已存在缓存数据时，仅基于<strong>对比缓存</strong>，请求数据的流程如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a113789f814d2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>       我们可以看到两类缓存规则的不同，<strong>强制缓存</strong>如果生效，不需要再和服务器发生交互，而<strong>对比缓存</strong>不管是否生效，都需要与服务端发生交互。</p><p>       两类缓存规则可以同时存在，<strong>强制缓存</strong>优先级高于<strong>对比缓存</strong>，也就是说，当执行<strong>强制缓存</strong>的规则时，如果缓存生效，直接使用缓存，不再执行<strong>对比缓存</strong>规则。</p><h3>三、缓存常用字段</h3><h3>1、http1.0时期的缓存方案</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a119737ecdeb2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>注意： </p><p>（1）如果使用了<code>Pragma: 'no-cache'</code>的话，再设置<code>Expires</code>或者<code>Cache-Control</code>，就没有用了，说明<code>Pragma</code>的权值比后两者高。</p><p> （2）如果设置了<code>Expires</code>之后，客户端在需要请求数据的时候，首先会对比当前系统时间和这个<code>Expires</code>时间，如果没有超过<code>Expires</code>时间，则直接读取本地磁盘中的缓存数据，不发送请求。<br></p><h3>2、http1.1 时期的缓存方案</h3><p><strong>2.1、Cache-Control 字段 </strong></p><p><strong>2.1.1、Cache-Control 作为请求头字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11b7c6a465ba~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>（1）Cache-Control: no-cache </strong></p><p>使用<code>no-cache</code>指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 <code>no-cache</code> 指令，则表示客户端将不会接收缓存的资源。每次请求都是从服务器获取资源，返回304。<br> </p><p><strong>（2）Cache-Control: no-store </strong></p><p>使用<code>no-store</code> 指令表示请求的资源不会被缓存，下次任何其它请求获取该资源，还是会从服务器获取，返回 200，即资源本身。<br></p><p><strong>2.1.2、Cache-Control 作为响应头字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11c6b7651b77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>Cache-Control: public </strong></p><p>当指定使用 <code>public </code>指令时，则明确表明其他用户也可利用缓存。</p><p><strong> Cache-Control: private</strong></p><p>当指定 <code>private</code> 指令后，响应只以特定的用户作为对象，这与 <code>public</code> 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。</p><p><strong> Cache-Control: no-cache </strong></p><p>如果服务器返回的响应中包含<code> no-cache </code>指令，每次客户端请求，必需先向服务器确认其有效性，如果资源没有更改，则返回304. </p><p><strong>Cache-Control: no-store </strong></p><p>不对响应的资源进行缓存，即用户下次请求还是返回 200，返回资源本身。 </p><p><strong>Cache-Control: max-age=604800（单位：秒） </strong></p><p>资源缓存在本地浏览器的时间，如果超过该时间，则重新向服务器获取。<br></p><p><strong>2.2、请求头部字段 & 响应头部字段</strong></p><p><strong>2.2.1、请求头部字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11dbaa0f8a2a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.2.2、响应头部字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11e177c975f2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>注意：</p><p> （1）<code>If-None-Match</code>的优先级比<code>If-Modified-Since</code>高，所以两者同时存在时，遵从前者。<br></p><h3>四、实验验证</h3><p><strong>1、实验1 — 请求的资源没修改，验证2种缓存出现的情形</strong></p><p>服务端使用 node.js ， 客户端使用 axios 进行请求：</p><p><strong>1.1、请求头部 / 响应头部 设置<br></strong></p><p>（1）服务端响应头部设置：</p><p>     res.setHeader('Cache-Control', 'public, max-age=10');</p><p>（2）客户端请求头部使用默认设置</p><p><br></p><p><strong>1.2、实验步骤</strong></p><p>（1）请求 3 次，第一次请求请求资源；第二次在10秒内再次请求该资源，第三次在 10 秒后再次请求该资源（实验过程中，服务端的资源没有进行改变）</p><p><br></p><p><strong>1.3、实验结果</strong></p><p>      3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（10 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（10 秒后）请求该资源时，因为资源缓存时间（10 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源没有做更改，所以返回 304，让客户端直接从浏览器缓存中获取该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11ff1e022d96~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.1、第一次请求资源</strong></p><p> 第一次请求资源的请求头部和响应头部的截图如下所示，因为第一次请求该资源，本地并没有缓存，所以直接从服务器获取该资源；我们从截图可以看到，服务器返回改资源的响应头部中包含3个属性与资源缓存相关：</p><p>（1）cache-control: public, max-age=10</p><p> &nbsp; &nbsp; 缓存规则的设置，我们这个示例中，设置缓存规则为 public, 并且设置缓存过期时间为10秒；</p><p>（2）etag: W/\"95f15b-16994d7ebf6\"</p><p> &nbsp; &nbsp; 资源的唯一标识符，客户端下次访问该资源时，会在请求头中携带 etag 去向服务器确认，该资源是否被修改；</p><p>（3）last-modified: Tue, 19 Mar 2019 07:26:12 GMT</p><p> &nbsp; &nbsp; 资源最后一次修改时间，客户端下次访问该资源时，会在请求头中携带该信息去向服务器进行匹配，该资源是否被修改；</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12072e2e0cb6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.2、第二次请求资源（10秒内，即在缓存时间失效前）</strong></p><p>       第二次请求资源的请求头部和响应头部的截图如下所示，因为第二次请求该资源，该资源本地缓存还没失效，所以就直接从浏览器缓存中获取该资源。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a120bbf711005~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.3、第三次请求资源（10秒后，即在缓存时间失效后）</strong></p><p>       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1211c38c875b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2、实验2 — 请求的资源进行修改，验证2种缓存出现的情形</strong></p><p>服务端使用 node.js ， 客户端使用 axios 进行请求：</p><p><strong>2.1、请求头部 / 响应头部 设置</strong></p><p>（1）服务端响应头部设置：</p><p>     res.setHeader('Cache-Control', 'public, max-age=20');</p><p>（2）客户端请求头部使用默认设置</p><p><br></p><p><strong>2.2、实验步骤</strong></p><p>（1）请求 3 次，第一次请求资源；然后在服务器对请求的资源进行修改，第二次在 20 秒内再次请求该资源，第三次在 20 秒后再次请求该资源</p><p><br></p><p><strong>2.3、实验结果</strong></p><p>       3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（20 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（20 秒后）请求该资源时，因为资源缓存时间（20 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源不同，所以重新返回该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121606944373~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.1、第一次请求资源</strong></p><p>       第一次请求资源的请求头部和响应头部的截图如下所示，具体详细信息与 1.3.1 小节相同，在此不同重复介绍。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1219166741f1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.2、第二次请求资源（20 秒内，即在缓存时间失效前）</strong></p><p>      第二次请求资源的请求头部和响应头部的截图如下所示，（注意：即使此时服务器上的资源已经更改，但是由于缓存在浏览器中的资源没有过期，所以还是从缓存中返回旧资源）。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121db9c73552~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.3、第三次请求资源（20 秒后，即在缓存时间失效后）</strong></p><p>       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改，从下图中可以看到，响应头部的属性 etag 与 请求头部的属性 If-None-Match &nbsp;不同，响应头部的属性 If-Modified-Since 与 请求头部的属性 last-modified 不同；所以服务器返回该资源的最新资源。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1221529a99db~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><h3>五、总结</h3><p>1、对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p><p>2、对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p><p>总结流程图如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12255df4532a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><em>有任何问题欢迎留言讨论，如果觉得对你有帮助，请点赞鼓励~</em><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>作者：我是你的超级英雄<br>链接：https://juejin.cn/post/6844903801778864136<br>来源：稀土掘金</p>","art_author":"yellow star","art_createtime":"2022-11-25T02:33:28.000Z","art_tags":4},{"id":98,"art_title":"使用 Github Actions 部署react-app 到 Github Pages","art_content":"<h2 style=\"text-align: start;\">原文： <a href=\"https://segmentfault.com/a/1190000041449997\" target=\"_blank\">https://segmentfault.com/a/1190000041449997</a> </h2><h2 style=\"text-align: start;\">前言-学以致用</h2><p style=\"text-align: start;\">之前一直忙于开发，总是零散的去看一些东西，想想学东西了么？额... 好像学了，又好像没有学，不知道你们有没有这种感觉，所以新年初始，换一种学习方法，本着学以致用去完整的学一些东西，正好之前想接触CI,CD 这里的知识，所以就从最常见的github开始吧，毕竟免费又常用。</p><h2 style=\"text-align: start;\">初始化项目</h2><p style=\"text-align: start;\">创建github代码仓库，clone 项目到本地，进入目录初始化项目</p><pre style=\"text-align: start; line-height: 1.5;\"><code>npx create-react-app</code></pre><p style=\"text-align: start;\">然后按照命令提示输入完成初始化,推送项目到github。</p><h2 style=\"text-align: start;\">配置github actions</h2><p style=\"text-align: start;\">目标是实现推送代码到master分支, 自动开始构建项目，部署到Gthub Pages。<br>按照<a href=\"https://link.segmentfault.com/?enc=BsHuQ0PzigUZ28kaoAvQ1A%3D%3D.qxiSOELr%2FQtZg8yDLMw5z%2F3N%2Fg7890IdTr0xBDUgph6mtDx00VjRN6ObO29wJLlQ\" target=\"_blank\">文档</a>先跑起来第一个流程，让自己看到效果，在去学习语法内容，这样更能激发兴趣，免得直接看文档看睡着了...</p><ol style=\"text-align: start;\"><li>在目录外层增加 .gihub/workflows文件夹，创建第一个first-demo.yml文件，拷贝示例内容.</li></ol><pre style=\"text-align: start; line-height: 1.5;\"><code>name: GitHub Actions Demo\non: [push]\njobs:\n  Explore-GitHub-Actions:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\"\n      - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\"\n      - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\"\n      - name: Check out repository code\n        uses: actions/checkout@v2\n      - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\"\n      - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\"\n      - name: List files in the repository\n        run: |\n          ls ${{ github.workspace }}\n      - run: echo \"🍏 This job's status is ${{ job.status }}.\"</code></pre><ol style=\"text-align: start;\"><li>提交代码，点击gihub仓库上方的<strong>Actions</strong>按钮，查看效果，第一个工作流程就完成了。<br><img src=\"https://segmentfault.com/img/bVcX4QB\" alt=\"image.png\" data-href=\"\" style=\"\"></li></ol><h2 style=\"text-align: start;\">开始编写自己的yml文件,实现自动构建</h2><p style=\"text-align: start;\">快速过一遍文档，学习一下语法，实现自己想要的工作流程。从demo可以看到主要有流程有这么几步</p><ol style=\"text-align: start;\"><li>name 工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。</li><li>on 触发流程的事件，具体可以触发的事件有<a href=\"https://link.segmentfault.com/?enc=RQOtsmXdu0%2FEXbROT%2FG%2F2Q%3D%3D.7z%2ByjH%2FOcAA%2Fn%2FAOG%2FPEc7sSAqWm8y9eeuk2jE6mKo3Sady7tvQdfp9twn8zABomtUFNy9UaxNnRKqmagziAA9KkvrPW%2FqZd9INMAa1hQb5%2Bbgd048QnZ4pxSaX8iVBA\" target=\"_blank\">这些</a>,我们所要实现的是提交代码，所以用 push.</li><li>jobs 要按顺序运行作业.</li></ol><p style=\"text-align: start;\">目标明确后，开始编写yml</p><pre style=\"text-align: start; line-height: 1.5;\"><code class=\"language-xml\"> # 显示得workflow名称\n name: First GitHub Actions Demo\n on: \n   # 推送到master分支开始打包\n   push:\n     branches:\n       - master\n\n jobs:\n   # 开始打包\n   Build:\n     runs-on: ubuntu-latest\n     steps:\n     - name: checkout code\n       # 迁出触发的流程的版本 能让下面的工作流程访问\n       uses: actions/checkout@v2\n       # setup-node 可以提供node环境，指定node版本以及 npm /yarn缓存\n     - name: actions/setup-node@v2\n       uses: actions/setup-node@v2   \n       with:\n         node: 16.14\n     # 初始用的npm 打包时间太长了，就想着用yarn 结果没仔细看文档，yarn 不用安装 ubuntu 上面有的 \n     # - name: install yarn \n     #  uses: npm install yarn     \n     # - run: yarn install\n     # - run: yarn build\n     # 简写为\n     - run: yarn install &amp;&amp; yarn build</code></pre><p style=\"text-align: start;\">好了提交代码看Actions（这是上面没有优化时的流程）。<br><img src=\"https://segmentfault.com/img/bVcX4U4\" alt=\"image.png\" data-href=\"\" style=\"\"><br>到此已经完成了提交代码自动打包的过程了，但是一看打包时间好家伙一分半，这要是实际开发大量依赖加入，那不得半个小时么？打开流程一看大部分时间都是在下载依赖，所以是不是可以添加缓存呢？一搜索果然有<a href=\"https://link.segmentfault.com/?enc=pnQPaLLU4xUkEVZs%2FAOMvg%3D%3D.2tU0x25fYK3W5v%2BKIaXbPtcgPRdBA3aCtheR9dRUoYVvVXrZqh4THcigzp8RkBWk\" target=\"_blank\">cache</a>,麻溜的按照文档添加进入，<br>一看时间46s,哈哈果然有效。到此yml内容为</p><pre style=\"text-align: start; line-height: 1.5;\"><code>name: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: checkout code\n      uses: actions/checkout@v2\n    - name: actions/setup-node@v2\n      uses: actions/setup-node@v2   \n      with:\n        node: 16.14\n    # 配置依赖缓存\n    - name: yarn cache\n      id: yarn-cahce-dir-path\n      run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    - uses: actions/cache@v2\n      id: yarn-cache\n      with: \n        path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: | \n          ${{ runner.os }}-yarn-\n    - run: yarn install &amp;&amp; yarn build</code></pre><h2 style=\"text-align: start;\">部署页面到Github Pages</h2><ol style=\"text-align: start;\"><li>首先需要设定一个分支，当做站点的根目录，具体<a href=\"https://link.segmentfault.com/?enc=VmP76VTiM%2BW%2BWDCp%2BCe%2BoQ%3D%3D.jjGmPHjENUgpLSpQUCjLgHZb4H9WteP7M1b8%2BsmlO6wkRYs7iMMi5X5gx4V3jda8WFrsrW7EPYw%2F0ARqadAHDW2cDfEmRicaQHdoj%2FsrssbgNcIGSjNimD2L2tqfO61ovyZJ7VdXGgATlEh37KyxRHVcdBEN3%2FFYiTDin%2B4GKvw%3D\" target=\"_blank\">设置文档</a>，设置完成后会告诉你网站访问地址（ps: 一定要把仓库设置为Public,不然无法进行设置）。</li></ol><p style=\"text-align: start;\"><img src=\"https://segmentfault.com/img/bVcX41W\" alt=\"image.png\" data-href=\"\" style=\"\"></p><ol style=\"text-align: start;\"><li>按照文档编辑.yml,增加发布流程</li></ol><pre style=\"text-align: start; line-height: 1.5;\"><code> # 上面的步骤拿过来\n # 新增 deploy\n  - name: deploy\n    uses: JamesIves/github-pages-deploy-action@v4.2.3\n    with:\n      branch: gh-pages # 部署的分支名 有一定要独立一个分支，第一次设置为master 好家伙构建完成后，直接把我的项目文件清除了，只剩下打包的文件了。\n      folder: build   # build后文件目录</code></pre><p style=\"text-align: start;\">效果<br><img src=\"https://segmentfault.com/img/bVcX42T\" alt=\"image.png\" data-href=\"\" style=\"\"><br>到这里基本的目标已经实现了，但是当我看公司内部的流程时，install, build, deploy流程是分开的，这样有利于增加一些校验，lint规则等流程，所以我在思考怎么拆分流程呢，第一次我简单的拆分</p><pre style=\"text-align: start; line-height: 1.5;\"><code>name: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n      - dev\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      uses: actions/checkout@v2\n      uses: actions/setup-node@v2   \n      with:\n        node: 16.14\n    - name: yarn cache\n      id: yarn-cahce-dir-path\n      run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    - uses: actions/cache@v2\n      id: yarn-cache\n      with: \n        path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: | \n          ${{ runner.os }}-yarn-   \n    - run: yarn install\n    - run: yarn build\n  Deploy:\n    - name: depploy\n      uses: JamesIves/github-pages-deploy-action@v4.2.3\n      width:\n        branch: gh-pages\n        folder: build\n        clean: true\n        clean-exclude: |\n          special-file.txt\n          some/*.txt\n        ssh-key: ${{ secrets.PAGE_ACCESS_TOKEN }}    </code></pre><p style=\"text-align: start;\">我想着这样应该就可以了，一提交代码直接GG,第一是没有Deploy没有等待build完成，第二是两个job之间的文件不能够直接用，又翻了下文档才发现官方给了这两个 actions/upload-artifact@v2 actions/download-artifact@v2 可以在不同job之间公用文件，所以又改了改,build阶段上传打包好的文件，deploy阶段下载打包好的文件进行部署（注意deploy也要使用checkout@v2）。<br>最终结果</p><pre style=\"text-align: start; line-height: 1.5;\"><code>name: First GitHub Actions Demo\non: \n  push:\n    branches:\n      - master\n      - dev\n\njobs:\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    # 步骤名称\n    - name: checkout code\n      uses: actions/checkout@v2\n    - name: actions/setup-node@v2\n      uses: actions/setup-node@v2   \n      with:\n        node-version: '16.14'\n        cache: 'yarn'\n        cache-dependency-path: '**/yarn.lock'\n    # 缓存 有需要可以开启 同时 setu node 也可以进行缓存\n    # - name: yarn cache\n    #   id: yarn-cahce-dir-path\n    #   run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    # - uses: actions/cache@v2\n    #   id: yarn-cache\n    #   with: \n    #     path: ${{ steps.yarn-cahce-dir-path.outputs.dir }}\n    #     key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n    #     restore-keys: | \n    #       ${{ runner.os }}-yarn-    \n    - run: yarn install &amp;&amp; yarn build  \n    # 上传打包好的文件，所以下一步可以使用\n    - name: upload files \n      uses: actions/upload-artifact@v2\n      with: \n        name: build-pages\n        path: build\n        retention-days: 1\n  Deploy: \n    needs: Build # 确保build 阶段完成\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout code\n        uses: actions/checkout@v2\n      - name: download build files\n        uses: actions/download-artifact@v2\n        with:\n          name: build-pages\n          path: build\n      - name: deploy\n        uses: JamesIves/github-pages-deploy-action@v4.2.3\n        with:\n          branch: gh-pages\n          folder: build \n          token: \"${{ secrets.DEPLOY_TOKEN }}\"  </code></pre><p style=\"text-align: start;\">提交代码，查看运行结果，完成拆分。<br><img src=\"https://segmentfault.com/img/bVcX49V\" alt=\"image.png\" data-href=\"\" style=\"\"><br>到这里可以愉快的访问你的网站了。</p><h2 style=\"text-align: start;\">结尾</h2><p style=\"text-align: start;\">写作思路是按照当时完成的思路一步一步的去完成这个流程来的，所以有些功能可能还没想到，同时如果流程有什么可以优化的地方，欢迎各位大佬指教。当然，完整的流程还欠缺很多，目前只是先完成简单的打包构建流程，接下来还需要去学习gitlab 的CI、CD,完成后会在水一篇文章。在之后才会去看一些部署项目相关的内容。比如Docker,Nginx等，希望能在空闲之余学会整个流程。加油！</p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-23T08:37:21.000Z","art_tags":4},{"id":97,"art_title":"nextjs代理配置","art_content":"<p>在next.config.js文件中配置：</p><pre><code class=\"language-javascript\">/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  swcMinify: true,\r\n  // rewrites:async ()=&gt;{\r\n  //   return [{\r\n  //     source: '/000000001000/:slug*',\r\n  //     destination: `http://111.20.105.192:6610/000000001000/:slug*`,\r\n  //   },]\r\n  // }\r\n}\r\n\r\nmodule.exports = nextConfig\r\n</code></pre><p>注释部分为代理配置，当匹配到 '/000000001000/’请求路径时会代理到`http://111.20.105.192:6610/000000001000/`地址</p>","art_author":"yellow star","art_createtime":"2022-11-22T09:31:16.000Z","art_tags":4},{"id":96,"art_title":"GitHub Actions 入门教程","art_content":"<h1 style=\"text-align: left;\">阮一峰大神的入门教学，全文copy👨‍💻</h1><p> <a href=\"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\" target=\"_blank\">https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a> </p><p><br></p><p style=\"text-align: left;\">作者： <a href=\"https://www.ruanyifeng.com/\" target=\"\" style=\"text-align: left;\">阮一峰</a></p><p style=\"text-align: left;\">日期： <a href=\"https://www.ruanyifeng.com/blog/2019/09/\" target=\"\" style=\"text-align: left;\">2019年9月12日</a></p><p style=\"text-align: left;\"><br></p><p style=\"text-align: left;\"><a href=\"https://github.com/features/actions\" target=\"_blank\" style=\"text-align: left;\">GitHub Actions</a> 是 GitHub 的<a href=\"https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" style=\"text-align: left;\">持续集成服务</a>，于2018年10月<a href=\"https://github.blog/changelog/2018-10-16-github-actions-limited-beta/\" target=\"_blank\" style=\"text-align: left;\">推出</a>。</p><p style=\"text-align: left;\">这些天，我一直在试用，觉得它非常强大，有创意，比 <a href=\"https://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" style=\"text-align: left;\">Travis CI</a> 玩法更多。</p><p style=\"text-align: left;\">本文是一个简单教程，演示如何使用 GitHub Actions 自动发布一个 React 应用到 <a href=\"https://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html\" target=\"_blank\" style=\"text-align: left;\">GitHub Pages</a>。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091201.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><h2 style=\"text-align: left;\">一、GitHub Actions 是什么？</h2><p style=\"text-align: left;\">大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p><p style=\"text-align: left;\">很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p><p style=\"text-align: left;\">如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p><p style=\"text-align: left;\">GitHub 做了一个<a href=\"https://github.com/marketplace?type=actions\" target=\"_blank\" style=\"text-align: left;\">官方市场</a>，可以搜索到他人提交的 actions。另外，还有一个 <a href=\"https://github.com/sdras/awesome-actions\" target=\"_blank\" style=\"text-align: left;\">awesome actions</a> 的仓库，也可以找到不少 action。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091105.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><p style=\"text-align: left;\">上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>userName/repoName</code></span>的语法引用 action。比如，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>actions/setup-node</code></span>就表示<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>github.com/actions/setup-node</code></span>这个<a href=\"https://github.com/actions/setup-node\" target=\"_blank\" style=\"text-align: left;\">仓库</a>，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 <a href=\"https://github.com/actions\" target=\"_blank\" style=\"text-align: left;\">github.com/actions</a> 里面。</p><p style=\"text-align: left;\">既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见<a href=\"https://help.github.com/en/articles/about-actions#versioning-your-action\" target=\"_blank\" style=\"text-align: left;\">官方文档</a>。</p><blockquote style=\"text-align: left;\">actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支</blockquote><h2 style=\"text-align: left;\">二、基本概念</h2><p style=\"text-align: left;\">GitHub Actions 有一些自己的术语。</p><p style=\"text-align: left;\">（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p><p style=\"text-align: left;\">（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p><p style=\"text-align: left;\">（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p><p style=\"text-align: left;\">（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p><h2 style=\"text-align: left;\">三、workflow 文件</h2><p style=\"text-align: left;\">GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>.github/workflows</code></span>目录。</p><p style=\"text-align: left;\">workflow 文件采用 <a href=\"https://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" style=\"text-align: left;\">YAML 格式</a>，文件名可以任意取，但是后缀名统一为<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>.yml</code></span>，比如<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>foo.yml</code></span>。一个库可以有多个 workflow 文件。GitHub 只要发现<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>.github/workflows</code></span>目录里面有<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>.yml</code></span>文件，就会自动运行该文件。</p><p style=\"text-align: left;\">workflow 文件的配置字段非常多，详见<a href=\"https://help.github.com/en/articles/workflow-syntax-for-github-actions\" target=\"_blank\" style=\"text-align: left;\">官方文档</a>。下面是一些基本字段。</p><p style=\"text-align: left;\"><code><strong>（1）name</strong></code></p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>name</code></span>字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p><blockquote style=\"text-align: left;\">name: GitHub Actions Demo</blockquote><p style=\"text-align: left;\"><code><strong>（2）on</strong></code></p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>on</code></span>字段指定触发 workflow 的条件，通常是某些事件。</p><blockquote style=\"text-align: left;\">on: push</blockquote><p style=\"text-align: left;\">上面代码指定，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>push</code></span>事件触发 workflow。</p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>on</code></span>字段也可以是事件的数组。</p><blockquote style=\"text-align: left;\">on: [push, pull_request]</blockquote><p style=\"text-align: left;\">上面代码指定，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>push</code></span>事件或<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>pull_request</code></span>事件都可以触发 workflow。</p><p style=\"text-align: left;\">完整的事件列表，请查看<a href=\"https://help.github.com/en/articles/events-that-trigger-workflows\" target=\"_blank\" style=\"text-align: left;\">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p><p style=\"text-align: left;\"><code><strong>（3）on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;</strong></code></p><p style=\"text-align: left;\">指定触发事件时，可以限定分支或标签。</p><blockquote style=\"text-align: left;\">on: push: branches: - master</blockquote><p style=\"text-align: left;\">上面代码指定，只有<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>master</code></span>分支发生<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>push</code></span>事件时，才会触发 workflow。</p><p style=\"text-align: left;\"><code><strong>（4）jobs.&lt;job_id&gt;.name</strong></code></p><p style=\"text-align: left;\">workflow 文件的主体是<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>jobs</code></span>字段，表示要执行的一项或多项任务。</p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>jobs</code></span>字段里面，需要写出每一项任务的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job_id</code></span>，具体名称自定义。<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job_id</code></span>里面的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>name</code></span>字段是任务的说明。</p><blockquote style=\"text-align: left;\">jobs: my_first_job: name: My first job my_second_job: name: My second job</blockquote><p style=\"text-align: left;\">上面代码的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>jobs</code></span>字段包含两项任务，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job_id</code></span>分别是<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>my_first_job</code></span>和<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>my_second_job</code></span>。</p><p style=\"text-align: left;\"><code><strong>（5）jobs.&lt;job_id&gt;.needs</strong></code></p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>needs</code></span>字段指定当前任务的依赖关系，即运行顺序。</p><blockquote style=\"text-align: left;\">jobs: job1: job2: needs: job1 job3: needs: [job1, job2]</blockquote><p style=\"text-align: left;\">上面代码中，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job1</code></span>必须先于<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job2</code></span>完成，而<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job3</code></span>等待<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job1</code></span>和<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job2</code></span>的完成才能运行。因此，这个 workflow 的运行顺序依次为：<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job1</code></span>、<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job2</code></span>、<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>job3</code></span>。</p><p style=\"text-align: left;\"><code><strong>（6）jobs.&lt;job_id&gt;.runs-on</strong></code></p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>runs-on</code></span>字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p><blockquote style=\"text-align: left;\">ubuntu-latest，ubuntu-18.04或ubuntu-16.04windows-latest，windows-2019或windows-2016macOS-latest或macOS-10.14</blockquote><p style=\"text-align: left;\">下面代码指定虚拟机环境为<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>ubuntu-18.04</code></span>。</p><blockquote style=\"text-align: left;\">runs-on: ubuntu-18.04</blockquote><p style=\"text-align: left;\"><code><strong>（7）jobs.&lt;job_id&gt;.steps</strong></code></p><p style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>steps</code></span>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p><blockquote style=\"text-align: left;\">jobs.&lt;job_id&gt;.steps.name：步骤名称。jobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。jobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。</blockquote><p style=\"text-align: left;\">下面是一个完整的 workflow 文件的范例。</p><blockquote style=\"text-align: left;\">name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</blockquote><p style=\"text-align: left;\">上面代码中，<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>steps</code></span>字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p><h2 style=\"text-align: left;\">四、实例：React 项目发布到 GitHub Pages</h2><p style=\"text-align: left;\">下面是一个实例，通过 GitHub Actions 构建一个 React 项目，并发布到 GitHub Pages。最终代码都在<a href=\"https://github.com/ruanyf/github-actions-demo\" target=\"_blank\" style=\"text-align: left;\">这个仓库</a>里面，发布后的参考网址为<a href=\"https://ruanyf.github.io/github-actions-demo\" target=\"_blank\" style=\"text-align: left;\">ruanyf.github.io/github-actions-demo</a>。</p><p style=\"text-align: left;\">第一步，GitHub Actions 目前还处在测试阶段，需要到<a href=\"https://github.com/features/actions/signup/\" target=\"_blank\" style=\"text-align: left;\">这个网址</a>申请测试资格。申请以后，可能需要几天才能通过。据说，2019年11月就会放开。</p><p style=\"text-align: left;\">获得资格后，仓库顶部的菜单会出现<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>Actions</code></span>一项。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091106.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><p style=\"text-align: left;\">第二步，这个示例需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照<a href=\"https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line\" target=\"_blank\" style=\"text-align: left;\">官方文档</a>，生成一个密钥。然后，将这个密钥储存到当前仓库的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>Settings/Secrets</code></span>里面。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091107.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><p style=\"text-align: left;\">上图是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>ACCESS_TOKEN</code></span>。如果你不用这个名字，后面脚本里的变量名也要跟着改。</p><p style=\"text-align: left;\">第三步，本地计算机使用<a href=\"https://github.com/facebook/create-react-app\" target=\"_blank\" style=\"text-align: left;\"><span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>create-react-app</code></span></a>，生成一个标准的 React 应用。</p><blockquote style=\"text-align: left;\">$ npx create-react-app github-actions-demo $ cd github-actions-demo</blockquote><p style=\"text-align: left;\">然后，打开<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>package.json</code></span>文件，加一个<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>homepage</code></span>字段，表示该应用发布后的根目录（参见<a href=\"https://create-react-app.dev/docs/deployment#building-for-relative-paths\" target=\"_blank\" style=\"text-align: left;\">官方文档</a>）。</p><blockquote style=\"text-align: left;\">\"homepage\": \"https://[username].github.io/github-actions-demo\",</blockquote><p style=\"text-align: left;\">上面代码中，将<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>[username]</code></span>替换成你的 GitHub 用户名，参见<a href=\"https://github.com/ruanyf/github-actions-demo/blob/master/package.json#L10\" target=\"_blank\" style=\"text-align: left;\">范例</a>。</p><p style=\"text-align: left;\">第四步，在这个仓库的<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>.github/workflows</code></span>目录，生成一个 workflow 文件，名字可以随便取，这个示例是<span style=\"color: rgb(17, 17, 17); background-color: pink;\"><code>ci.yml</code></span>。</p><p style=\"text-align: left;\">我们选用一个别人已经写好的 action：<a href=\"https://github.com/marketplace/actions/deploy-to-github-pages\" target=\"_blank\" style=\"text-align: left;\">JamesIves/github-pages-deploy-action</a>，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看<a href=\"https://github.com/ruanyf/github-actions-demo/blob/master/.github/workflows/ci.yml\" target=\"_blank\" style=\"text-align: left;\">源码</a>）。</p><blockquote style=\"text-align: left;\">name: GitHub Actions Build and Deploy Demo on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} BRANCH: gh-pages FOLDER: build BUILD_SCRIPT: npm install &amp;&amp; npm run build</blockquote><p style=\"text-align: left;\">上面这个 workflow 文件的要点如下。</p><blockquote style=\"text-align: left;\">整个流程在master分支发生push事件时触发。只有一个job，运行在虚拟机环境ubuntu-latest。第一步是获取源码，使用的 action 是actions/checkout。第二步是构建和部署，使用的 action 是JamesIves/github-pages-deploy-action。第二步需要四个环境变量，分别为 GitHub 密钥、发布分支、构建成果所在目录、构建脚本。其中，只有 GitHub 密钥是秘密变量，需要写在双括号里面，其他三个都可以直接写在文件里。</blockquote><p style=\"text-align: left;\">第五步，保存上面的文件后，将整个仓库推送到 GitHub。</p><p style=\"text-align: left;\">GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看<a href=\"https://github.com/ruanyf/github-actions-demo/commit/24fbf6a875351297f31434fd44bc3146accf9e59/checks\" target=\"_blank\" style=\"text-align: left;\">运行日志</a>，日志默认保存30天。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091108.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><p style=\"text-align: left;\">等到 workflow 运行结束，访问 <a href=\"https://ruanyf.github.io/github-actions-demo/\" target=\"_blank\" style=\"text-align: left;\">GitHub Page</a>，会看到构建成果已经发上网了。</p><p style=\"text-align: left;\"><img src=\"https://www.wangbase.com/blogimg/asset/201909/bg2019091109.jpg\" alt=\"\" data-href=\"\" style=\"\"></p><p style=\"text-align: left;\">以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。</p><h2 style=\"text-align: left;\">五、参考链接</h2><ul style=\"text-align: left;\"><li style=\"text-align: left;\"><a href=\"https://help.github.com/en/categories/automating-your-workflow-with-github-actions\" target=\"_blank\" style=\"text-align: left;\">GitHub Pages 官方文档</a></li><li style=\"text-align: left;\"><a href=\"https://lukeboyle.com/blog-posts/2019/08/github-actions-for-web-apps/\" target=\"_blank\" style=\"text-align: left;\">Github Actions for web apps</a>, Luke Boyle</li><li style=\"text-align: left;\"><a href=\"https://medium.com/@adam.zolyak/my-first-week-with-github-actions-5d92de4c4851\" target=\"_blank\" style=\"text-align: left;\">My First Week With GitHub Actions</a>, Adam Zolyak</li></ul><p style=\"text-align: left;\">（完）</p><p style=\"text-align: left;\"><br></p>","art_author":"yellow star","art_createtime":"2022-11-22T03:41:39.000Z","art_tags":4},{"id":95,"art_title":"做了css媒体查询，自适应屏幕大小","art_content":"<p>做了两种适配，1200px，800px📢📢📢</p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1669011016533.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1669011093219.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1669011134210.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-21T06:12:21.000Z","art_tags":1},{"id":94,"art_title":"JS格式化金钱（千分位加逗号、保留两位小数）","art_content":"<p><span style=\"color: rgba(0, 0, 0, 0.75); background-color: rgb(255, 255, 255); font-size: 16px;\">直接使用JS内置 API （</span>toLocaleString<span style=\"color: rgba(0, 0, 0, 0.75); background-color: rgb(255, 255, 255); font-size: 16px;\">），实现金额的格式化</span></p><pre><code class=\"language-javascript\">(999999999).toLocaleString(); // 999,999,999\r\n\r\n// 还可以加参数，进行更优雅的做法\r\nconst options = {\r\n  style: 'currency',\r\n  currency: 'CNY',\r\n};\r\n(999999).toLocaleString('zh-CN', options); // ¥999,999.00\r\n</code></pre><pre><code class=\"language-javascript\">const options = {\r\n  style: 'percent',\r\n  currency: 'CNY',\r\n};\r\n(1).toLocaleString('zh-CN', options); // 100%\r\n</code></pre><blockquote>toLocaleString 可以接收两个可选参数：locales 和 options，而且这个 api在各大浏览器通用不存在兼容问题并且这个 api 不止存在 Number 的原型上，Array、Object、Date 原型上都有这个 api，并且格式化出来的值可以根据我们传入的参数出现各种结果，关于toLocaleString的参数及用法在MDN（Number.prototype.toLocaleString()）中有详细的用法，感兴趣的小伙伴可以深入了解一下</blockquote>","art_author":"yellow star","art_createtime":"2022-11-17T07:47:15.000Z","art_tags":7},{"id":93,"art_title":"React 搭建后台项目","art_content":"<h2>创建一个项目</h2><h3><span style=\"color: rgb(0, 0, 0);\">官网推荐的工具链</span></h3><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">React 团队主要推荐这些解决方案：</span></p><ul><li><span style=\"color: rgb(26, 26, 26);\">如果你是在</span><strong>学习 React</strong><span style=\"color: rgb(26, 26, 26);\"> 或</span><strong>创建一个新的</strong>单页<strong>应用</strong><span style=\"color: rgb(26, 26, 26);\">，请使用 </span>Create React App<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在</span><strong>用 Node.js 构建服务端渲染的网站</strong><span style=\"color: rgb(26, 26, 26);\">，试试 </span>Next.js<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在构建</span><strong>内容主导的静态网站</strong><span style=\"color: rgb(26, 26, 26);\">，试试 </span>Gatsby<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在打造</span><strong>组件库</strong><span style=\"color: rgb(26, 26, 26);\">或</span><strong>将 React 集成到现有代码仓库</strong><span style=\"color: rgb(26, 26, 26);\">，尝试</span>更灵活的工具链<span style=\"color: rgb(26, 26, 26);\">。</span></li></ul><h3><span style=\"color: rgb(0, 0, 0);\">Create React App</span></h3><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\">Create React App</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 是一个用于</span><strong>学习 React</strong><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 的舒适环境，也是用 React 创建</span><strong>新的</strong><a href=\"https://zh-hans.reactjs.org/docs/glossary.html#single-page-application\" target=\"_blank\">单页</a><strong>应用</strong><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">的最佳方式。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 </span><a href=\"https://nodejs.org/en/\" target=\"_blank\">Node &gt;= 14.0.0 和 npm &gt;= 5.6</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">。要创建项目，请执行：</span></p><pre><code >npx create-react-app my-app \ncd my-app \nnpm start\n</code></pre><p><strong>注意</strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">第一行的 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">npx</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 不是拼写错误 —— 它是 </span>npm 5.2+ 附带的 package 运行工具<span style=\"color: rgb(0, 0, 0); font-size: 16px;\">。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 </span><a href=\"https://babeljs.io/\" target=\"_blank\">Babel</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 和 </span><a href=\"https://webpack.js.org/\" target=\"_blank\">webpack</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">，但你无需了解它们的任何细节。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">当你准备好部署到生产环境时，执行 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">npm run build</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 会在 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">build</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 文件夹内生成你应用的优化版本。</span></p><p>项目初始页面：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667288055402-d6851283-8b72-48bb-b4cb-dab40dea6a4b.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p>初始目录结构：</p><pre><code >my-app\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\t\t\t\t\t\t\t\t\t # 不参与编译的资源文件\n│   ├── favicon.ico\n│   ├── index.html\n│   └── manifest.json\n└── src\t\t\t\t\t\t\t\t\t\t\t # 主程序目录\t\t\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    └── serviceWorker.js\n    └── setupTests.js</code></pre><h3>一个模块（页面/组件）的基本代码结构</h3><p>hello.jsx:</p><pre><code >import React, { useState } from 'react'\nimport styles from './index.module.scss'\n\nconst app = () =&gt; {\n  \n  const [data, setData] = useState('hello world')\n  \n  const onChange = () =&gt; {\n    setActiveKey('changed')\n  }\n\n  return (\n    &lt;div className={styles.box} onClick={onChange}&gt;\n  \t\t{data}\n    &lt;/div&gt;\n  )\n}\n\nexport default app\n</code></pre><h2>构建路由 <span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router</span></h2><p>为什么要使用路由？</p><p>传统web开发是每一个请求地址都会请求服务器来进行处理，但是用户有些操作则无需请求服务器，直接页面端修改下逻辑就能达到目的，这种最好使用路由，使用路由时，url也是随着改变的，用户浏览到一个网页时可以直接复制或收藏当前页的url给别人，这种方式对于搜索引擎和用户来说都是友好的。</p><p><br></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router</span></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router是为React（一个用于构建用户界面的 JavaScript 库）设计的一个功能齐全的可以用在客户端和服务端的路由库，它可以在React运行的地方运行，在web上，node.js在服务器上，以及React Native上。</span></p><h3><span style=\"font-size: 16px;\">安装</span></h3><p><span style=\"font-size: 16px;\">在项目目录下，使用npm下载</span></p><pre><code >npm install react-router-dom@6 history@5</code></pre><h3>项目中使用</h3><p><span style=\"font-size: 16px;\">首先创建路由：选定一个入口文件，并引入 </span><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">BrowserRouter 组件包裹整个应用；添加路由、嵌套路由、重定向；</span></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">入口文件：</span></p><pre><code >import React, { } from 'react'\nimport './App.css'\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route,\n  Navigate\n} from 'react-router-dom'\nimport DefaultLayout from '@/components/Layouts/DefaultLayout'\nimport routesData from './router/routes'\nimport Login from './pages/Login'\n\nfunction App () {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;Router&gt;\n        &lt;Routes&gt;\n          {/* 首次进入页面是重定向到/home路径 */}\n          &lt;Route path=\"/\" element={&lt;Navigate to=\"/home\" /&gt;}&gt;&lt;/Route&gt;\n          &lt;Route element={&lt;DefaultLayout /&gt;}&gt;\n            {routesData.map((item: any, index: number) =&gt; {\n              return (\n                &lt;Route\n                  path={item.path}\n                  key={index}\n                  element={&lt;item.component /&gt;}\n                &gt;&lt;/Route&gt;\n              )\n            })}\n          &lt;/Route&gt;\n          &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;div className=\"noFound\"&gt;Not Found&lt;/div&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Router&gt;\n    &lt;/div&gt;\n  )\n}\nexport default App</code></pre><p><span style=\"font-size: 16px;\">路由之间的跳转</span></p><p><span style=\"font-size: 16px;\">方法一：</span></p><pre><code >import { Link } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;div&gt;\n        &lt;Link to=\"/home\"&gt;home&lt;/Link&gt;\n        &lt;Link to=\"/login\"&gt;login&lt;/Link&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><span style=\"font-size: 16px;\">方法二：</span></p><pre><code >import { useNavigate } from \"react-router-dom\";\n\nexport default function App() {\n  const navigate = useNavigate()\n  return (\n    &lt;div&gt;\n        &lt;button onClick={()=&gt;navigate('/home')}&gt;home&lt;/button&gt;\n        &lt;button onClick={()=&gt;navigate('/login')}&gt;login&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><h2>配置Antd组件库</h2><p><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">antd</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</span></p><p style=\"text-align: left;\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667289069588-daffe4f2-9fbc-4a09-886d-daa1658ebade.png\" alt=\"\" data-href=\"\" style=\"\"></p><p><span style=\"color: rgba(0, 0, 0, 0.85);\">✨</span><strong> 特性：</strong></p><ul><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🌈 提炼自企业级中后台产品的交互语言和视觉风格。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">📦 开箱即用的高质量 React 组件。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🛡 使用 TypeScript 开发，提供完整的类型定义文件。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">⚙️ 全链路开发和设计工具体系。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🌍 数十个国际化语言支持。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🎨 深入每个细节的主题定制能力。</span></li></ul><p><br></p><p>安装使用</p><pre><code >npm install antd</code></pre><p>使用一个按钮组件</p><pre><code >import React from 'react';\nimport { Button } from 'antd';\nimport './App.css';\n\nconst App = () =&gt; (\n  &lt;div className=\"App\"&gt;\n    &lt;Button type=\"primary\"&gt;Button&lt;/Button&gt;\n  &lt;/div&gt;\n);\n\nexport default App;</code></pre><p>导入样式，<span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">修改 </span><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">src/App.css</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">，在文件顶部引入 </span><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">antd/dist/antd.css</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">。</span></p><pre><code >@import '~antd/dist/antd.css';</code></pre><p>全局配置中文语言环境，默认情况下，antd语言是英文，需要手动修改回中文环境</p><p>index.js:</p><pre><code >import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\nimport { ConfigProvider } from 'antd'\nimport zhCN from 'antd/es/locale/zh_CN'\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n)\nroot.render(\n  // ConfigProvider antd全局配置中文语言环境\n  &lt;ConfigProvider locale={zhCN}&gt;\n    &lt;App /&gt;\n  &lt;/ConfigProvider&gt;\n)\n\nreportWebVitals()\n</code></pre><h2>封装全局组件</h2><p>在src/components路径下创建全局组件,解决重复利用，开发代码基本和页面开发一致，</p><p>举个例子：</p><pre><code >import styles from './index.module.scss'\nimport React, { } from 'react'\n\nconst App = (props) =&gt; {\n  const { title = '段落标题', children, style } = props\n  return (\n    &lt;div className={styles.box} style={style}&gt;\n      &lt;div className={styles.header}&gt;&lt;div className={styles.headerItem}&gt;{title}&lt;/div&gt;&lt;/div&gt;\n      &lt;div className={styles.content}&gt;{ children}&lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\nexport default App\n</code></pre><p>调用</p><pre><code >import Plates from '@/components/Plates'\n\n...\n\n&lt;Plates title={'费用详情'}&gt;\n  &lt;Table\n    columns={columns}\n    dataSource={data}\n    pagination={false}\n    bordered\n    size={'small'}\n  /&gt;\n&lt;/Plates&gt;</code></pre><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668648752246-771519a6-4446-48b8-a095-848e711a9bcc.png\" alt=\"\" data-href=\"\" style=\"\"/></p><h2>二次封装请求函数</h2><h3><span style=\"color: rgb(51, 51, 51);\">Axios 是什么?</span></h3><p>Axios 是一个基于 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fpromise-basics\" target=\"_blank\">promise</a> 网络请求库，作用于<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2F\" target=\"_blank\">node.js</a> 和浏览器中。 它是 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.lullabot.com%2Farticles%2Fwhat-is-an-isomorphic-application\" target=\"_blank\">isomorphic</a> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><p><strong>特性</strong></p><ul><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">从浏览器中创建 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">XMLHttpRequests</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">从 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">node.js</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> 创建 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">http</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">请求</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">支持 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">Promise</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> API</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">拦截请求和响应</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">转换请求数据和响应数据</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">取消请求</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">自动转换</span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"> JSON</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> 数据</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">客户端支持防御</span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">XSRF</span></li></ul><h3><span style=\"background-color: rgb(255, 245, 245);\">基本使用</span></h3><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">安装</span></p><pre><code >npm install axios</code></pre><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">导入</span></p><pre><code >import axios from 'axios'</code></pre><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">发送请求</span></p><pre><code >axios({        \n  url:'xxx',    // 设置请求的地址\n  method:\"GET\", // 设置请求方法\n  params:{      // get请求使用params进行参数凭借,如果是post请求用data\n    type: '',\n    page: 1\n  }\n}).then(res =&gt; {  \n  // res为后端返回的数据\n  console.log(res);   \n})\n</code></pre><h3><span style=\"color: rgb(51, 51, 51);\">为什么要封装</span></h3><p>axios 的 API 很友好，完全可以很轻松地在项目中直接使用。</p><p>不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍，这种重复劳动不仅浪费时间，而且让代码变得冗余增加，难以维护。为了提高代码质量，所以应该在项目中二次封装 axios 再使用。</p><h3>如何封装</h3><ul><li>封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间......</li><li>设置接口请求前缀：根据开发、测试、预发、生产环境的不同，前缀需要加以区分；</li><li>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(比如：用户信息)；</li><li>状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好；</li><li>请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便</li><li>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</li><li>响应拦截器： 这块就是根据 后端返回来的状态码判定执行不同业务</li></ul><p>代码实例：</p><pre><code >import axios from 'axios'\nimport { message, notification } from 'antd'\n\nconst openNotification = (msg) =&gt; {\n  notification.error({\n    message: '请联系管理员',\n    description: msg\n  })\n}\n\nconst showStatus = (status) =&gt; {\n  let message = ''\n  switch (status) {\n    case 400:\n      message = '请求错误(400)'\n      break\n    case 401:\n      message = '未授权，请重新登录(401)'\n      break\n    case 402:\n      message = '拒绝访问(402)'\n      break\n    case 404:\n      message = '请求出错(404)'\n      break\n    case 408:\n      message = '请求超时(408)'\n      break\n    case 500:\n      message = '服务器错误(500)'\n      break\n    case 501:\n      message = '服务未实现(501)'\n      break\n    case 502:\n      message = '网络错误(502)'\n      break\n    case 503:\n      message = '服务不可用(503)'\n      break\n    case 504:\n      message = '网络超时(504)'\n      break\n    case 505:\n      message = 'HTTP版本不受支持(505)'\n      break\n    default:\n      message = `连接出错(${status})!`\n  }\n  return `${message}，请检查网络或联系管理员！`\n}\n\nconst service = axios.create({\n  // 联调\n\n  headers: {\n    get: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    },\n    post: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    }\n  },\n  // 是否跨站点访问控制请求\n  withCredentials: false,\n  timeout: 30000,\n  validateStatus () {\n    // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常\n    return true\n  }\n})\n\n// 请求拦截器\nservice.interceptors.request.use(\n  config =&gt; {\n    // 将 token 添加到请求头\n    const token = localStorage.getItem('token')\n    token && (config.headers.token = token)\n    return config\n  },\n  (err) =&gt; {\n    err.message = '服务器异常，请联系管理员！'\n    // 错误抛到业务代码\n    return Promise.reject(err)\n  }\n)\n\n// 响应拦截器\nservice.interceptors.response.use(\n  response =&gt; {\n    const status = response.status\n    let msg = ''\n    if ((status &lt; 200) || (status &gt;= 300 && status !== 401 && status !== 500)) {\n      // 处理http错误，抛到业务代码\n      msg = showStatus(status)\n      openNotification(msg)\n      if (typeof response.data === 'string') {\n        response.data = { msg }\n      } else {\n        response.data.msg = msg\n      }\n      return response\n    } else if (status === 200) {\n      if (!response.data.success) {\n        message.error(response.data.message)\n      }\n      return response.data\n    } else if (status === 500) {\n      msg = showStatus(status)\n      openNotification(msg)\n      response.data = { msg }\n      //   router.replace({name:'exception',query:{type:500}})\n      return response\n    }\n  },\n  (err) =&gt; {\n    err.message = '请求超时或服务器异常，请检查网络或联系管理员！'\n    openNotification('请求超时或服务器异常，请检查网络或联系管理员！')\n    // return Promise.reject(err)\n  }\n)\n\nexport default service\n</code></pre><h2>CSS Modules + node-sass</h2><h3>什么是CSS Modules</h3><p><span style=\"color: rgb(10, 10, 35);\">所有的类名和动画名称默认都有各自的作用域的 CSS 文件。</span></p><p><span style=\"color: rgb(10, 10, 35);\">所以 CSS Modules 既不是官方标准，也不是浏览器的特性，而是在构建步骤（例如使用 Webpack 或 Browserify）中对 CSS 类名和选择器限定作用域的一种方式（类似于命名空间）。</span></p><h3>node-sass</h3><p><span style=\"color: rgb(10, 10, 35);\">node sass是一个库，它将Node.js绑定到LibSass【流行样式表预处理器Sass的C版本】，它允许用户以令人难以置信的速度将【.scss】文件本地编译为css，并通过连接中间件自动编译。</span></p><h3><span style=\"color: rgb(33, 37, 41);\">为什么使用scss，而不是传统的css</span></h3><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">使用 scss 可以编写清晰、无冗余、语义化的 css。</span></p><p><strong>变量</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">是 scss 提供的最基本的工具。通过变量可以让独立的 css 值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。</span></p><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">同样基础的是 scss 的 </span><strong>嵌套机制</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">。嵌套允许css规则内嵌套css规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。scss同时提供了特殊的</span><strong>父选择器标识符 &</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\"> ，通过它可以构造出更高效的嵌套。</span></p><p><strong>混合器</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">允许用户编写语义化样式的同时避免视觉层面上样式的重复。使用混合器减少重复，使用混合器让你的css变得更加可维护和语义化。</span></p><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">与混合器相辅相成的</span><strong>选择器继承</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。</span></p><p><strong>样式导入</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">，scss 的另一个重要特性。通过样式导入可以把分散在多个sass文件中的内容合并生成到一个css文件，避免了项目中有大量的css文件通过原生的css @import带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。</span></p><h2>状态管理工具 mobx</h2><p><em>简单、可扩展的状态管理</em></p><h3><span style=\"color: rgb(51, 51, 51);\">Mobx工作流程</span></h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668651326688-11627ad0-e87a-463e-82a5-09d5445f86a4.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</span></p><h2><span style=\"font-size: 14px;\">ESlint代码规范</span></h2><p><a href=\"https://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy\" target=\"\">https://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy</a></p><h2>项目优化</h2><h4><span style=\"font-size: 14px;\">绝对路径 @ </span></h4><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">使用</span><a href=\"https://github.com/timarney/react-app-rewired\" target=\"_blank\">react-app-rewired</a><span style=\"font-size: 14px;\">来对react-scripts进行hack。</span></p><pre><code >$ yarn add -D react-app-rewired //或 $ npm install react-app-rewired --save-dev</code></pre><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">然后修改</span><strong>package.json</strong><span style=\"font-size: 14px;\">，将</span><strong>start</strong><span style=\"font-size: 14px;\">、</span><strong>build</strong><span style=\"font-size: 14px;\">、</span><strong>test</strong><span style=\"font-size: 14px;\">三个命令由react-scripts换成</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">react-app-rewired</span></p><pre><code >\"scripts\": { \n  \t\"start\": \"react-app-rewired start\", \n    \"build\": \"react-app-rewired build\", \n    \"test\": \"react-app-rewired test\", \n    \"eject\": \"react-scripts eject\" \n},</code></pre><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">在根目录下创建</span><strong>config-overrides.js</strong><span style=\"font-size: 14px;\">：</span></p><pre><code >const path = require('path'); \nconst rootPath = path.resolve(__dirname, 'src'); \n\nmodule.exports = { \n  webpack: (config) =&gt; { \n    config.resolve.alias['@'] = rootPath; \n    return config; \n  }, \n}</code></pre><p style=\"text-align: left;\"><strong>注意：</strong><span style=\"font-size: 14px;\">修改完文件后，</span><strong>必须先重启项目</strong><span style=\"font-size: 14px;\">，然后再使用绝对路径，</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">@</span><span style=\"font-size: 14px;\">代表的就是</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">根目录/src</span><span style=\"font-size: 14px;\"> 。</span></p><h4>helper.js</h4><h4>页面跳转过渡状态</h4><p><br></p><p><br></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-17T03:04:38.000Z","art_tags":4},{"id":92,"art_title":"vercel免费分配二级域名，并部署应用🚀","art_content":"<p style=\"text-align: left;\">在 <a href=\"https://vercel.com/\" target=\"_blank\">https://vercel.com/</a> 中可以免费部署你的nextjs项目或者个人网站；它是通过关联GitHub仓库实现自动化部署，并且会分配一个免费的二级域名；nice！</p><p style=\"text-align: center;\"><img src=\"http://124.223.185.220:3000/getImage?img=image-1668503171393.png\" alt=\"\" data-href=\"\" style=\"\"></p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1668503396271.png\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-11-15T09:10:29.000Z","art_tags":4},{"id":90,"art_title":"增加了tag功能📢","art_content":"<p>tag！！！</p><p>tag！！！</p><p>tag！！！</p>","art_author":"yellow star","art_createtime":"2022-11-15T08:23:36.000Z","art_tags":8},{"id":86,"art_title":"【收藏】发现一个机场测速平台👨‍💻","art_content":"<p>节点再也不担心翻车了📢</p><p> <a href=\"https://www.duyaoss.com/\" target=\"_blank\">https://www.duyaoss.com/</a> </p>","art_author":"yellow star","art_createtime":"2022-11-15T07:16:51.000Z","art_tags":null},{"id":85,"art_title":"【CSS】display:grid; 布局","art_content":"<p>属性好多 好难，api参考 <a href=\"https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a> </p><p>demo查看 &nbsp;<a href=\"/gridauto\" target=\"_blank\">grid-demo</a> </p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1668416165008.png\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-11-14T08:56:16.000Z","art_tags":null},{"id":84,"art_title":"Web Sockets、Web Worker 和 Service Worker 之间的区别","art_content":"<p style=\"text-align: start;\">Web Sockets、Web Workers、Service Workers……这些术语您可能已经阅读或无意中听到。也许不是全部，但可能至少其中之一。即使您对前端开发有很好的了解，您也很有可能需要查找它们的含义。或者，也许你像我一样，时不时地把它们混在一起。这些术语看起来和听起来都非常相似，很容易让它们混淆。</p><p style=\"text-align: start;\">那么，让我们将它们分解在一起，区分 Web Sockets、Web Workers 和 Service Worker。不是从本质上讲，我们会深入研究并获得每个人的实践经验——更像是下次你需要复习时书签的小<s>帮手</s>。</p><h3 style=\"text-align: start;\">快速参考</h3><p style=\"text-align: start;\">我们将从高级概述开始，以便进行快速比较和对比。</p><p style=\"text-align: start;\"><br></p><table style=\"width: auto;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>特征</strong></th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>这是什么</strong></th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>Web Socket</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">在浏览器和服务器之间建立开放且持久的双向连接，以通过事件触发的单个连接发送和接收消息。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>Web Worker</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">允许脚本在单独的线程中在后台运行，以防止脚本在主线程上相互阻塞。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>Service Worker</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">一种 Web Worker，它创建一个后台服务，该服务充当中间件，用于处理浏览器和服务器之间的网络请求，即使在离线情况下也是如此。</td></tr></tbody></table><h3 style=\"text-align: start;\">网络套接字</h3><p style=\"text-align: start;\">Web Socket 是一种双向通信协议。把这想象成你和你的朋友之间正在进行的通话，除非你们中的一个人决定挂断，否则它不会结束。唯一的区别是你是浏览器，你的朋友是服务器。客户端向服务器发送请求，服务器通过处理客户端的请求进行响应，反之亦然。</p><p style=\"text-align: start;\"><img src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/10/s_946F1219BF833C90E2A9F5AFF16573F7EDD61CBB9CE5FD38969485809A5FD1A8_1666620506067_YpooKVs9-.png?resize=500%2C500&amp;ssl=1\" alt=\"分别代表浏览器和服务器的两名女性的插图。 它们之间的箭头显示了活动连接中的通信流程。\" data-href=\"\" style=\"height: auto !important;\"></p><p style=\"text-align: start;\">通信基于事件。建立一个<code>WebSocket</code>对象并连接到服务器，服务器之间的消息触发发送和接收它们的事件。</p><p style=\"text-align: start;\">这意味着当建立初始连接时，我们有一个客户端-服务器通信，其中一个连接被启动并保持活动状态，直到客户端或服务器选择通过发送一个<code>CloseEvent</code>. 这使得 Web Sockets 非常适合需要在客户端和服务器之间进行连续和直接通信的应用程序。我见过的大多数定义都将聊天应用程序称为常见用例——您键入一条消息，将其发送到服务器，触发一个事件，然后服务器用数据进行响应，而无需一遍又一遍地 ping 服务器。</p><p style=\"text-align: start;\"><strong>考虑这种情况</strong>：您正在出门，并决定打开 Google 地图。您可能已经知道 Google 地图的工作原理，但如果您不知道，它会在您连接到应用程序后自动找到您的位置，并随时随地跟踪它。只要此连接处于活动状态，它就会使用实时数据传输来跟踪您的位置。这是一个 Web Socket，它在浏览器和服务器之间建立持久的双向对话，以使数据保持最新。具有实时比分的体育应用程序也可以通过这种方式使用 Web Sockets。</p><p style=\"text-align: start;\">Web Sockets 和 Web Worker（以及我们将看到的 Service Worker）之间的最大区别在于它们可以直接访问 DOM。Web Worker（和 Service Worker）在不同的线程上运行，而 Web Sockets 是主线程的一部分，这使它们能够操作 DOM。</p><p style=\"text-align: start;\">有一些工具和服务可以帮助建立和维护 Web Socket 连接，包括：<a href=\"https://socketcluster.io/\" target=\"\">SocketCluster</a>、<a href=\"https://www.asyncapi.com/\" target=\"\">AsyncAPI</a>、<a href=\"https://github.com/ninenines/cowboy\" target=\"\">cowboy</a>、<a href=\"https://websocketking.com/\" target=\"\">WebSocket King</a>、<a href=\"https://channels.readthedocs.io/en/stable/index.html\" target=\"\">Channels</a>和<a href=\"https://pkg.go.dev/github.com/gorilla/websocket\" target=\"\">Gorilla WebSocket</a>。MDN 有一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API#tools\" target=\"\">包含其他服务的运行列表</a>。</p><h4 style=\"text-align: start;\">更多 Web 套接字信息</h4><ul style=\"text-align: start;\"><li><a href=\"https://web.dev/websockets-basics/\" target=\"\">介绍 WebSockets – 将 Sockets 引入 Web</a> (web.dev)</li><li><a href=\"https://css-tricks.com/thinking-about-power-usage-and-websites/\" target=\"\">考虑用电和网站</a>(Chris Coyier)</li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\" target=\"\">WebSocket API</a> (MDN 文档)</li><li><a href=\"https://caniuse.com/websockets\" target=\"\">最新的浏览器支持</a>(Caniuse)</li></ul><h3 style=\"text-align: start;\"></h3><h3 style=\"text-align: start;\">Web Workers</h3><p style=\"text-align: start;\">考虑一个场景，您需要执行一堆复杂的计算，同时对 DOM 进行更改。JavaScript 是一种单线程应用程序，运行多个脚本可能会破坏您尝试更改的用户界面以及正在执行的复杂计算。</p><p style=\"text-align: start;\">这就是 Web Workers 发挥作用的地方。</p><p style=\"text-align: start;\">Web Worker 允许脚本在不同线程的后台运行，以防止脚本在主线程上相互阻塞。这使得它们非常适合提高需要密集操作的应用程序的性能，因为这些操作可以在后台在单独的线程上执行，而不会影响用户界面的渲染。但是它们在访问 DOM 方面并不是那么出色，因为与 Web Sockets 不同的是，Web Worker 在其自己的线程中运行在主线程之外。</p><p style=\"text-align: start;\">Web Worker 是一个对象，它通过使用<code>Worker</code>对象来执行任务来执行脚本文件。当我们谈论工人时，他们往往属于以下三种类型之一：</p><ul style=\"text-align: start;\"><li><strong>专用工人：</strong>专用工人只能通过调用它的脚本来实现。它仍然执行典型 Web Worker 的任务，例如它的多线程脚本。</li><li><strong>共享工作者：</strong>共享工作者与专用工作者相反。它可以被多个脚本访问，并且实际上可以执行 web worker 执行的任何任务，只要它们与 worker 存在于同一个域中。</li><li><strong>Service Worker：</strong> Service Worker 充当应用程序、浏览器和服务器之间的网络代理，即使在网络离线时也允许脚本运行。我们将在下一节讨论这个问题。</li></ul><h4 style=\"text-align: start;\">More Web Workers information</h4><ul style=\"text-align: start;\"><li><a href=\"https://css-tricks.com/off-the-main-thread/\" target=\"\">“脱离主线”</a>（克里斯·科伊尔）</li><li><a href=\"https://css-tricks.com/the-state-of-web-workers-in-2021/\" target=\"\">2021 年 Web 工作者的状态</a>(Chris Coyier)</li><li><a href=\"https://zapier.com/engineering/intro-to-web-workers/\" target=\"\">Web Workers 简介</a>(Zapier)</li><li> Web Workers<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\" target=\"\"> API</a>（MDN 文档）</li><li><a href=\"https://caniuse.com/webworkers\" target=\"\">最新的浏览器支持</a>(Caniuse)</li></ul><h3 style=\"text-align: start;\">Service Workers</h3><p style=\"text-align: start;\">作为开发人员，有些事情我们无法控制，其中之一就是用户的网络连接。无论用户连接到什么网络，它就是什么。我们只能尽最大努力优化我们的应用程序，以便它们在碰巧使用的任何连接上都能发挥最佳性能。</p><p style=\"text-align: start;\">Service Worker 是我们可以做的事情之一，以逐步提高应用程序的性能。服务工作者位于应用程序、浏览器和服务器之间，提供在后台运行在单独线程上的安全连接，这要归功于——你猜对了——Web Workers。正如我们在上一节中了解到的，Service Worker 是三种类型的 Web Worker 之一。</p><p style=\"text-align: start;\">那么，为什么你需要一个<span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">service worker</span>坐在你的应用程序和用户的浏览器之间呢？同样，我们无法控制用户的网络连接。假设连接由于某种未知原因而中断。这会破坏浏览器和服务器之间的通信，阻止数据来回传递。服务工作者维护连接，充当能够拦截请求和执行任务的异步代理——即使在网络连接丢失之后也是如此。</p><p style=\"text-align: start;\"><img src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/10/s_946F1219BF833C90E2A9F5AFF16573F7EDD61CBB9CE5FD38969485809A5FD1A8_1666620745315_fmg2Vf-3x.png?resize=500%2C500&amp;ssl=1\" alt=\"一个标记为 Service Worker 的齿轮图标位于标记为客户端的浏览器图标和标记为服务器的云图标之间。\" data-href=\"\" style=\"height: auto !important;\"></p><p style=\"text-align: start;\">这是通常被称为<a href=\"https://css-tricks.com/instant-loading-building-offline-first-progressive-web-apps/\" target=\"\">“离线优先”开发</a>的主要驱动力。我们可以将资产存储在本地缓存而不是网络中，在用户离线时提供关键信息，预取内容以便在用户需要时准备好，并提供回退以响应网络错误。它们是完全异步的，但与 Web Socket 不同，它们无法访问 DOM，因为它们在自己的线程上运行。</p><p style=\"text-align: start;\">关于 Service Workers 要了解的另一件大事是它们拦截来自您的应用程序的每一个请求和响应。因此，它们具有一些安全隐患，最值得注意的是它们遵循同源策略。因此，这意味着没有从 CDN 或第三方服务运行服务工作者。它们还需要安全的 HTTPS 连接，这意味着您需要 SSL 证书才能运行它们。</p><h4 style=\"text-align: start;\">更多服务工作者信息</h4><ul style=\"text-align: start;\"><li><a href=\"https://css-tricks.com/add-a-service-worker-to-your-site/\" target=\"\">将 Service Worker 添加到您的站点</a>(Chris Ferdinadi)</li><li><a href=\"https://developer.chrome.com/docs/workbox/service-worker-overview/\" target=\"\">Service Worker 概述</a>（Chrome 开发人员）</li><li><a href=\"https://philipwalton.com/articles/smaller-html-payloads-with-service-workers/\" target=\"\">使用 Service Worker 的更小的 HTML 有效负载</a>(Philip Walton)</li><li><a href=\"https://serviceworke.rs/\" target=\"\">服务工作者手册</a>(Mozilla)</li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" target=\"\">服务工作者 API</a>（MDN 文档）</li><li><a href=\"https://caniuse.com/serviceworkers\" target=\"\">最新的浏览器支持</a>(Caniuse)</li></ul><h3 style=\"text-align: start;\">包起来</h3><p style=\"text-align: start;\">这是对 Web Sockets、Web Worker 和 Service Worker 之间差异（和相似之处）的超高级解释。同样，术语和概念非常相似，可以将它们混为一谈，但希望这能让您更好地了解如何区分它们。</p><p style=\"text-align: start;\">我们从一个快速参考表开始。这是同样的事情，但稍微扩大以进行更深入的比较。</p><p style=\"text-align: start;\"><br></p><table style=\"width: auto;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>特征</strong></th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>这是什么</strong></th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>多线程？</strong></th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>HTTPS？</strong></th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\"><strong>DOM 访问？</strong></th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>网络套接字</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">在浏览器和服务器之间建立开放且持久的双向连接，以通过事件触发的单个连接发送和接收消息。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">在主线程上运行</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">不需要</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">是的</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>Web Worker</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">允许脚本在单独的线程中在后台运行，以防止脚本在主线程上相互阻塞。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">在单独的线程上运行</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">必需的</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">不</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><strong>Service Worker</strong></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">一种 Web Worker，它创建一个后台服务，该服务充当中间件，用于处理浏览器和服务器之间的网络请求，即使在离线情况下也是如此。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">在单独的线程上运行</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">必需的</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">不</td></tr></tbody></table><p><br></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-14T06:20:30.000Z","art_tags":null},{"id":83,"art_title":"乱搞","art_content":"<p style=\"text-align: center;\"><img src=\"http://124.223.185.220:3000/getImage?img=35d92b9406f3a90b65fe0035725885b6-1668229110059.jpeg\" alt=\"\" data-href=\"\" style=\"width: 407.00px;height: 407.00px;\"></p><p style=\"text-align: center;\">勒好啊</p>","art_author":"yellow star","art_createtime":"2022-11-12T04:59:23.000Z","art_tags":null},{"id":82,"art_title":"【CSS】渐变魔方","art_content":"<p style=\"text-align: center;\">纯css实现</p><p style=\"text-align: center;\"> <a href=\"/cubeshover\" target=\"_blank\">跳转查看</a> </p><p style=\"text-align: center;\"> <a href=\"https://github.com/Mr-majifu/Cubes-Hover-Effects\" target=\"_blank\">GitHub</a></p><p style=\"text-align: center;\"><img src=\"http://124.223.185.220:3000/getImage?img=image-1668148205530.png\" alt=\"\" data-href=\"\" style=\"\"></p>","art_author":"yellow star","art_createtime":"2022-11-11T06:32:09.000Z","art_tags":null},{"id":81,"art_title":"【CSS】抄了一个好看的navBar","art_content":"<p style=\"text-align: center;\"> 🎈 <a href=\"/navbarcss\" target=\"_blank\">跳转查看</a> &nbsp; </p><p style=\"text-align: center;\"> <a href=\"https://github.com/Mr-majifu/Magic-Menu-Indicator\" target=\"_blank\">Github</a></p><p style=\"text-align: center;\"><img src=\"http://124.223.185.220:3000/getImage?img=image-1668136681098.png\" alt=\"\" data-href=\"\" style=\"\"></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-11T03:18:24.000Z","art_tags":null},{"id":80,"art_title":"【CSS】CSS 中的 :root","art_content":"<h2 style=\"text-align: start;\">:root</h2><p style=\"text-align: start;\"> &nbsp; &nbsp; &nbsp; &nbsp;:root是一个伪类，表示文档根元素，所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本。在:root中声明相当于全局属性，只要当前页面引用了:root segment所在文件，都可以使用var()来引用。</p><pre><code class=\"language-css\">:root {\r\n    --blue: #007bff;\r\n    --indigo: #6610f2;\r\n    --purple: #6f42c1;\r\n    --pink: #e83e8c;\r\n    --red: #dc3545;\r\n    --orange: #fd7e14;\r\n    --yellow: #ffc107;\r\n    --green: #28a745;\r\n    --teal: #20c997;\r\n    --cyan: #17a2b8;\r\n    --white: #fff;\r\n    --gray: #6c757d;\r\n    --gray-dark: #343a40;\r\n    --primary: #007bff;\r\n    --secondary: #6c757d;\r\n    --success: #28a745;\r\n    --info: #17a2b8;\r\n    --warning: #ffc107;\r\n    --danger: #dc3545;\r\n    --light: #f8f9fa;\r\n    --dark: #343a40;\r\n    --breakpoint-xs: 0;\r\n    --breakpoint-sm: 576px;\r\n    --breakpoint-md: 768px;\r\n    --breakpoint-lg: 992px;\r\n    --breakpoint-xl: 1200px;\r\n    --breakpoint-xxl: 1600px;\r\n    --font-family-sans-serif: -apple-system, BlinkMacSystemFont;\r\n    --font-family-monospace: SFMono-Regular, Menlo, Monaco, Consolas;\r\n}</code></pre><h2>var()</h2><p> &nbsp; &nbsp; &nbsp; &nbsp;var()函数可以代替元素中任何属性中的值的任何部分。var()函数不能作为属性名、选择器或者其他除了属性值之外的值。（这样做通常会产生无效的语法或者一个没有关联到变量的值。）</p><pre><code class=\"language-css\">body {\n  background-color: var(--blue);  /* 设置背景颜色为蓝色 */\n}</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-11T03:13:30.000Z","art_tags":null},{"id":78,"art_title":"Gitee Go 实现远程自动部署","art_content":"<p>🚀</p><p><img src=\"http://124.223.185.220:3000/getImage?img=image-1667976257980.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-09T07:37:36.000Z","art_tags":null},{"id":77,"art_title":"【壁纸】测试图片上传bug，最终版","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=xenoblade Homura-1667886321361.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p><p> &nbsp; 继续调节获取时间语句位置，测试通过！</p>","art_author":"yellow star","art_createtime":"2022-11-08T05:46:33.000Z","art_tags":null},{"id":75,"art_title":"【计划】","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=iTab-e7j33o-1667805206433.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p><p> &nbsp; &nbsp;规划一下学习路线：</p><ul><li>TS慢慢学起来</li></ul><ul><li>antd Pro 熟悉起来</li><li>react native 可以学习下</li></ul><p> &nbsp; &nbsp;</p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-07T07:16:26.000Z","art_tags":null},{"id":74,"art_title":"【壁纸】2022/11/07","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=168917-1667793965047.webp\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-11-07T04:06:35.000Z","art_tags":null},{"id":71,"art_title":"【测试】pm2 图片上传功能修复完成📢","art_content":"<p>原项目，获取日期创建文件夹写在了全局，导致项目启动日期只获取一次，故过一天会出现图片上传成功，获取图片失败的bug。</p><p>解决：</p><p>将获取日期写在接口处理函数内，每次创建文件夹都是最新的日期！</p><p><img src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221014151720-1667371174132.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-11-02T06:42:57.000Z","art_tags":null},{"id":70,"art_title":"【屌图】程序员能有什么压力","art_content":"<p>👨‍💻</p><p><img src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221025105908-1667369141159.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-11-02T06:10:15.000Z","art_tags":null},{"id":69,"art_title":"【技术】structuredClone深拷贝","art_content":"<h2>对象转换为 JSON 字符串，再转换为对象</h2><pre><code class=\"language-javascript\">const obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = JSON.parse(JSON.stringify(obj));\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }\n</code></pre><p>JSON.parse(JSON.stringify(obj))可比上面 deepClone 函数简洁多了，但不是好的实践，因为它有以下缺点：</p><ul><li style=\"text-align: left;\">会忽略 undefined</li><li style=\"text-align: left;\">会忽略 symbol</li><li style=\"text-align: left;\">不能序列化函数</li><li style=\"text-align: left;\">不能解决循环引用的对象</li><li style=\"text-align: left;\">如果 data 里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li style=\"text-align: left;\">致命缺陷，性能差</li></ul><h2 style=\"text-align: left;\">structuredClone</h2><p style=\"text-align: left;\"><span style=\"color: rgb(0, 0, 0); font-size: 13px; font-family: &quot;Courier New&quot;;\">structuredClone</span>&nbsp;是 HTML5 一个新的 API，它可以实现深拷贝。</p><pre><code >const obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = structuredClone(obj);\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }</code></pre><p>该方法还支持把原始值中的 transferable objects (en-US) (可转移对象) 转移到新对象，而不是把属性引用拷贝过去。 可转移对象与原始对象分离并附加到新对象;它们不可以在原始对象中访问被访问到。目前要考虑浏览器以及nodejs版本兼容性问题</p>","art_author":"yellow star","art_createtime":"2022-11-02T04:07:59.000Z","art_tags":null},{"id":68,"art_title":"JavaScript将图片转换成Base64字符串的几种方法","art_content":"<h2>FileReader 方法</h2><p>Load the image as blob via <a href=\"https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">XMLHttpRequest</span></a> and use the <a href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">FileReader API</span></a> (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">readAsDataURL()</span></a>) to convert it to a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">dataURL</span></a>:</p><p>通过 XMLHttpRequest 以blob格式请求图像，图像数据返回成功之后， 使用 <a href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">FileReader API</span></a> (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">readAsDataURL()</span></a>) 将其转换为 dataURL：</p><pre><code class=\"language-javascript\">function toDataURL(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.onload = function() {\n    var reader = new FileReader();\n    reader.onloadend = function() {\n      callback(reader.result);\n    }\n    reader.readAsDataURL(xhr.response);\n  };\n  xhr.open('GET', url);\n  xhr.responseType = 'blob';\n  xhr.send();\n}\n\ntoDataURL('https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0', function(dataUrl) {\n  console.log('RESULT:', dataUrl)\n})\n</code></pre><p>以下代码发送请求部分也可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">fetch API</span></a> 接口实现：</p><pre><code class=\"language-javascript\">const toDataURL = url =&gt; fetch(url)\n  .then(response =&gt; response.blob())\n  .then(blob =&gt; new Promise((resolve, reject) =&gt; {\n    const reader = new FileReader()\n    reader.onloadend = () =&gt; resolve(reader.result)\n    reader.onerror = reject\n    reader.readAsDataURL(blob)\n  }))\n\n\ntoDataURL('https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0')\n  .then(dataUrl =&gt; {\n    console.log('RESULT:', dataUrl)\n  })\n</code></pre><p>这种方式的好处是支持的格式比较多，缺点就是 FileReader API 的兼容性差一点，有部分手机浏览器不支持。</p><h2>Canvas 方法</h2><p>构建一个Image对象，用以加载图片数据。然后通过Canvas的drawImage方法将图片绘制到Canvas上，最后通过Canvas的toDataURL方法将图片转换为base64字符串。</p><pre><code class=\"language-javascript\">function toDataURL(src, callback, outputFormat) {\n  var img = new Image();\n  img.crossOrigin = 'Anonymous';\n  img.onload = function() {\n    var canvas = document.createElement('CANVAS');\n    var ctx = canvas.getContext('2d');\n    var dataURL;\n    canvas.height = this.naturalHeight;\n    canvas.width = this.naturalWidth;\n    ctx.drawImage(this, 0, 0);\n    dataURL = canvas.toDataURL(outputFormat);\n    callback(dataURL);\n  };\n  img.src = src;\n  if (img.complete || img.complete === undefined) {\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==\";\n    img.src = src;\n  }\n}\n\ntoDataURL(\n  'https://www.gravatar.com/avatar/d50c83cc0c6523b4d3f6085295c953e0',\n  function(dataUrl) {\n    console.log('RESULT:', dataUrl)\n  }\n)\n</code></pre><p>这种方式的好处是兼容性好，缺点是只支持图片格式。</p><h2>本地图片转换</h2><p>如果是本地图片，可以使用 <a href=\"https://developer.mozilla.org/de/docs/Web/API/FileReader\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">FileReader API</span></a> 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\" target=\"\"><span style=\"color: rgb(0, 56, 132);\">readAsDataURL()</span></a> 方法将其转换为 dataURL。</p><p>当然，需要有一个文件上传按钮。</p><pre><code class=\"language-javascript\">function encodeImageFileAsURL(element) {\n  var file = element.files[0];\n  var reader = new FileReader();\n  reader.onloadend = function() {\n    console.log('RESULT', reader.result)\n  }\n  reader.readAsDataURL(file);\n}\n\n&lt;input type=\"file\" onchange=\"encodeImageFileAsURL(this)\" /&gt;</code></pre><p>参考资料</p><ul><li style=\"text-align: left;\">How can I convert an image into Base64 string using JavaScript? - Stack Overflow</li></ul>","art_author":"yellow star","art_createtime":"2022-11-02T02:59:31.000Z","art_tags":null},{"id":67,"art_title":"【Echarts】legend不能formatter标签和转义字符（老坑人了）","art_content":"<p style=\"text-align: start; line-height: 1.5;\">legend:{</p><p style=\"text-align: start; line-height: 1.5;\"> data:['rain','sunny']</p><p style=\"text-align: start; line-height: 1.5;\"> selected:{</p><p style=\"text-align: start; line-height: 1.5;\"> 'rain':false,</p><p style=\"text-align: start; line-height: 1.5;\"> 'sunny':true,</p><p style=\"text-align: start; line-height: 1.5;\"> }</p><p style=\"text-align: start; line-height: 1.5;\">}</p><p style=\"text-align: start; line-height: 1.5;\"> </p><p style=\"text-align: start; line-height: 1.5;\">legend可以数组（多个）/对象（一个）</p><p style=\"text-align: start; line-height: 1.5;\">selected控制是否显示rain的条形数据</p>","art_author":"yellow star","art_createtime":"2022-11-01T12:37:05.000Z","art_tags":null},{"id":65,"art_title":"【技术】比Webpack快700倍的Turbopack，到底快在哪？","art_content":"<blockquote><span style=\"color: rgb(102, 102, 102); background-color: rgb(247, 247, 247); font-size: 14px;\">Turbopack 建立在新的增量架构上，以提供最快的开发体验。在大型应用上，它的更新速度比 Vite 快 10 倍，比Webpack 快 700 倍。在更大的应用上，通常会比 Vite 快 20 倍。</span></blockquote><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">10 月 25 日，Next.js 13 正式发布。同时，Vercel 还推出并开源了下一代打包工具：Turbopack。Turbopack 是针对 JavaScript 和 TypeScript 优化的增量打包工具，由 Webpack 的创建者 Tobias Koppers 和 Next.js 团队使用 Rust 编写。Turbopack 的推出吸引了众多开发者的关注，下面就来看看 Turbopack 都有哪些优势！</p><p style=\"text-align: center;\"><img src=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&amp;w=240&amp;h=135\" alt=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&amp;w=240&amp;h=135\" data-href=\"https://www4.bing.com//th?id=OHR.BridgeofSighs_ZH-CN5414607871_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&amp;w=240&amp;h=135\" style=\"\"></p><h3 style=\"text-align: start;\">Turbopack 的速度有多快？</h3><p style=\"text-align: start;\">Turbopack 建立在新的增量架构上，以提供最快的开发体验。在大型应用上，它的更新速度比 Vite 快 10 倍，比Webpack 快 700 倍。在更大的应用上，通常会比 Vite 快 20 倍。</p><p style=\"text-align: start;\">由于 Turbopack 只打包开发所需的最少资源，因此启动时间非常快。在具有 3000 个模块的应用上，Turbopack 需要 1.8 秒即可启动，而 Vite 则需要 11.4 秒：</p><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: start;\">Turbopack 为什么这么快？</h3><p style=\"text-align: start;\">Turbopack 性能的秘诀有两个：高度优化的机器代码和低层级增量计算引擎，可以缓存到单个函数的级别。它的架构吸取了 Turborepo 和 Google 的 Bazel 等工具的经验教训，它们都专注于使用缓存来避免重复执行相同的工作。</p><h4 style=\"text-align: start;\">Turbo 引擎工作原理</h4><p style=\"text-align: start;\">Turbopack 之所以如此之快，是因为它建立在一个可重用的 Rust 库之上，该库支持增量计算，称为 Turbo 引擎。以下是它的工作原理。</p><p style=\"text-align: start;\">在 Turbopack 驱动的程序中，可以将某些函数标记为“to be remembered”。当这些函数被调用时，Turbo 引擎会记住它们被调用的内容，以及它们返回的内容。然后它将其保存在内存缓存中。下面是一个简化的示例：</p><p style=\"text-align: start;\">我们首先在 api.ts​ 和 sdk.ts​ 这两个文件中调用 readFile。然后打包这些文件，将它们拼接在一起，最后得到 fullBundle。所有这些函数调用的结果都保存在缓存中以备后用。<br></p><p style=\"text-align: start;\">由于 sdk.ts​ 的结果发生了变化，就需要再次打包，然后需要再次拼接。重要的是，api.ts​ 并没有改变。只需从缓存中读取它的结果并将其传递给 concat。因此，这样就通过不读取并重新打包来节省了时间。</p><p style=\"text-align: start;\">Turbo 引擎当前将其缓存存储在内存中。这意味着缓存将与运行它的进程一样长，这对于 Dev server 来说效果很好。将来，计划将这个缓存持久化——要么保存到文件系统中，要么保存到像 Turborepo 这样的远程缓存中。这意味着 Turbopack 可以记住跨运行和机器完成的工作。</p><p style=\"text-align: start;\">这种方法使 Turbopack 在计算应用的增量更新方面非常快速，优化了 Turbopack 以处理开发中的更新，这意味着 Dev server 将始终快速响应更改。</p><h4 style=\"text-align: start;\">按要求编译</h4><p style=\"text-align: start;\">Turbo 引擎有助于在 Dev server 上提供极快的更新，但还有另一个重要指标需要考虑——启动时间。Dev server 开始运行的速度越快，开始工作的速度就越快。有两种方法可以使流程更快：工作更快或做工作更少。为了启动 Dev server，减少工作量的方法就是只编译启动所需的代码。</p><p style=\"text-align: start;\"><strong>（1）页面级编译</strong></p><p style=\"text-align: start;\">2-3 年前的 Next.js 版本在显示 Dev server 之前会编译整个应用。从 Next.js 11 开始就只编译请求的页面上的代码。这样会更好，但并不完美。当导航到 /users 时，将打包所有客户端和服务端模块、动态导入的模块以及引用的 CSS 和图片。这意味着如果页面的很大一部分隐藏在视图之外，或者隐藏在选项卡后面，仍然会编译它。</p><p style=\"text-align: start;\"><strong>（2）请求级编译</strong></p><p style=\"text-align: start;\">Turbopack 足够智能，可以只编译请求的代码。这意味着如果浏览器请求 HTML，就只会编译 HTML，而不会编译 HTML 引用的任何内容。如果浏览器需要 CSS，将只编译 CSS，而不编译其引用的图片，Turbopack 甚至知道不编译 source map，除非 Chrome DevTools 是打开的。通过请求级编译，减少了请求的数量，性能改进显着。</p><h3 style=\"text-align: start;\">为什么基于 Rust 开发？</h3><p style=\"text-align: start;\">Turbopack是 基于 Rust 开发的，每当 Next.js 团队将基于 JavaScript 的工具转移到基于 Rust 的工具时，都会看到巨大的改进。Next.js 替换了 JavaScript 编译器 Babel，使编译速度提高达 17 倍，替换了 Terser，使压缩速度提高了 6 倍，同时还减少了加载时间和宽带使用。</p><h3 style=\"text-align: start;\">为什么选择 Turbopack？</h3><p style=\"text-align: start;\">创建 Turbopack 就是为了提高 Next.js 的速度，希望它能够取代 Webpack，成为下一代 Web 打包工具。那为什么不选择新一代打包工具 esbuild 和 swc，而是选择创建自己的打包工具呢？</p><h4 style=\"text-align: start;\">增量计算</h4><p style=\"text-align: start;\">通常，有两种方法可以加快进程：减少工作量或并行工作。想要打造最快的打包工具，就要用力拉动这两个杠杆。因此决定为分布式和增量行为创建一个可重用的 Turbo 构建引擎。Turbo 引擎就像函数调用的调度程序一样工作，允许在所有可用内核上并行调用函数。Turbo 引擎还会缓存它调度的所有函数的结果，这意味着它永远不需要执行两次相同的工作。简而言之，它会以最大速度做最少的工作。</p><p style=\"text-align: start;\">其他工具对“做更少的工作”采取不同的方式。比如，Vite 通过在开发模式下使用原生 ESM 将工作量降至最低。在底层，Vite 将 esbuild 用于许多任务。esbuild 是一个非常快的打包器，它不会强迫我们使用原生 ESM。但出于几个原因，决定不采用 esbuild：</p><p style=\"text-align: start;\">esbuild 的代码针对一项任务进行了超优化 - 快速打包，因此没有 HMR（热更新）；</p><p style=\"text-align: start;\">esbuild 是一个非常快的打包工具，但它并没有做太多的缓存。这意味着会做很多重复的工作；</p><p style=\"text-align: start;\">而具有增量计算的 Rust 驱动的打包器在更大的规模上可以比 esbuild 更好地执行。</p><h4 style=\"text-align: start;\">惰性打包</h4><p style=\"text-align: start;\">Next.js 的早期版本试图在开发模式下打包整个 Web 应用，这并不是最优的。Next.js 的现代版本仅打包 Dev server 请求的页面。例如，如果转到localhost:3000​，它将仅打包 pages/index.jsx，以及它导入的模块。</p><p style=\"text-align: start;\">这种更“惰性”的方法是快速 Dev server 的关键。而 esbuild 没有“惰性”打包的概念——它是全有或全无的。Turbopack 的开发模式会根据收到的请求构建应用导入和导出的最小图，并且只打包必要的最少代码。</p><p style=\"text-align: start;\">此策略使 Turbopack 在首次启动 Dev server 时速度极快。只需计算渲染页面所需的代码，然后在单个块中将其发送到浏览器。在大规模应用中，这最终比原生 ESM 快得多。</p><p style=\"text-align: start;\">这就是构建 Turbopack 的原因。</p><h3 style=\"text-align: start;\">Turbopack 的功能</h3><p style=\"text-align: start;\">构建 Web 应用的实践非常多样化。仅在 CSS 中，就有 SCSS、Less、CSS Module、PostCSS等。React、Vue 和 Svelte 等框架需要自定义设置。</p><p style=\"text-align: start;\">在构建打包工具时，我们希望它能开箱即用，无需配置，可以通过插件获得一些功能。目前，Turbopack 仍处于 alpha 阶段，在当前状态下，Turbopack 还不能配置，所以插件也还不可用。</p><p style=\"text-align: start;\">下面来看一下 Turbopack 默认配置中哪些功能是开箱即用的以及未来将通过插件配置的功能：</p><ul style=\"text-align: start;\"><li>JavaScript：支持所有 ESNext 功能、Browserslist 和顶层 await；</li><li>TypeScript：开箱即用地支持 TypeScript，包括解析路径和baseUrl；</li><li>Imports：支持 require、import、动态导入等；</li><li>Dev Server：优化的 Dev Server 支持热更新 (HMR) 和快速刷新；</li><li>CSS：支持全局 CSS、CSS Module、postcss-nested 和 @import；</li><li>静态资源：支持 /public 目录、JSON 导入和通过 ESM 导入资源；</li><li>环境变量：通过 .env、.env.local 等支持环境变量。</li></ul><h3 style=\"text-align: start;\">Turbopack vs Vite vs Webpack</h3><h4 style=\"text-align: start;\">Turbopack vs Vite</h4><p style=\"text-align: start;\">Turbopack 在以下两个关键指标上的表现优于 Vite。</p><p style=\"text-align: start;\"><strong>（1）Dev server 启动时间</strong></p><p style=\"text-align: start;\">Turbopack 的 Dev server 启动速度比 Vite 快得多。在 1000 个模块的应用中，Vite 需要 4.8 秒才能启动。Turbopack 启动仅需 0.9 秒，快了5.5倍。在大型应用中，这种差异将保持一致。在 30000 个模块的应用中， Turbopack 的启动速度比 Vite 快了 5.4 倍。</p><p style=\"text-align: start;\"><strong>（2）代码更新</strong></p><p style=\"text-align: start;\">当文件更改时，它需要将更改呈现给浏览器。它做到的越快，反馈循环就越紧密，发布的速度就越快。在 1000 个模块的应用中，Turbopack 对文件更改的速度比 Vite 快 5.8 倍。</p><h4 style=\"text-align: start;\">Turbopack vs Webpack</h4><p style=\"text-align: start;\">Turbopack 的增量架构在以下两个关键指标上超过了 Webpack 的速度。</p><p style=\"text-align: start;\"><strong>（1）Dev server 启动时间</strong></p><p style=\"text-align: start;\">Turbopack 的 Dev server 启动速度比 Webpack 快得多。Next.js 12 底层使用了 Webpack，可以在 3.4 秒内在 1000 个模块的应用上启动 build server。Turbopack 的启动速度快了 0.9 秒 - 3.9倍。</p><p style=\"text-align: start;\"><strong>（2）代码更新</strong></p><p style=\"text-align: start;\">在 Dev server 上执行的最常见操作就是更改文件。当文件更改时，它需要将更改呈现给浏览器。它做到的越快，反馈循环就越紧密，发布的速度就越快。在 1000 个模块的应用中，Turbopack 对文件更改的反应速度比 Webpack 快 8.9 倍：</p><h3 style=\"text-align: start;\">Turbopack 的未来</h3><p style=\"text-align: start;\">到目前为止，Turbopack 可以在 Next.js v13 中使用。未来将发布独立的 CLI、插件 API，并支持其他框架，如 Svelte 和 Vue。</p><p style=\"text-align: start;\">Turbopack 将用于 Next.js 13 Dev server。它将为闪电般快速的 HMR 提供动力，并将原生支持 React 服务端组件，以及 TypeScript、JSX、CSS 等。Webpack 用户还可以期待使用 Turbopack 进入基于 Rust 的未来的增量迁移路径。</p><p style=\"text-align: start;\">期待在 Webpack 的创建者 Tobias Koppers 的带领下，Turbopack 成为 Web 的下一代打包工具。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p>","art_author":"yellow star","art_createtime":"2022-10-28T09:17:10.000Z","art_tags":null},{"id":64,"art_title":"【技术】Vite的原理介绍及应用","art_content":"<p><br></p><h2>背景</h2><blockquote>在当今Webpack横行的时代，Webpack的影响力不可谓之不大。对于一个主流Web项目的开发而言，大多数时候我们都会采用现有的脚手架作为项目开发，打包工具如：Vue-cli、create-react-app，而他们都基于Webpack。但是，在不断的使用和日常项目的迭代中，我们慢慢会走入一个窘境，就会出现我们稍微改动一行代码我们就需要等待十几秒甚至是数十秒的情况，这对于我们日益增长的业务开发来说是十分不友好的。 深入Webpack打包原理我们可以清晰的知道他的编译过程是静态的，也就是说他会把所有可能用到的代码全部进行打包构建，会借助胶水代码用来组装各模块，这样打包出来的代码是十分庞大的，很多时候其实我们在开发过程中并不需要全部代码的功能，而是一小部分，这个时候大量的构建时间都是多余的，我们需要一个能够真正意义上实现懒加载的开发工具。</blockquote><h2>Vite是什么？</h2><h3>定义</h3><blockquote>Vite（轻量，轻快）vite是一个基于vue3单文件组件的非打包开发服务器。它做到了本地快速开发启动，实现按需编译，不再等待整个应用编译完成。 面向现代化浏览器，基于原生模块系统 ES moudle 的开发服务器，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。 浏览器端使用 export、import 的方式导入和导出模块，在 script 标签里设置 type=\"module\"，浏览器会识别所有添加了type='module'的script标签，对于该标签中的import关键字，浏览器会发起http请求获取模块内容。</blockquote><blockquote>它主要具有以下特点： 快速的冷启动 即时的模块热更新 真正的按需编译</blockquote><h3>基本架构</h3><p>启动项目时，则是启动一个koa服务器，服务器拦截浏览器的es module的请求，服务器直接将 ESM 模块内容处理后，通过 path 找到目录下对应的文件做一定的处理最终以 ES Modules 格式返回给客户端。接着，现代浏览器通过解析 script module，对每一个 import 到的模块进行 HTTP 请求，服务器继续对这些 HTTP 请求进行处理并响应。（热更新）<br><br></p><p>图中的目标项目即我们开发时的项目，vite服务在解析模块路径以及读取文件内容时需要访问目标项目中的模块内容或者配置文件等。</p><p><br></p><p><br></p><h2>Vite的原理介绍</h2><ul><li>使用vite后项目分析</li><li></li></ul><pre><code class=\"language-  language-jsx\">它的核心在于使用了es的语法，我们可以看到index.html文件，和以前不一样的地方在于，它使用了:\n  &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n// 这样引入的话就表示它是一个模块，那这个script里面就可以使用import\n//默认引入的是src下的main.js\n\n\n\n\n<img src=\"//upload-images.jianshu.io/upload_images/8496278-969c945a7160f9f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/909/format/webp\" alt=\"\" data-href=\"\" style=\"\"/>\nimage.png</code></pre><p>从其他请求中我们也可以看出每一个.vue文件都被拆分成了多个请求，并通过type来标识是template还是style。<br></p><p><img src=\"//upload-images.jianshu.io/upload_images/8496278-5b47c8ada339e630.png?imageMogr2/auto-orient/strip|imageView2/2/w/904/format/webp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>image.png</p><ul><li>结论</li></ul><blockquote>vite在这里做了两件事，第一是修改了模块请求路径，第二就是将.vue文件进行解析拆分。（只是本文会进行详细讲解的有关于Vite实现的部分，而不是说Vite只干了这两件事 Vite的功能还是十分强大的）</blockquote><h2>深入源码讲原理</h2><h4>1、创建自己的vite工具 my-vite</h4><blockquote>项目目录概述： my-vite -bin 。www.js -node_modules -plugins -index.js -package.json</blockquote><p>在项目根目录创建bin目录，并在bin目录下创建一个<a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.js\" target=\"_blank\">www.js</a>文件，文件内容如下：</p><p><br></p><pre><code class=\"language-  language-jsx\">! /usr/bin/env node\n// 执行的入口\nrequire('../index');\n</code></pre><h4>2、创建服务</h4><p>在创建<a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fwww.js\" target=\"_blank\">www.js</a>文件中引入了index.js文件，主要是使用了koa启动了一个简单服务以及实现vite的功能</p><p><br></p><pre><code class=\"language-  language-tsx\">const Koa = require('koa')\nconst { moduleRewritePlugin } = require('./plugins/serverPluginModuleRewrite')\nconst serveStaticPlugin = require('./plugins/serverPluginServeStatic')\nconst { moduleResolvePlugin } = require('./plugins/serverPluginModuleResolve')\nconst { vuePlugin } = require('./plugins/serverPluginVue')\n\nfunction createServer() {\n    let app = new Koa();\n    const context = { //直接创建一个上下文，来给不同的插件共享功能\n        app,\n        root: process.cwd()     \n     }\n    const resolvePlugin = [\n        moduleRewritePlugin, //2.重写我们的请求路径, 重写后浏览器会再次发送请求\n        moduleResolvePlugin,//解析模块路径,服务端来解析模块真实位置\n        vuePlugin, // 解析.vue文件\n        serveStaticPlugin //1.静态服务插件,处理所需要处理的静态文件    \n    ]\n    resolvePlugin.forEach(plugin =&gt; plugin(context))\n    return app;\n}\ncreateServer().listen(4000, () =&gt; {\n    console.log('vite start 4000')\n})\n\n</code></pre><h4>3、静态服务插件</h4><p><strong>serverPluginServeStatic.js文件</strong>:使用koa-static中间件来托管静态资源，同时我们需要拿到koa实例（app），其次需要获取到目标项目的根目录路径（root），将目标项目进行整体托管，同时对于目标项目的 public目录也进行托管，这样，我们需要处理的静态文件基本完成了。</p><p><br></p><pre><code class=\"language-  language-jsx\">const static = require('koa-static')\nconst path = require('path')\n\nfunction serveStaticPlugin({ app, root }) {\n\n    app.use(static(root)) // root指的是根目录 访问根目录下的index.html\n    app.use(static(path.resolve(root, 'public'))) //可以直接http://localhost:4000/文件名，访问public下的文件,比如public文件下有aa.txt,则直接访问http://localhost:4000/aa.txt\n}\n\nmodule.exports = serveStaticPlugin\n</code></pre><h4>4、重写模块路径插件</h4><p><strong>为什么要重写模块路径呢？</strong><br><br>这是因为我们在使用import方式导入模块的时候，浏览器只能识别./、../、/这种开头的路径，对于直接使用模块名比如：import vue from 'vue'，浏览器就会报错，因为它无法识别这种路径，这就是我们需要进行处理的地方了。<br></p><p><img src=\"//upload-images.jianshu.io/upload_images/8496278-cff68afc3687df15.png?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>image.png</p><p><br></p><p><strong>serverPluginModuleRewrite.js文件：</strong><br></p><p><img src=\"//upload-images.jianshu.io/upload_images/8496278-b8f5c37f492f3653.png?imageMogr2/auto-orient/strip|imageView2/2/w/1125/format/webp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>image.png<br></p><p><img src=\"//upload-images.jianshu.io/upload_images/8496278-3ff52d2268e84a58.png?imageMogr2/auto-orient/strip|imageView2/2/w/807/format/webp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>image.png</p><p><br></p><h4>5、解析模块路径插件</h4><p>在处理完所有的模块路径之后，我们就需要在服务端来解析模块真实位置。</p><p><br></p><pre><code class=\"language-  language-jsx\">const reg = /^\\/@modules\\//\nconst fs = require('fs').promises\nconst path = require('path')\n \nfunction moduleResolvePlugin({ app, root }) {\n    app.use(async(ctx, next) =&gt; {\n        // 如果没有匹配到 /@modules就往下执行即可\n        if (!reg.test(ctx.path)) {\n            return next();\n        }\n        const id = ctx.path.replace(reg, '');\n        //console.log(\"id--&gt;\", id)  //vue\n        let mapping = {\n                vue: path.resolve(root, 'node_modules', '@vue/runtime-dom/dist/runtime-dom.esm-browser.js')\n            }\n            //如果是第三方模块，则可以根据package.json进行查找\n        const content = await fs.readFile(mapping[id], 'utf8')\n        ctx.type = 'js' //返回的文件为js\n        ctx.body = content\n    })\n}\n\nexports.moduleResolvePlugin =  moduleResolvePlugin\n</code></pre><h4>6、解析.vue文件</h4><p>当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template , css ,script 模块三个模块进行分别处理。最后会对 script ,template, css 发送多个请求获取。<br></p><p><img src=\"//upload-images.jianshu.io/upload_images/8496278-3ed884d6ce6c3225.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>image.png</p><h4>7、总结</h4><blockquote>在 koa 中间件里获取请求 body 通过 es-module-lexer 解析资源 ast 拿到 import 的内容 判断 import 的资源是否是 npm 模块 返回处理后的资源路径：\"vue\" =&gt; \"/@modules/vue\" 将处理的template,script,style等所需的依赖以http请求的形式，通过query参数形式区分并加载SFC文件各个模块内容。</blockquote><h2>Webpack & Vite 对比</h2><ul><li><br><br></li></ul><blockquote>1.当我们对比使用 vue-cli-service serve 的时候，会有明显感觉。因为 Webpack Dev Server 在启动时，需要先 build—遍，而 build 的过程是需要耗费很多时间的。 2.而 Vite 则完全不同，当我们执行 Vite serve 时（npm run dev），内部直接启动了 Web Server，并不会先编译所有的代码文件。那仅仅是启动 Web Server，那么及时请求的编译呢？关于支持 JSX， TSX，Typescript 编译到原生 JS —— Vite 引入了EsBuild，是使用 Go 写的，直接编译为 Native 代码，性能要比 TSC 好二三十倍， 当然也会用上缓存。</blockquote><ul><li>即时的热模块更新</li></ul><blockquote>1.热更新的时候，Vite 只需要立即编译当前所修改的文件即可，所以 响应速度非常快。 2.而 Webpack 修改某个文件过后，会自动以这个文件为入口重写 build—次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。</blockquote><ul><li>真正的按需编译</li></ul><blockquote>1.Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。 2.Vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。也就是说，只有具体去请求某个文件时才会编译这个文件。所以，这种「即时编译」的好处主要体现在：按需编译。<br></blockquote><p>作者：江南之城<br>链接：https://www.jianshu.com/p/0d00a49adb20<br>来源：简书<br></p>","art_author":"yellow star","art_createtime":"2022-10-26T07:31:34.000Z","art_tags":null},{"id":63,"art_title":"【笔记】JavaScript阻止屏幕进入睡眠状态","art_content":"<p style=\"text-align: start;\">使用 JavaScript 阻止屏幕进入睡眠状态。</p><p style=\"text-align: start;\">最近在 H5 端有需要保持手机屏幕常亮的需求，辗转之下，发现了一个早在 chrome 85 中就已经支持的 Web API，不过，截止到今天发文时，Safari 仍不支持，尽管如此，在安卓端我们还是能调用这个 API 来节省设备电池电量（相对于 NoSleep.js 来说），ios 端使用 polyfill 的方式，在将来 Safari 支持该 API 后移除即可。</p><p style=\"text-align: start;\">Wake Lock 可防止屏幕关闭、变暗或锁定，仅适用于活动的选项卡/窗口，这可以防止后台选项卡使您的设备保持唤醒状态，也提供了函数以随时通过代码手动释放。</p><p style=\"text-align: start;\">调用 Wake Lock 之前，我们首先需要检查当前浏览器中是否存在该功能。我们可以使用以下简单函数来做到这一点。</p><pre><code class=\"language-javascript\">const canWakeLock = () =&gt; 'wakeLock' in navigator;</code></pre><h2 style=\"text-align: start;\">请求唤醒锁</h2><p style=\"text-align: start;\">下面的示例演示如何请求 WakeLockSentinel 对象。<span style=\"color: rgb(248, 35, 117); background-color: rgb(248, 248, 248);\"><code>WakeLock.request</code></span> 方法是基于 Promise 的，因此我们可以创建一个异步函数。</p><pre><code class=\"language-javascript\">let wakeLock = null;const requestWakeLock = async ()=&gt;{\n    try {\n        wakeLock = await navigator.wakeLock.request('screen');\n        console.log('Wake Lock is active!');\n    } catch (err) {\n        console.log(`${err.name}, ${err.message}`);\n    }\n\n}\n\nrequestWakeLock()</code></pre><h2 style=\"text-align: start;\">释放唤醒锁</h2><p style=\"text-align: start;\">下面的示例演示如何释放以前获取的唤醒锁。</p><pre><code class=\"language-javascript\">wakeLock.release().then(() =&gt; wakeLock = null);</code></pre><h2 style=\"text-align: start;\">侦听唤醒锁释放</h2><p style=\"text-align: start;\">如因任何原因（例如离开活动窗口/选项卡）而释放唤醒锁，将出触发 release 监听函数。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">复制wakeLock.addEventListener('release', () =&gt; {\n    console.log('Wake Lock has been released');\n});</code></pre><h2 style=\"text-align: start;\">重新获取唤醒锁</h2><p style=\"text-align: start;\">以下代码在文档的可见性发生更改并释放唤醒锁时重新获取唤醒锁。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">复制document.addEventListener('visibilitychange', async () =&gt; {\n    if (wakeLock !== null && document.visibilityState === 'visible') {\n        requestWakeLock()\n    }\n});</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-10-21T03:24:47.000Z","art_tags":null},{"id":62,"art_title":"【图片】发现一张邓紫棋照片🖼","art_content":"<p><img src=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" alt=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" data-href=\"https://qpic.y.qq.com/music_cover/Biax4WTSMic4N0bgPWDwUCs0U1ZpaC3FJmVKYbA4FmORq7ZeLYRLGiclQ/600?n=1\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-10-20T05:38:08.000Z","art_tags":null},{"id":61,"art_title":"【CSS】Chrome如何支持小于12px 的文字 🎃","art_content":"<p style=\"text-align: start;\"><br></p><ol><li>方案一：使用zoom</li></ol><ul><li>zoom 可以改变页面上元素的尺寸，属于真实尺寸。</li><li>zoom:50%，表示缩小到原来的一半</li><li>zoom:0.5，表示缩小到原来的一半</li></ul><p><br></p><pre style=\"text-align: left;\"><code>.span10{\n    font-size: 12px;\n    display: inline-block;\n    zoom: 0.8;\n}\n</code></pre><p>方法二： transform:scale(0.8)</p><pre style=\"text-align: left;\"><code>.span10{\n    font-size: 12px;\n    display: inline-block;\n    transform:scale(0.8);\n}</code></pre><p style=\"text-align: center;\"><img src=\"http://img.poooster.com/poooster/2022/10/illuminator_POSTER_01.jpg\" alt=\"钻石\" data-href=\"http://img.poooster.com/poooster/2022/10/illuminator_POSTER_01.jpg\" style=\"width: 50%;\"></p>","art_author":"yellow star","art_createtime":"2022-10-20T03:48:05.000Z","art_tags":null},{"id":60,"art_title":"【HTML】HTML5 drag API 🎈","art_content":"<ul style=\"text-align: start;\"><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul><p><br></p>","art_author":"yellow star","art_createtime":"2022-10-20T03:42:46.000Z","art_tags":null},{"id":59,"art_title":"钻石💎","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=illuminator_POSTER_02-1666158145550.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-10-19T05:43:09.000Z","art_tags":null},{"id":58,"art_title":"钱钱刚刚在叫","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=35d92b9406f3a90b65fe0035725885b6-1666106223817.jpeg\" alt=\"\" data-href=\"\" style=\"width: 129.00px;height: 129.00px;\"/> 表情包 😊 ❤️🏋️‍♂️🥌</p>","art_author":"yellow star","art_createtime":"2022-10-18T15:18:51.000Z","art_tags":null},{"id":57,"art_title":"【测试】标题表情包测试🧛‍♀️🧛‍♂️🧜‍♀️🧜‍♂️","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=å¾®ä¿¡å¾ç_20221014151720-1666074535913.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p>","art_author":"yellow star","art_createtime":"2022-10-18T06:28:58.000Z","art_tags":null},{"id":56,"art_title":"【测试】表情包测试","art_content":"<p>👧👦🧒👶👵</p>","art_author":"yellow star","art_createtime":"2022-10-18T06:26:33.000Z","art_tags":null},{"id":55,"art_title":"【记录一下】梦  2022/10/18","art_content":"<p>梦到乔丹从一个少年成为篮球巨星的故事，乔丹，生于单亲妈妈家庭，是一个白人，没错是白人，由妈妈带大，篮球目标也是妈妈为他选好的，参加选秀的时候，一枝独秀；出名后故意晒黑（也可能是纹身）让自己成为黑皮肤，报复母亲；</p><p>衔接上个梦境，成为超人，一群人来挑事，往我电脑安装监控器，被发现后还态度强硬，后被我暴揍，将他们最厉害两个人按地上暴捶；</p><p>醒</p><p>莫名其妙 </p>","art_author":"yellow star","art_createtime":"2022-10-18T06:06:53.000Z","art_tags":null},{"id":54,"art_title":"和人可人去人咬人不人马人","art_content":"<p>和人可人去人咬人不人马人</p><p>和人可人去人咬人不人马人</p>","art_author":"yellow star","art_createtime":"2022-10-10T08:42:18.000Z","art_tags":null},{"id":53,"art_title":"后期优化点","art_content":"<ol><li>首页加载数据限制，下拉刷新</li><li>视频功能加上？（痛点：服务器存储不够）</li><li>资源整理</li><li>服务器数据区emoji字符集还未更新！</li><li>手机访问适配，媒体查询</li><li>其他板块探索</li></ol>","art_author":"yellow star","art_createtime":"2022-10-10T08:34:06.000Z","art_tags":null},{"id":51,"art_title":"发布图片测试-问题","art_content":"<p><img src=\"http://124.223.185.220:3000/getImage?img=HYDRA-1665389786925.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p><blockquote> &nbsp; 问题：使用PM2管理项目，上传图片会失败，终端npm start启动项目成功上传图片！</blockquote>","art_author":"yellow star","art_createtime":"2022-10-10T08:18:13.000Z","art_tags":null},{"id":47,"art_title":"ERROR 1064 (42000): You have an error in your SQL syntax; Want to configure a password as root being the user","art_content":"<p style=\"text-align: left;\">I was using MySQL 8 and non of the above worked for me.</p><p style=\"text-align: left;\">This is what I had to do:</p><pre><code ># ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password';</code></pre><blockquote><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"><code>This worked for me on: mysql ver 8.0.16 for osx10.14 on x86_64 (Homebrew). Update query resulted in syntax error.</code></span><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"> </span>– <a href=\"https://stackoverflow.com/users/2010877/nishant-ghodke\" target=\"\">Nishant Ghodke</a><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"> </span><span style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\">Jul 14, 2019 at 12:42<br></span><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\">Yup... only this works on: mysql ver 8.0.16 for mac installed with homebrew </span>– <a href=\"https://stackoverflow.com/users/1364747/teddy\" target=\"\">Teddy</a><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"> </span><span style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\">Jul 16, 2019 at 9:25<br></span><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\">This was the only thing that worked for me been googling forever!! </span>– <a href=\"https://stackoverflow.com/users/4245513/sam-johnson\" target=\"\">Sam Johnson</a><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 13px;\"> </span><span style=\"color: var(--black-350); background-color: rgb(255, 255, 255); font-size: 13px;\">Jan 7, 2020 at 22:37</span></blockquote><p style=\"text-align: left;\">On MySQL 8.0.15 (maybe earlier than this too) the <span style=\"color: var(--black-800); background-color: var(--black-075);\"><code>PASSWORD()</code></span> function does not work anymore, so you have to do:</p><p style=\"text-align: left;\">Make sure you have stopped MySQL first (Go to: 'System Preferences' &gt;&gt; 'MySQL' and stop MySQL).</p><p style=\"text-align: left;\">Run the server in safe mode with privilege bypass:</p><p><br></p><pre><code >sudo mysqld_safe --skip-grant-tables\r\nmysql -u root\r\nUPDATE mysql.user SET authentication_string=null WHERE User='root';\r\nFLUSH PRIVILEGES;\r\nexit;</code></pre><p><span style=\"color: rgb(35, 38, 41); background-color: rgb(255, 255, 255); font-size: 15px;\">Then</span></p><pre><code >mysql -u root\r\nALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'yourpasswd';</code></pre><p style=\"text-align: left;\">Finally, start MySQL again.<br></p>","art_author":"yellow star","art_createtime":"2022-09-14T01:11:10.000Z","art_tags":null},{"id":46,"art_title":"今日0914","art_content":"<p><span style=\"color: rgb(8, 151, 156);\">昨日俩鸡 over</span></p>","art_author":"yellow star","art_createtime":"2022-09-14T01:07:04.000Z","art_tags":null},{"id":19,"art_title":"SSG","art_content":"<h3 style=\"text-align: start;\">SSG</h3><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">SSG(Static Site Generation) 是指在应用编译构建时预先渲染页面，并生成静态的 HTML。把生成的 HTML 静态资源部署到服务器后，浏览器不仅首次能请求到带页面内容的 HTML ，而且不需要服务器实时渲染和响应，大大节约了服务器运维成本和资源。</span></p><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">Next.js 默认为每个页面开启 SSG。对于页面内容需要依赖静态数据的场景，允许在每个页面中 </span>export<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 一个 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 异步函数，在这个函数中可以把该页面组件所需要的数据收集并返回。当 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 函数执行完成后，页面组件就能在 </span>props<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 中拿到这些数据并执行静态渲染。举个在静态路由中使用 SSG 的例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/first-post.js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  // 模拟获取静态数据\r\n  const postData = await getPostData();\r\n  return {\r\n    props: { postData }\r\n  }\r\n}</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">对于动态路由的场景，Next.js 是如何做 SSG 的呢？Next.js 提供 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 异步函数，在这个方法中，会返回一个 </span>paths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 数组，这个数组包含了这个动态路由在构建时需要预渲染的页面数据。举个例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  // 返回该动态路由可能会渲染的页面数据，比如 params.id\r\n  const paths = [\r\n    {\r\n      params: { id: 'ssg-ssr' }\r\n    },\r\n    {\r\n      params: { id: 'pre-rendering' }\r\n    }\r\n  ]\r\n  return {\r\n    paths,\r\n    // 命中尚未生成静态页面的路由直接返回 404 页面\r\n    fallback: false\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    }\r\n  }\r\n}</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">当我们执行 </span>nextjs build<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 后，可以看到打包结果包含 </span>pre-rendering.html<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 和 </span>ssg-ssr.html<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 两个 HTML 页面，也就是说在执行 SSG 时，会对 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 函数返回的 </span>paths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 数组进行循环，逐一预渲染页面组件并生成 HTML。</span></p><pre><code >├── server\r\n|  ├── chunks\r\n|  ├── pages\r\n|  |  ├── api\r\n|  |  ├── index.html\r\n|  |  ├── index.js\r\n|  |  ├── index.json\r\n|  |  └── posts\r\n|  |     ├── [id].js\r\n|  |     ├── first-post.html\r\n|  |     ├── first-post.js\r\n|  |     ├── pre-rendering.html       # 预渲染生成 pre-rendering 页面\r\n|  |     ├── pre-rendering.json\r\n|  |     ├── ssg-ssr.html             # 预渲染生成 ssg-ssr 页面\r\n|  |     └── ssg-ssr.json</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">SSG 虽然很好解决了白屏时间过长和 SEO 不友好的问题，但是它仅仅适合于页面内容较为静态的场景，比如官网、博客等。面对</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>页面数据更新频繁</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">或</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>页面数量很多</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">的情况，它似乎显得有点束手无策，毕竟在静态构建时不能拿到最新的数据和无法枚举海量页面。这时，就需要增量静态再生成(Incremental Static Regeneration)方案了。</span></p>","art_author":"yellow star","art_createtime":"2022-08-24T01:38:08.000Z","art_tags":null},{"id":18,"art_title":"2022/08/24 09:06","art_content":"<h3 style=\"text-align: start;\">ISR</h3><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">Next.js 推出的 ISR(Incremental Static Regeneration) 方案，允许在</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>应用运行时再重新生成每个页面 HTML，而不需要重新构建整个应用</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">。这样即使有海量页面，也能使用上 SSG 的特性。一般来说，使用 ISR 需要 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 和 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 同时配合使用。举个例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  const paths = await fetch('https://.../posts');\r\n  return {\r\n    paths,\r\n    // 页面请求的降级策略，这里是指不降级，等待页面生成后再返回，类似于 SSR\r\n    fallback: 'blocking'\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    },\r\n    // 开启 ISR，最多每10s重新生成一次页面\r\n    revalidate: 10,\r\n  }\r\n}</code></pre><p style=\"text-align: start;\">在应用编译构建阶段，会生成已经确定的静态页面，和上面 SSG 执行流程一致。</p><p style=\"text-align: start;\">在 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>getStaticProps</code></span> 函数返回的对象中增加 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>revalidate</code></span> 属性，表示开启 ISR。在上面的例子中，指定 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>revalidate = 10</code></span>，表示最多10秒内重新生成一次静态 HTML。当浏览器请求已在构建时渲染生成的页面时，首先返回的是缓存的 HTML，10s 后页面开始重新渲染，页面成功生成后，更新缓存，浏览器再次请求页面时就能拿到最新渲染的页面内容了。</p><p style=\"text-align: start;\">对于浏览器请求构建时未生成的页面时，会马上生成静态 HTML。在这个过程中，<span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>getStaticPaths</code></span> 返回的 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback</code></span> 字段有以下的选项：</p><ul style=\"text-align: start;\"><li><span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: 'blocking'</code></span>：不降级，并且要求用户请求一直等到新页面静态生成结束，静态页面生成结束后会缓存</li><li><span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: true</code></span>：降级，先返回降级页面，当静态页面生成结束后，会返回一个 JSON 供降级页面 CSR 使用，经过二次渲染后，完整页面出来了</li></ul><p style=\"text-align: start;\">在上面的例子中，使用的是不降级方案(<span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: 'blocking'</code></span>)，实际上和 SSR 方案有相似之处，都是阻塞渲染，只不过多了缓存而已。</p><p style=\"text-align: start;\">If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path.</p><p style=\"text-align: start;\">也不是所有场景都适合使用 ISR。对于实时性要求较高的场景，比如新闻资讯类的网站，可能 SSR 才是最好的选择。</p>","art_author":"yellow star","art_createtime":"2022-08-24T01:07:51.000Z","art_tags":null},{"id":17,"art_title":"2022/08/23 17:06","art_content":"<p>今天成功打包了一个nextJs项目</p><p>问题：</p><p>npm run build后终端报错打包失败：panicked at 'The global thread pool has not been initialized.</p><p>解决：</p><p>问题看不懂来源，我直接把 node_modules文件夹整个删掉；</p><p>再 npm install 下回来，</p><pre><code >npm install\r</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">依赖下完后继续打包</span></p><pre><code >npm run build\r</code></pre><p style=\"text-align: start;\">打包成功，成功解决。</p><p style=\"text-align: start;\">笑死~<br>问题来的触不及防，走的也悄无声息。</p>","art_author":"yellow star","art_createtime":"2022-08-23T09:09:06.000Z","art_tags":null},{"id":16,"art_title":"华华美女","art_content":"<h2>最好看的华华</h2><pre><code class=\"language-javascript\">log('仙女华华')</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-08-23T02:22:25.000Z","art_tags":null},{"id":14,"art_title":"20220822/17:01","art_content":"<p>富文本内容只读操作</p><pre><code class=\"language-javascript\">import React, { useEffect, useState } from 'react'\r\nimport Head from 'next/head'\r\nimport Image from 'next/image'\r\nimport styles from '../../styles/artcontent.module.css'\r\nimport axios from 'axios'\r\nimport { useRouter } from 'next/router'\r\nimport '@wangeditor/editor/dist/css/style.css'\r\nimport dynamic from 'next/dynamic';\r\n\r\nexport async function getStaticPaths() {\r\n    const res = await fetch('http://192.168.70.98:3030/api/msq/test')\r\n    const arts = await res.json()\r\n   const narts= arts.data.map(item=&gt;{\r\n       return {\r\n        params:{aid:item.id+''}\r\n       }\r\n    })\r\n    // console.log('arts',narts);\r\n    return {\r\n      paths: narts,\r\n    //   paths: [{ params: { aid: '1' } }, { params: { aid: '2' }}],\r\n      fallback: false, // can also be true or 'blocking'\r\n    }\r\n  }\r\nexport async function getStaticProps(context) {\r\n   \r\n  // Call an external API endpoint to get posts.\r\n  // You can use any data fetching library\r\n  const res = await fetch('http://192.168.70.98:3030/api/msq/search?id='+context.params.aid)\r\n  const detail = await res.json()\r\n    console.log(detail);\r\n//   // By returning { props: { posts } }, the Blog component\r\n//   // will receive `posts` as a prop at build time\r\n  return {\r\n    props: {\r\n      datas:detail.data,\r\n    },\r\n  }\r\n}\r\n\r\nconst DisplayPanels = dynamic(import(\"../../components/DisplayPanels\"), {\r\n    ssr: false,\r\n    loading: () =&gt; &lt;p&gt;Loading ...&lt;/p&gt;,\r\n  });\r\n\r\n\r\nexport default function Artcontent(props) {\r\n  const router = useRouter()\r\n  const { aid } = router.query\r\n  const {datas={}}=props\r\n  useEffect(()=&gt;{\r\n    \r\n  },[])\r\n\r\n  return (\r\n    &lt;div className={styles.container}&gt;\r\n      &lt;Head&gt;\r\n        &lt;title&gt;yellow star blog&lt;/title&gt;\r\n        &lt;meta name=\"description\" content=\"yellow star blog\" /&gt;\r\n        &lt;link rel=\"icon\" href=\"/CarStation.svg\" /&gt;\r\n      &lt;/Head&gt;\r\n\r\n      &lt;main className={styles.main}&gt;\r\n        &lt;h1&gt;{datas.art_title}&lt;/h1&gt;\r\n        &lt;DisplayPanels\r\n            EditorCfg={{\r\n                defaultConfig:{\r\n                    placeholder: '无内容',\r\n                    readOnly:true\r\n                  },\r\n                value:datas.art_content,\r\n                // onCreated:setEditor,\r\n                // onChange:editor =&gt; setHtml(editor.getHtml()),\r\n                mode:'default',\r\n                style:{ height: '500px', 'overflowY': 'hidden' },\r\n                readOnly:true\r\n              }}\r\n        &gt;&lt;/DisplayPanels&gt;\r\n      &lt;/main&gt;\r\n\r\n      &lt;footer className={styles.footer}&gt;\r\n        &lt;a\r\n          href=\"https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        &gt;\r\n          Powered by{' '}\r\n          &lt;span className={styles.logo}&gt;\r\n            &lt;Image src=\"/vercel.svg\" alt=\"Vercel Logo\" width={72} height={16} /&gt;\r\n          &lt;/span&gt;\r\n        &lt;/a&gt;\r\n      &lt;/footer&gt;\r\n    &lt;/div&gt;\r\n  )\r\n}\r\n</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-08-22T09:03:28.000Z","art_tags":null},{"id":13,"art_title":"20220822","art_content":"<p>今天周一，天气晴，做了核酸！</p>","art_author":"yellow star","art_createtime":"2022-08-22T07:51:51.000Z","art_tags":null}]},"__N_SSG":true}