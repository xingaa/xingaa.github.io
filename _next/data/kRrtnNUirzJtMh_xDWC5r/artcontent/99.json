{"pageProps":{"datas":{"id":99,"art_title":"深入理解HTTP缓存机制及原理","art_content":"<h3>一、前言</h3><p>       上周阿里的面试官问了个面试题 “ 能不能说下 304 的过程，以及影响缓存的头部属性有哪些？”OMG.......因为之前只是大概了解 304 状态码是表示缓存，且因为平时项目开发过程中也没有在缓存这块踩过坑，所以这一块也没有去做特别深入的研究。所以当被问这个问题时，有被当头一棒的感觉，也好好反思了下，自己校招以软件开发工程师的职位进入公司，之前没有想过要从事前端开发，所以前端基础几乎可以忽略不计。工作一年多来，为在工作上表现突出，在工作上投入大量的精力，干到晚上10点是常规操作，周末至少加班1天；并且空余时间，经常看前端相关书籍弥补基础，如《JavaScript 高级程序设计》、《CSS 权威指南》、《Sass 实践》、《JavaScript 高性能编程》....《Webpack 实践》、《深入浅出 node.js》等不下10本书；在广度上涉及的还是很多的，但是存在问题：从事前端时间不长，前端知识杂而多，如果没有专门准备，如果突然问你一个知识点，你虽然大概知道这是啥，但是让你讲的话，你很难有条理的讲清楚。</p><p>       So，下一阶段的首要任务：“打好打牢前端基础，深入了解所用的技术栈原理”。废话少说，学问学问，不懂就弄清楚！以下“理论知识 + 实践操作”来彻底弄懂 HTTP 缓存机制及原理！</p><h3>二、缓存规则及解析</h3><p>       为方便大家理解，我假设览器存在一个缓存数据库，用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。如下流程图所示：</p><p><img src=\"\" alt=\"\" data-href=\"\" style=\"\"/></p><p><img src=\"\" alt=\"\" data-href=\"\" style=\"\"/><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1125a6943e17~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><p>       根据是否需要重新向服务器发起请求来分类，将HTTP缓存规则分为两大类(<strong>强制缓存</strong>，<strong>对比缓存</strong>)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p><p>（1）已存在缓存数据时，仅基于<strong>强制缓存</strong>，请求数据的流程如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1131a01649ce~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>（2）已存在缓存数据时，仅基于<strong>对比缓存</strong>，请求数据的流程如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a113789f814d2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>       我们可以看到两类缓存规则的不同，<strong>强制缓存</strong>如果生效，不需要再和服务器发生交互，而<strong>对比缓存</strong>不管是否生效，都需要与服务端发生交互。</p><p>       两类缓存规则可以同时存在，<strong>强制缓存</strong>优先级高于<strong>对比缓存</strong>，也就是说，当执行<strong>强制缓存</strong>的规则时，如果缓存生效，直接使用缓存，不再执行<strong>对比缓存</strong>规则。</p><h3>三、缓存常用字段</h3><h3>1、http1.0时期的缓存方案</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a119737ecdeb2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>注意： </p><p>（1）如果使用了<code>Pragma: 'no-cache'</code>的话，再设置<code>Expires</code>或者<code>Cache-Control</code>，就没有用了，说明<code>Pragma</code>的权值比后两者高。</p><p> （2）如果设置了<code>Expires</code>之后，客户端在需要请求数据的时候，首先会对比当前系统时间和这个<code>Expires</code>时间，如果没有超过<code>Expires</code>时间，则直接读取本地磁盘中的缓存数据，不发送请求。<br></p><h3>2、http1.1 时期的缓存方案</h3><p><strong>2.1、Cache-Control 字段 </strong></p><p><strong>2.1.1、Cache-Control 作为请求头字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11b7c6a465ba~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>（1）Cache-Control: no-cache </strong></p><p>使用<code>no-cache</code>指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 <code>no-cache</code> 指令，则表示客户端将不会接收缓存的资源。每次请求都是从服务器获取资源，返回304。<br> </p><p><strong>（2）Cache-Control: no-store </strong></p><p>使用<code>no-store</code> 指令表示请求的资源不会被缓存，下次任何其它请求获取该资源，还是会从服务器获取，返回 200，即资源本身。<br></p><p><strong>2.1.2、Cache-Control 作为响应头字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11c6b7651b77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>Cache-Control: public </strong></p><p>当指定使用 <code>public </code>指令时，则明确表明其他用户也可利用缓存。</p><p><strong> Cache-Control: private</strong></p><p>当指定 <code>private</code> 指令后，响应只以特定的用户作为对象，这与 <code>public</code> 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。</p><p><strong> Cache-Control: no-cache </strong></p><p>如果服务器返回的响应中包含<code> no-cache </code>指令，每次客户端请求，必需先向服务器确认其有效性，如果资源没有更改，则返回304. </p><p><strong>Cache-Control: no-store </strong></p><p>不对响应的资源进行缓存，即用户下次请求还是返回 200，返回资源本身。 </p><p><strong>Cache-Control: max-age=604800（单位：秒） </strong></p><p>资源缓存在本地浏览器的时间，如果超过该时间，则重新向服务器获取。<br></p><p><strong>2.2、请求头部字段 & 响应头部字段</strong></p><p><strong>2.2.1、请求头部字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11dbaa0f8a2a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.2.2、响应头部字段</strong><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11e177c975f2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>注意：</p><p> （1）<code>If-None-Match</code>的优先级比<code>If-Modified-Since</code>高，所以两者同时存在时，遵从前者。<br></p><h3>四、实验验证</h3><p><strong>1、实验1 — 请求的资源没修改，验证2种缓存出现的情形</strong></p><p>服务端使用 node.js ， 客户端使用 axios 进行请求：</p><p><strong>1.1、请求头部 / 响应头部 设置<br></strong></p><p>（1）服务端响应头部设置：</p><p>     res.setHeader('Cache-Control', 'public, max-age=10');</p><p>（2）客户端请求头部使用默认设置</p><p><br></p><p><strong>1.2、实验步骤</strong></p><p>（1）请求 3 次，第一次请求请求资源；第二次在10秒内再次请求该资源，第三次在 10 秒后再次请求该资源（实验过程中，服务端的资源没有进行改变）</p><p><br></p><p><strong>1.3、实验结果</strong></p><p>      3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（10 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（10 秒后）请求该资源时，因为资源缓存时间（10 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源没有做更改，所以返回 304，让客户端直接从浏览器缓存中获取该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a11ff1e022d96~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.1、第一次请求资源</strong></p><p> 第一次请求资源的请求头部和响应头部的截图如下所示，因为第一次请求该资源，本地并没有缓存，所以直接从服务器获取该资源；我们从截图可以看到，服务器返回改资源的响应头部中包含3个属性与资源缓存相关：</p><p>（1）cache-control: public, max-age=10</p><p> &nbsp; &nbsp; 缓存规则的设置，我们这个示例中，设置缓存规则为 public, 并且设置缓存过期时间为10秒；</p><p>（2）etag: W/\"95f15b-16994d7ebf6\"</p><p> &nbsp; &nbsp; 资源的唯一标识符，客户端下次访问该资源时，会在请求头中携带 etag 去向服务器确认，该资源是否被修改；</p><p>（3）last-modified: Tue, 19 Mar 2019 07:26:12 GMT</p><p> &nbsp; &nbsp; 资源最后一次修改时间，客户端下次访问该资源时，会在请求头中携带该信息去向服务器进行匹配，该资源是否被修改；</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12072e2e0cb6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.2、第二次请求资源（10秒内，即在缓存时间失效前）</strong></p><p>       第二次请求资源的请求头部和响应头部的截图如下所示，因为第二次请求该资源，该资源本地缓存还没失效，所以就直接从浏览器缓存中获取该资源。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a120bbf711005~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>1.3.3、第三次请求资源（10秒后，即在缓存时间失效后）</strong></p><p>       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1211c38c875b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2、实验2 — 请求的资源进行修改，验证2种缓存出现的情形</strong></p><p>服务端使用 node.js ， 客户端使用 axios 进行请求：</p><p><strong>2.1、请求头部 / 响应头部 设置</strong></p><p>（1）服务端响应头部设置：</p><p>     res.setHeader('Cache-Control', 'public, max-age=20');</p><p>（2）客户端请求头部使用默认设置</p><p><br></p><p><strong>2.2、实验步骤</strong></p><p>（1）请求 3 次，第一次请求资源；然后在服务器对请求的资源进行修改，第二次在 20 秒内再次请求该资源，第三次在 20 秒后再次请求该资源</p><p><br></p><p><strong>2.3、实验结果</strong></p><p>       3 次请求的 HTTP 信息如下图所示，从图中的信息可以得出，第一次请求该资源是从服务器获取；第二次（20 秒内）请求该资源是直接从浏览器缓存中获取该资源（没有向服务器确认）；第三次（20 秒后）请求该资源时，因为资源缓存时间（20 秒）过期，所以向服务器获取资源，服务器判断该资源与本地缓存的资源不同，所以重新返回该资源；以下，根据 HTTP 头部信息详细介绍三个操作的交互过程。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121606944373~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.1、第一次请求资源</strong></p><p>       第一次请求资源的请求头部和响应头部的截图如下所示，具体详细信息与 1.3.1 小节相同，在此不同重复介绍。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1219166741f1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.2、第二次请求资源（20 秒内，即在缓存时间失效前）</strong></p><p>      第二次请求资源的请求头部和响应头部的截图如下所示，（注意：即使此时服务器上的资源已经更改，但是由于缓存在浏览器中的资源没有过期，所以还是从缓存中返回旧资源）。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a121db9c73552~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><strong>2.3.3、第三次请求资源（20 秒后，即在缓存时间失效后）</strong></p><p>       第三次请求资源的请求头部和响应头部的截图如下所示，因为第三次请求该资源，该资源本地缓存已经失效，所以在请求头部中加入 If-Modified-Since 和 If-None-Match 属性，来向服务器进行确认该资源是否有被更改，从下图中可以看到，响应头部的属性 etag 与 请求头部的属性 If-None-Match &nbsp;不同，响应头部的属性 If-Modified-Since 与 请求头部的属性 last-modified 不同；所以服务器返回该资源的最新资源。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a1221529a99db~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><h3>五、总结</h3><p>1、对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p><p>2、对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p><p>总结流程图如下所示：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a12255df4532a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><em>有任何问题欢迎留言讨论，如果觉得对你有帮助，请点赞鼓励~</em><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/22/169a123d14bbb808~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/><br></p><p>作者：我是你的超级英雄<br>链接：https://juejin.cn/post/6844903801778864136<br>来源：稀土掘金</p>","art_author":"yellow star","art_createtime":"2022-11-25T02:33:28.000Z","art_tags":4}},"__N_SSG":true}