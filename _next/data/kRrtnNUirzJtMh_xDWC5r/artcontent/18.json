{"pageProps":{"datas":{"id":18,"art_title":"2022/08/24 09:06","art_content":"<h3 style=\"text-align: start;\">ISR</h3><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">Next.js 推出的 ISR(Incremental Static Regeneration) 方案，允许在</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>应用运行时再重新生成每个页面 HTML，而不需要重新构建整个应用</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">。这样即使有海量页面，也能使用上 SSG 的特性。一般来说，使用 ISR 需要 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 和 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 同时配合使用。举个例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  const paths = await fetch('https://.../posts');\r\n  return {\r\n    paths,\r\n    // 页面请求的降级策略，这里是指不降级，等待页面生成后再返回，类似于 SSR\r\n    fallback: 'blocking'\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    },\r\n    // 开启 ISR，最多每10s重新生成一次页面\r\n    revalidate: 10,\r\n  }\r\n}</code></pre><p style=\"text-align: start;\">在应用编译构建阶段，会生成已经确定的静态页面，和上面 SSG 执行流程一致。</p><p style=\"text-align: start;\">在 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>getStaticProps</code></span> 函数返回的对象中增加 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>revalidate</code></span> 属性，表示开启 ISR。在上面的例子中，指定 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>revalidate = 10</code></span>，表示最多10秒内重新生成一次静态 HTML。当浏览器请求已在构建时渲染生成的页面时，首先返回的是缓存的 HTML，10s 后页面开始重新渲染，页面成功生成后，更新缓存，浏览器再次请求页面时就能拿到最新渲染的页面内容了。</p><p style=\"text-align: start;\">对于浏览器请求构建时未生成的页面时，会马上生成静态 HTML。在这个过程中，<span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>getStaticPaths</code></span> 返回的 <span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback</code></span> 字段有以下的选项：</p><ul style=\"text-align: start;\"><li><span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: 'blocking'</code></span>：不降级，并且要求用户请求一直等到新页面静态生成结束，静态页面生成结束后会缓存</li><li><span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: true</code></span>：降级，先返回降级页面，当静态页面生成结束后，会返回一个 JSON 供降级页面 CSR 使用，经过二次渲染后，完整页面出来了</li></ul><p style=\"text-align: start;\">在上面的例子中，使用的是不降级方案(<span style=\"background-color: rgba(27, 31, 35, 0.05); font-size: 12px;\"><code>fallback: 'blocking'</code></span>)，实际上和 SSR 方案有相似之处，都是阻塞渲染，只不过多了缓存而已。</p><p style=\"text-align: start;\">If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path.</p><p style=\"text-align: start;\">也不是所有场景都适合使用 ISR。对于实时性要求较高的场景，比如新闻资讯类的网站，可能 SSR 才是最好的选择。</p>","art_author":"yellow star","art_createtime":"2022-08-24T01:07:51.000Z","art_tags":null}},"__N_SSG":true}