{"pageProps":{"datas":{"id":19,"art_title":"SSG","art_content":"<h3 style=\"text-align: start;\">SSG</h3><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">SSG(Static Site Generation) 是指在应用编译构建时预先渲染页面，并生成静态的 HTML。把生成的 HTML 静态资源部署到服务器后，浏览器不仅首次能请求到带页面内容的 HTML ，而且不需要服务器实时渲染和响应，大大节约了服务器运维成本和资源。</span></p><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">Next.js 默认为每个页面开启 SSG。对于页面内容需要依赖静态数据的场景，允许在每个页面中 </span>export<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 一个 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 异步函数，在这个函数中可以把该页面组件所需要的数据收集并返回。当 </span>getStaticProps<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 函数执行完成后，页面组件就能在 </span>props<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 中拿到这些数据并执行静态渲染。举个在静态路由中使用 SSG 的例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/first-post.js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticProps() {\r\n  // 模拟获取静态数据\r\n  const postData = await getPostData();\r\n  return {\r\n    props: { postData }\r\n  }\r\n}</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">对于动态路由的场景，Next.js 是如何做 SSG 的呢？Next.js 提供 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 异步函数，在这个方法中，会返回一个 </span>paths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 数组，这个数组包含了这个动态路由在构建时需要预渲染的页面数据。举个例子：</span></p><pre><code class=\"language-javascript\">// pages/posts/[id].js\r\nfunction Post(props) {\r\n  const { postData } = props;\r\n  \r\n  return &lt;div&gt;{postData.title}&lt;/div&gt;\r\n}\r\n\r\nexport async function getStaticPaths() {\r\n  // 返回该动态路由可能会渲染的页面数据，比如 params.id\r\n  const paths = [\r\n    {\r\n      params: { id: 'ssg-ssr' }\r\n    },\r\n    {\r\n      params: { id: 'pre-rendering' }\r\n    }\r\n  ]\r\n  return {\r\n    paths,\r\n    // 命中尚未生成静态页面的路由直接返回 404 页面\r\n    fallback: false\r\n  }\r\n}\r\n\r\nexport async function getStaticProps({ params }) {\r\n  // 使用 params.id 获取对应的静态数据\r\n  const postData = await getPostData(params.id)\r\n  return {\r\n    props: {\r\n      postData\r\n    }\r\n  }\r\n}</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">当我们执行 </span>nextjs build<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 后，可以看到打包结果包含 </span>pre-rendering.html<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 和 </span>ssg-ssr.html<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 两个 HTML 页面，也就是说在执行 SSG 时，会对 </span>getStaticPaths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 函数返回的 </span>paths<span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"> 数组进行循环，逐一预渲染页面组件并生成 HTML。</span></p><pre><code >├── server\r\n|  ├── chunks\r\n|  ├── pages\r\n|  |  ├── api\r\n|  |  ├── index.html\r\n|  |  ├── index.js\r\n|  |  ├── index.json\r\n|  |  └── posts\r\n|  |     ├── [id].js\r\n|  |     ├── first-post.html\r\n|  |     ├── first-post.js\r\n|  |     ├── pre-rendering.html       # 预渲染生成 pre-rendering 页面\r\n|  |     ├── pre-rendering.json\r\n|  |     ├── ssg-ssr.html             # 预渲染生成 ssg-ssr 页面\r\n|  |     └── ssg-ssr.json</code></pre><p><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">SSG 虽然很好解决了白屏时间过长和 SEO 不友好的问题，但是它仅仅适合于页面内容较为静态的场景，比如官网、博客等。面对</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>页面数据更新频繁</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">或</span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\"><strong>页面数量很多</strong></span><span style=\"color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-size: 14px;\">的情况，它似乎显得有点束手无策，毕竟在静态构建时不能拿到最新的数据和无法枚举海量页面。这时，就需要增量静态再生成(Incremental Static Regeneration)方案了。</span></p>","art_author":"yellow star","art_createtime":"2022-08-24T01:38:08.000Z","art_tags":null}},"__N_SSG":true}