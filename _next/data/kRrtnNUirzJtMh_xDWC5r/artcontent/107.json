{"pageProps":{"datas":{"id":107,"art_title":"React.memo()、useCallback()、useMemo()实现减少子组件渲染","art_content":"<h2>React.memo()</h2><p>React.memo 为高阶组件。它与React.PureComponent非常相似。</p><p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。这与shouldComponentUpdate 方法的返回值相反。</p><pre><code class=\"language-javascript\">function MyComponent(props) {\r\n  /* 使用 props 渲染 */\r\n}\r\nfunction areEqual(prevProps, nextProps) {\r\n  /*\r\n  如果把 nextProps 传入 render 方法的返回结果与\r\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\r\n  否则返回 false\r\n  */\r\n}\r\nexport default React.memo(MyComponent, areEqual);</code></pre><p><strong>问题：</strong>如果此时在子组件引用了事件处理函数的话， React.memo()将会失效，因为父组件在每次重新渲染时，定义的事件函数也会重新声明，对子组件来说，该事件属性已经发生改变了所以每次都会重新渲染；</p><pre><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={(newName) =&gt; setName(newName)}/&gt;</code></pre><blockquote style=\"text-align: start;\">注意: 如果直接使用<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>useState</code></span>解构的setName传给子组件, 子组件将不会重复渲染，因为解构出来的是一个memoized 函数。</blockquote><pre style=\"text-align: start;\"><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={setName}/&gt;</code></pre><p>如何解决因事件函数产生的重复渲染呢，这个时候需要用到useCallback()了</p><h2>useCallback()</h2><p><span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">把内联回调函数及依赖项数组作为参数传入 </span>useCallback<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">，它将返回该回调函数的</span>memoized回调函数<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">，该回调函数仅在某个依赖项改变时才会更新</span></p><blockquote><span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>memoized</code></span>回调函数: 使用一组参数初次调用函数时，缓存参数和计算结果，当再次使用相同的参数调用该函数时，直接返回相应的缓存结果。(返回对应饮用，所以恒等于 ===)</blockquote><pre><code class=\"language-javascript\">&lt;ChildMemo name={name} onClick={ useCallback((newName: string) =&gt; setName(newName), []) }/&gt;</code></pre><h2 style=\"text-align: start;\">useMemo()</h2><p><span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">上面的例子中，name 属性是个字符串，如果换成传递对象会怎样？</span></p><pre><code class=\"language-javascript\">const userInfo={name:\"jack\",age:16}\nreturn (\n    ...\n    &lt;ChildMemo userInfo={userInfo} /&gt;\n)\n</code></pre><p>更新父组件的其他state变量，看到子组件每次都重新渲染了。<br>分析原因跟调用函数是一样的：</p><ul><li>更新父组件state，触发父组件重新渲染；</li><li>父组件渲染，userInfo 会重新生成一个新对象，导致传递给子组件的 userInfo 属性值变化，进而导致子组件重新渲染。</li><li>注意: 如果使用<code>useState</code>解构的userInfo, 子组件将不会重复渲染，因为解构出来的是一个memoized 值。</li></ul><p>解决：<span style=\"color: rgb(43, 43, 43); background-color: rgb(255, 255, 255); font-size: 14px;\">使用 useMemo 将对象属性包一层。useMemo()返回一个 memoized 值。</span></p><pre><code class=\"language-javascript\">const userInfo = useMemo(() =&gt; ({ name: \"小明\", age: 18 }), []);\nreturn (\n    ...\n    &lt;ChildMemo userInfo={userInfo} /&gt;\n)</code></pre><p><br></p>","art_author":"yellow star","art_createtime":"2022-12-08T02:48:09.000Z","art_tags":8}},"__N_SSG":true}