{"pageProps":{"datas":{"id":69,"art_title":"【技术】structuredClone深拷贝","art_content":"<h2>对象转换为 JSON 字符串，再转换为对象</h2><pre><code class=\"language-javascript\">const obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = JSON.parse(JSON.stringify(obj));\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }\n</code></pre><p>JSON.parse(JSON.stringify(obj))可比上面 deepClone 函数简洁多了，但不是好的实践，因为它有以下缺点：</p><ul><li style=\"text-align: left;\">会忽略 undefined</li><li style=\"text-align: left;\">会忽略 symbol</li><li style=\"text-align: left;\">不能序列化函数</li><li style=\"text-align: left;\">不能解决循环引用的对象</li><li style=\"text-align: left;\">如果 data 里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li style=\"text-align: left;\">致命缺陷，性能差</li></ul><h2 style=\"text-align: left;\">structuredClone</h2><p style=\"text-align: left;\"><span style=\"color: rgb(0, 0, 0); font-size: 13px; font-family: &quot;Courier New&quot;;\">structuredClone</span>&nbsp;是 HTML5 一个新的 API，它可以实现深拷贝。</p><pre><code >const obj = { a: 1, b: 2, c: { d: 4 } };\nconst copy = structuredClone(obj);\ncopy.c.d = 5;\nconsole.log(obj); // { a: 1, b: 2, c: { d: 4 } }</code></pre><p>该方法还支持把原始值中的 transferable objects (en-US) (可转移对象) 转移到新对象，而不是把属性引用拷贝过去。 可转移对象与原始对象分离并附加到新对象;它们不可以在原始对象中访问被访问到。目前要考虑浏览器以及nodejs版本兼容性问题</p>","art_author":"yellow star","art_createtime":"2022-11-02T04:07:59.000Z","art_tags":null}},"__N_SSG":true}