{"pageProps":{"datas":{"id":93,"art_title":"React 搭建后台项目","art_content":"<h2>创建一个项目</h2><h3><span style=\"color: rgb(0, 0, 0);\">官网推荐的工具链</span></h3><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">React 团队主要推荐这些解决方案：</span></p><ul><li><span style=\"color: rgb(26, 26, 26);\">如果你是在</span><strong>学习 React</strong><span style=\"color: rgb(26, 26, 26);\"> 或</span><strong>创建一个新的</strong>单页<strong>应用</strong><span style=\"color: rgb(26, 26, 26);\">，请使用 </span>Create React App<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在</span><strong>用 Node.js 构建服务端渲染的网站</strong><span style=\"color: rgb(26, 26, 26);\">，试试 </span>Next.js<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在构建</span><strong>内容主导的静态网站</strong><span style=\"color: rgb(26, 26, 26);\">，试试 </span>Gatsby<span style=\"color: rgb(26, 26, 26);\">。</span></li><li><span style=\"color: rgb(26, 26, 26);\">如果你是在打造</span><strong>组件库</strong><span style=\"color: rgb(26, 26, 26);\">或</span><strong>将 React 集成到现有代码仓库</strong><span style=\"color: rgb(26, 26, 26);\">，尝试</span>更灵活的工具链<span style=\"color: rgb(26, 26, 26);\">。</span></li></ul><h3><span style=\"color: rgb(0, 0, 0);\">Create React App</span></h3><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\">Create React App</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 是一个用于</span><strong>学习 React</strong><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 的舒适环境，也是用 React 创建</span><strong>新的</strong><a href=\"https://zh-hans.reactjs.org/docs/glossary.html#single-page-application\" target=\"_blank\">单页</a><strong>应用</strong><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">的最佳方式。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 </span><a href=\"https://nodejs.org/en/\" target=\"_blank\">Node &gt;= 14.0.0 和 npm &gt;= 5.6</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">。要创建项目，请执行：</span></p><pre><code >npx create-react-app my-app \ncd my-app \nnpm start\n</code></pre><p><strong>注意</strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">第一行的 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">npx</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 不是拼写错误 —— 它是 </span>npm 5.2+ 附带的 package 运行工具<span style=\"color: rgb(0, 0, 0); font-size: 16px;\">。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 </span><a href=\"https://babeljs.io/\" target=\"_blank\">Babel</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 和 </span><a href=\"https://webpack.js.org/\" target=\"_blank\">webpack</a><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">，但你无需了解它们的任何细节。</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 16px;\">当你准备好部署到生产环境时，执行 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">npm run build</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 会在 </span><span style=\"color: rgb(26, 26, 26); font-size: 16px;\">build</span><span style=\"color: rgb(0, 0, 0); font-size: 16px;\"> 文件夹内生成你应用的优化版本。</span></p><p>项目初始页面：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667288055402-d6851283-8b72-48bb-b4cb-dab40dea6a4b.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p>初始目录结构：</p><pre><code >my-app\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\t\t\t\t\t\t\t\t\t # 不参与编译的资源文件\n│   ├── favicon.ico\n│   ├── index.html\n│   └── manifest.json\n└── src\t\t\t\t\t\t\t\t\t\t\t # 主程序目录\t\t\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    └── serviceWorker.js\n    └── setupTests.js</code></pre><h3>一个模块（页面/组件）的基本代码结构</h3><p>hello.jsx:</p><pre><code >import React, { useState } from 'react'\nimport styles from './index.module.scss'\n\nconst app = () =&gt; {\n  \n  const [data, setData] = useState('hello world')\n  \n  const onChange = () =&gt; {\n    setActiveKey('changed')\n  }\n\n  return (\n    &lt;div className={styles.box} onClick={onChange}&gt;\n  \t\t{data}\n    &lt;/div&gt;\n  )\n}\n\nexport default app\n</code></pre><h2>构建路由 <span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router</span></h2><p>为什么要使用路由？</p><p>传统web开发是每一个请求地址都会请求服务器来进行处理，但是用户有些操作则无需请求服务器，直接页面端修改下逻辑就能达到目的，这种最好使用路由，使用路由时，url也是随着改变的，用户浏览到一个网页时可以直接复制或收藏当前页的url给别人，这种方式对于搜索引擎和用户来说都是友好的。</p><p><br></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router</span></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">React Router是为React（一个用于构建用户界面的 JavaScript 库）设计的一个功能齐全的可以用在客户端和服务端的路由库，它可以在React运行的地方运行，在web上，node.js在服务器上，以及React Native上。</span></p><h3><span style=\"font-size: 16px;\">安装</span></h3><p><span style=\"font-size: 16px;\">在项目目录下，使用npm下载</span></p><pre><code >npm install react-router-dom@6 history@5</code></pre><h3>项目中使用</h3><p><span style=\"font-size: 16px;\">首先创建路由：选定一个入口文件，并引入 </span><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">BrowserRouter 组件包裹整个应用；添加路由、嵌套路由、重定向；</span></p><p><span style=\"color: rgb(28, 30, 33); font-size: 16px;\">入口文件：</span></p><pre><code >import React, { } from 'react'\nimport './App.css'\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route,\n  Navigate\n} from 'react-router-dom'\nimport DefaultLayout from '@/components/Layouts/DefaultLayout'\nimport routesData from './router/routes'\nimport Login from './pages/Login'\n\nfunction App () {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;Router&gt;\n        &lt;Routes&gt;\n          {/* 首次进入页面是重定向到/home路径 */}\n          &lt;Route path=\"/\" element={&lt;Navigate to=\"/home\" /&gt;}&gt;&lt;/Route&gt;\n          &lt;Route element={&lt;DefaultLayout /&gt;}&gt;\n            {routesData.map((item: any, index: number) =&gt; {\n              return (\n                &lt;Route\n                  path={item.path}\n                  key={index}\n                  element={&lt;item.component /&gt;}\n                &gt;&lt;/Route&gt;\n              )\n            })}\n          &lt;/Route&gt;\n          &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;div className=\"noFound\"&gt;Not Found&lt;/div&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Router&gt;\n    &lt;/div&gt;\n  )\n}\nexport default App</code></pre><p><span style=\"font-size: 16px;\">路由之间的跳转</span></p><p><span style=\"font-size: 16px;\">方法一：</span></p><pre><code >import { Link } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;div&gt;\n        &lt;Link to=\"/home\"&gt;home&lt;/Link&gt;\n        &lt;Link to=\"/login\"&gt;login&lt;/Link&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p><span style=\"font-size: 16px;\">方法二：</span></p><pre><code >import { useNavigate } from \"react-router-dom\";\n\nexport default function App() {\n  const navigate = useNavigate()\n  return (\n    &lt;div&gt;\n        &lt;button onClick={()=&gt;navigate('/home')}&gt;home&lt;/button&gt;\n        &lt;button onClick={()=&gt;navigate('/login')}&gt;login&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><h2>配置Antd组件库</h2><p><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">antd</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\"> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</span></p><p style=\"text-align: left;\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1667289069588-daffe4f2-9fbc-4a09-886d-daa1658ebade.png\" alt=\"\" data-href=\"\" style=\"\"></p><p><span style=\"color: rgba(0, 0, 0, 0.85);\">✨</span><strong> 特性：</strong></p><ul><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🌈 提炼自企业级中后台产品的交互语言和视觉风格。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">📦 开箱即用的高质量 React 组件。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🛡 使用 TypeScript 开发，提供完整的类型定义文件。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">⚙️ 全链路开发和设计工具体系。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🌍 数十个国际化语言支持。</span></li><li><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">🎨 深入每个细节的主题定制能力。</span></li></ul><p><br></p><p>安装使用</p><pre><code >npm install antd</code></pre><p>使用一个按钮组件</p><pre><code >import React from 'react';\nimport { Button } from 'antd';\nimport './App.css';\n\nconst App = () =&gt; (\n  &lt;div className=\"App\"&gt;\n    &lt;Button type=\"primary\"&gt;Button&lt;/Button&gt;\n  &lt;/div&gt;\n);\n\nexport default App;</code></pre><p>导入样式，<span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">修改 </span><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">src/App.css</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">，在文件顶部引入 </span><span style=\"color: rgba(0, 0, 0, 0.85); background-color: rgb(242, 244, 245);\">antd/dist/antd.css</span><span style=\"color: rgba(0, 0, 0, 0.85); font-size: 14px;\">。</span></p><pre><code >@import '~antd/dist/antd.css';</code></pre><p>全局配置中文语言环境，默认情况下，antd语言是英文，需要手动修改回中文环境</p><p>index.js:</p><pre><code >import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\nimport { ConfigProvider } from 'antd'\nimport zhCN from 'antd/es/locale/zh_CN'\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n)\nroot.render(\n  // ConfigProvider antd全局配置中文语言环境\n  &lt;ConfigProvider locale={zhCN}&gt;\n    &lt;App /&gt;\n  &lt;/ConfigProvider&gt;\n)\n\nreportWebVitals()\n</code></pre><h2>封装全局组件</h2><p>在src/components路径下创建全局组件,解决重复利用，开发代码基本和页面开发一致，</p><p>举个例子：</p><pre><code >import styles from './index.module.scss'\nimport React, { } from 'react'\n\nconst App = (props) =&gt; {\n  const { title = '段落标题', children, style } = props\n  return (\n    &lt;div className={styles.box} style={style}&gt;\n      &lt;div className={styles.header}&gt;&lt;div className={styles.headerItem}&gt;{title}&lt;/div&gt;&lt;/div&gt;\n      &lt;div className={styles.content}&gt;{ children}&lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\nexport default App\n</code></pre><p>调用</p><pre><code >import Plates from '@/components/Plates'\n\n...\n\n&lt;Plates title={'费用详情'}&gt;\n  &lt;Table\n    columns={columns}\n    dataSource={data}\n    pagination={false}\n    bordered\n    size={'small'}\n  /&gt;\n&lt;/Plates&gt;</code></pre><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668648752246-771519a6-4446-48b8-a095-848e711a9bcc.png\" alt=\"\" data-href=\"\" style=\"\"/></p><h2>二次封装请求函数</h2><h3><span style=\"color: rgb(51, 51, 51);\">Axios 是什么?</span></h3><p>Axios 是一个基于 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fpromise-basics\" target=\"_blank\">promise</a> 网络请求库，作用于<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2F\" target=\"_blank\">node.js</a> 和浏览器中。 它是 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.lullabot.com%2Farticles%2Fwhat-is-an-isomorphic-application\" target=\"_blank\">isomorphic</a> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><p><strong>特性</strong></p><ul><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">从浏览器中创建 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">XMLHttpRequests</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">从 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">node.js</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> 创建 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">http</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">请求</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">支持 </span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">Promise</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> API</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">拦截请求和响应</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">转换请求数据和响应数据</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">取消请求</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">自动转换</span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\"> JSON</span><span style=\"color: rgb(51, 51, 51); font-size: 16px;\"> 数据</span></li><li><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">客户端支持防御</span><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245); font-size: 16px;\">XSRF</span></li></ul><h3><span style=\"background-color: rgb(255, 245, 245);\">基本使用</span></h3><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">安装</span></p><pre><code >npm install axios</code></pre><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">导入</span></p><pre><code >import axios from 'axios'</code></pre><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">发送请求</span></p><pre><code >axios({        \n  url:'xxx',    // 设置请求的地址\n  method:\"GET\", // 设置请求方法\n  params:{      // get请求使用params进行参数凭借,如果是post请求用data\n    type: '',\n    page: 1\n  }\n}).then(res =&gt; {  \n  // res为后端返回的数据\n  console.log(res);   \n})\n</code></pre><h3><span style=\"color: rgb(51, 51, 51);\">为什么要封装</span></h3><p>axios 的 API 很友好，完全可以很轻松地在项目中直接使用。</p><p>不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍，这种重复劳动不仅浪费时间，而且让代码变得冗余增加，难以维护。为了提高代码质量，所以应该在项目中二次封装 axios 再使用。</p><h3>如何封装</h3><ul><li>封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间......</li><li>设置接口请求前缀：根据开发、测试、预发、生产环境的不同，前缀需要加以区分；</li><li>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(比如：用户信息)；</li><li>状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好；</li><li>请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便</li><li>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</li><li>响应拦截器： 这块就是根据 后端返回来的状态码判定执行不同业务</li></ul><p>代码实例：</p><pre><code >import axios from 'axios'\nimport { message, notification } from 'antd'\n\nconst openNotification = (msg) =&gt; {\n  notification.error({\n    message: '请联系管理员',\n    description: msg\n  })\n}\n\nconst showStatus = (status) =&gt; {\n  let message = ''\n  switch (status) {\n    case 400:\n      message = '请求错误(400)'\n      break\n    case 401:\n      message = '未授权，请重新登录(401)'\n      break\n    case 402:\n      message = '拒绝访问(402)'\n      break\n    case 404:\n      message = '请求出错(404)'\n      break\n    case 408:\n      message = '请求超时(408)'\n      break\n    case 500:\n      message = '服务器错误(500)'\n      break\n    case 501:\n      message = '服务未实现(501)'\n      break\n    case 502:\n      message = '网络错误(502)'\n      break\n    case 503:\n      message = '服务不可用(503)'\n      break\n    case 504:\n      message = '网络超时(504)'\n      break\n    case 505:\n      message = 'HTTP版本不受支持(505)'\n      break\n    default:\n      message = `连接出错(${status})!`\n  }\n  return `${message}，请检查网络或联系管理员！`\n}\n\nconst service = axios.create({\n  // 联调\n\n  headers: {\n    get: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    },\n    post: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    }\n  },\n  // 是否跨站点访问控制请求\n  withCredentials: false,\n  timeout: 30000,\n  validateStatus () {\n    // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常\n    return true\n  }\n})\n\n// 请求拦截器\nservice.interceptors.request.use(\n  config =&gt; {\n    // 将 token 添加到请求头\n    const token = localStorage.getItem('token')\n    token && (config.headers.token = token)\n    return config\n  },\n  (err) =&gt; {\n    err.message = '服务器异常，请联系管理员！'\n    // 错误抛到业务代码\n    return Promise.reject(err)\n  }\n)\n\n// 响应拦截器\nservice.interceptors.response.use(\n  response =&gt; {\n    const status = response.status\n    let msg = ''\n    if ((status &lt; 200) || (status &gt;= 300 && status !== 401 && status !== 500)) {\n      // 处理http错误，抛到业务代码\n      msg = showStatus(status)\n      openNotification(msg)\n      if (typeof response.data === 'string') {\n        response.data = { msg }\n      } else {\n        response.data.msg = msg\n      }\n      return response\n    } else if (status === 200) {\n      if (!response.data.success) {\n        message.error(response.data.message)\n      }\n      return response.data\n    } else if (status === 500) {\n      msg = showStatus(status)\n      openNotification(msg)\n      response.data = { msg }\n      //   router.replace({name:'exception',query:{type:500}})\n      return response\n    }\n  },\n  (err) =&gt; {\n    err.message = '请求超时或服务器异常，请检查网络或联系管理员！'\n    openNotification('请求超时或服务器异常，请检查网络或联系管理员！')\n    // return Promise.reject(err)\n  }\n)\n\nexport default service\n</code></pre><h2>CSS Modules + node-sass</h2><h3>什么是CSS Modules</h3><p><span style=\"color: rgb(10, 10, 35);\">所有的类名和动画名称默认都有各自的作用域的 CSS 文件。</span></p><p><span style=\"color: rgb(10, 10, 35);\">所以 CSS Modules 既不是官方标准，也不是浏览器的特性，而是在构建步骤（例如使用 Webpack 或 Browserify）中对 CSS 类名和选择器限定作用域的一种方式（类似于命名空间）。</span></p><h3>node-sass</h3><p><span style=\"color: rgb(10, 10, 35);\">node sass是一个库，它将Node.js绑定到LibSass【流行样式表预处理器Sass的C版本】，它允许用户以令人难以置信的速度将【.scss】文件本地编译为css，并通过连接中间件自动编译。</span></p><h3><span style=\"color: rgb(33, 37, 41);\">为什么使用scss，而不是传统的css</span></h3><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">使用 scss 可以编写清晰、无冗余、语义化的 css。</span></p><p><strong>变量</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">是 scss 提供的最基本的工具。通过变量可以让独立的 css 值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。</span></p><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">同样基础的是 scss 的 </span><strong>嵌套机制</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">。嵌套允许css规则内嵌套css规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。scss同时提供了特殊的</span><strong>父选择器标识符 &</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\"> ，通过它可以构造出更高效的嵌套。</span></p><p><strong>混合器</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">允许用户编写语义化样式的同时避免视觉层面上样式的重复。使用混合器减少重复，使用混合器让你的css变得更加可维护和语义化。</span></p><p><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">与混合器相辅相成的</span><strong>选择器继承</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。</span></p><p><strong>样式导入</strong><span style=\"color: rgb(33, 37, 41); font-size: 16px;\">，scss 的另一个重要特性。通过样式导入可以把分散在多个sass文件中的内容合并生成到一个css文件，避免了项目中有大量的css文件通过原生的css @import带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。</span></p><h2>状态管理工具 mobx</h2><p><em>简单、可扩展的状态管理</em></p><h3><span style=\"color: rgb(51, 51, 51);\">Mobx工作流程</span></h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/29349018/1668651326688-11627ad0-e87a-463e-82a5-09d5445f86a4.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><span style=\"color: rgb(51, 51, 51); font-size: 16px;\">React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</span></p><h2><span style=\"font-size: 14px;\">ESlint代码规范</span></h2><p><a href=\"https://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy\" target=\"\">https://www.yuque.com/yuhucoldchain/rg9z8o/eaegfy</a></p><h2>项目优化</h2><h4><span style=\"font-size: 14px;\">绝对路径 @ </span></h4><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">使用</span><a href=\"https://github.com/timarney/react-app-rewired\" target=\"_blank\">react-app-rewired</a><span style=\"font-size: 14px;\">来对react-scripts进行hack。</span></p><pre><code >$ yarn add -D react-app-rewired //或 $ npm install react-app-rewired --save-dev</code></pre><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">然后修改</span><strong>package.json</strong><span style=\"font-size: 14px;\">，将</span><strong>start</strong><span style=\"font-size: 14px;\">、</span><strong>build</strong><span style=\"font-size: 14px;\">、</span><strong>test</strong><span style=\"font-size: 14px;\">三个命令由react-scripts换成</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">react-app-rewired</span></p><pre><code >\"scripts\": { \n  \t\"start\": \"react-app-rewired start\", \n    \"build\": \"react-app-rewired build\", \n    \"test\": \"react-app-rewired test\", \n    \"eject\": \"react-scripts eject\" \n},</code></pre><p style=\"text-align: left;\"><span style=\"font-size: 14px;\">在根目录下创建</span><strong>config-overrides.js</strong><span style=\"font-size: 14px;\">：</span></p><pre><code >const path = require('path'); \nconst rootPath = path.resolve(__dirname, 'src'); \n\nmodule.exports = { \n  webpack: (config) =&gt; { \n    config.resolve.alias['@'] = rootPath; \n    return config; \n  }, \n}</code></pre><p style=\"text-align: left;\"><strong>注意：</strong><span style=\"font-size: 14px;\">修改完文件后，</span><strong>必须先重启项目</strong><span style=\"font-size: 14px;\">，然后再使用绝对路径，</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">@</span><span style=\"font-size: 14px;\">代表的就是</span><span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 12px;\">根目录/src</span><span style=\"font-size: 14px;\"> 。</span></p><h4>helper.js</h4><h4>页面跳转过渡状态</h4><p><br></p><p><br></p><p><br></p>","art_author":"yellow star","art_createtime":"2022-11-17T03:04:38.000Z","art_tags":4}},"__N_SSG":true}